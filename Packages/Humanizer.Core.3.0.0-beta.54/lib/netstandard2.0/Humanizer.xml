<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Humanizer</name>
    </assembly>
    <members>
        <member name="T:System.Runtime.CompilerServices.CallerArgumentExpressionAttribute">
            <summary>
            Indicates that a parameter captures the expression passed for another parameter as a string.
            </summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.CallerArgumentExpressionAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Runtime.CompilerServices.CallerArgumentExpressionAttribute"/> class.
            </summary>
            <param name="parameterName">
            The name of the parameter whose expression should be captured as a string.
            </param>
        </member>
        <member name="P:System.Runtime.CompilerServices.CallerArgumentExpressionAttribute.ParameterName">
            <summary>
            Gets the name of the parameter whose expression should be captured as a string.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute">
            <summary>
            Indicates that compiler support for a particular feature is required for the location where this attribute is applied.
            </summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.#ctor(System.String)">
            <summary>
            Initialize a new instance of <see cref="T:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute"/>
            </summary>
            <param name="featureName">The name of the required compiler feature.</param>
        </member>
        <member name="P:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.FeatureName">
            <summary>
            The name of the compiler feature.
            </summary>
        </member>
        <member name="P:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.IsOptional">
            <summary>
            If true, the compiler can choose to allow access to the location where this attribute is applied if it does not understand <see cref="P:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.FeatureName"/>.
            </summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.RefStructs">
            <summary>
            The <see cref="P:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.FeatureName"/> used for the ref structs C# feature.
            </summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.RequiredMembers">
            <summary>
            The <see cref="P:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.FeatureName"/> used for the required members C# feature.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.DisableRuntimeMarshallingAttribute">
             <summary>
             Disables the built-in runtime managed/unmanaged marshalling subsystem for
             P/Invokes, Delegate types, and unmanaged function pointer invocations.
             </summary>
             <remarks>
             The built-in marshalling subsystem has some behaviors that cannot be changed due to
             backward-compatibility requirements. This attribute allows disabling the built-in
             subsystem and instead uses the following rules for P/Invokes, Delegates,
             and unmanaged function pointer invocations:
            
             - All value types that do not contain reference type fields recursively (<c>unmanaged</c> in C#) are blittable
             - Value types that recursively have any fields that have <c>[StructLayout(LayoutKind.Auto)]</c> are disallowed from interop.
             - All reference types are disallowed from usage in interop scenarios.
             - SetLastError support in P/Invokes is disabled.
             - varargs support is disabled.
             - LCIDConversionAttribute support is disabled.
             </remarks>
        </member>
        <member name="T:System.Runtime.CompilerServices.IsExternalInit">
            <summary>
            Reserved to be used by the compiler for tracking metadata. This class should not be used by developers in source code.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.ModuleInitializerAttribute">
             <summary>
             Used to indicate to the compiler that a method should be called
             in its containing module's initializer.
             </summary>
             <remarks>
             When one or more valid methods
             with this attribute are found in a compilation, the compiler will
             emit a module initializer which calls each of the attributed methods.
            
             Certain requirements are imposed on any method targeted with this attribute:
             - The method must be `static`.
             - The method must be an ordinary member method, as opposed to a property accessor, constructor, local function, etc.
             - The method must be parameterless.
             - The method must return `void`.
             - The method must not be generic or be contained in a generic type.
             - The method's effective accessibility must be `internal` or `public`.
            
             The specification for module initializers in the .NET runtime can be found here:
             https://github.com/dotnet/runtime/blob/master/docs/design/specs/Ecma-335-Augments.md#module-initializer
             </remarks>
        </member>
        <member name="T:System.Runtime.CompilerServices.RequiredMemberAttribute">
            <summary>
            Specifies that a type has required members or that a member is required.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.SkipLocalsInitAttribute">
            <summary>
            Used to indicate to the compiler that the <c>.locals init</c>
            flag should not be set in method headers.
            </summary>
            <remarks>
            This attribute is unsafe because it may reveal uninitialized memory to
            the application in certain instances (e.g., reading from uninitialized
            stackalloc'd memory). If applied to a method directly, the attribute
            applies to that method and all nested functions (lambdas, local
            functions) below it. If applied to a type or module, it applies to all
            methods nested inside. This attribute is intentionally not permitted on
            assemblies. Use at the module level instead to apply to multiple type
            declarations.
            </remarks>
        </member>
        <member name="T:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler">
            <summary>Provides a handler used by the language compiler to process interpolated strings into <see cref="T:System.String"/> instances.</summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.GuessedLengthPerHole">
            <summary>Expected average length of formatted data used for an individual interpolation expression result.</summary>
            <remarks>
            This is inherited from string.Format, and could be changed based on further data.
            string.Format actually uses `format.Length + args.Length * 8`, but format.Length
            includes the format items themselves, e.g. "{0}", and since it's rare to have double-digit
            numbers of items, we bump the 8 up to 11 to account for the three extra characters in "{d}",
            since the compiler-provided base length won't include the equivalent character count.
            </remarks>
        </member>
        <member name="F:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.MinimumArrayPoolLength">
            <summary>Minimum size array to rent from the pool.</summary>
            <remarks>Same as stack-allocation size used today by string.Format.</remarks>
        </member>
        <member name="F:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.StringMaxLength">
            <summary>Maximum length allowed for a string.</summary>
            <remarks>Keep in sync with AllocateString in gchelpers.cpp.</remarks>
        </member>
        <member name="F:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler._provider">
            <summary>Optional provider to pass to IFormattable.ToString or ISpanFormattable.TryFormat calls.</summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler._arrayToReturnToPool">
            <summary>Array rented from the array pool and used to back <see cref="F:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler._chars"/>.</summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler._chars">
            <summary>The span to write into.</summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler._pos">
            <summary>Position at which to write the next character.</summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler._hasCustomFormatter">
            <summary>Whether <see cref="F:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler._provider"/> provides an ICustomFormatter.</summary>
            <remarks>
            Custom formatters are very rare.  We want to support them, but it's ok if we make them more expensive
            in order to make them as pay-for-play as possible.  So, we avoid adding another reference type field
            to reduce the size of the handler and to reduce required zero'ing, by only storing whether the provider
            provides a formatter, rather than actually storing the formatter.  This in turn means, if there is a
            formatter, we pay for the extra interface call on each AppendFormatted that needs it.
            </remarks>
        </member>
        <member name="M:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.#ctor(System.Int32,System.Int32)">
            <summary>Creates a handler used to translate an interpolated string into a <see cref="T:System.String"/>.</summary>
            <param name="literalLength">The number of constant characters outside of interpolation expressions in the interpolated string.</param>
            <param name="formattedCount">The number of interpolation expressions in the interpolated string.</param>
            <remarks>This is intended to be called only by compiler-generated code. Arguments are not validated as they'd otherwise be for members intended to be used directly.</remarks>
        </member>
        <member name="M:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.#ctor(System.Int32,System.Int32,System.IFormatProvider)">
            <summary>Creates a handler used to translate an interpolated string into a <see cref="T:System.String"/>.</summary>
            <param name="literalLength">The number of constant characters outside of interpolation expressions in the interpolated string.</param>
            <param name="formattedCount">The number of interpolation expressions in the interpolated string.</param>
            <param name="provider">An object that supplies culture-specific formatting information.</param>
            <remarks>This is intended to be called only by compiler-generated code. Arguments are not validated as they'd otherwise be for members intended to be used directly.</remarks>
        </member>
        <member name="M:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.#ctor(System.Int32,System.Int32,System.IFormatProvider,System.Span{System.Char})">
            <summary>Creates a handler used to translate an interpolated string into a <see cref="T:System.String"/>.</summary>
            <param name="literalLength">The number of constant characters outside of interpolation expressions in the interpolated string.</param>
            <param name="formattedCount">The number of interpolation expressions in the interpolated string.</param>
            <param name="provider">An object that supplies culture-specific formatting information.</param>
            <param name="initialBuffer">A buffer temporarily transferred to the handler for use as part of its formatting.  Contents may be overwritten.</param>
            <remarks>This is intended to be called only by compiler-generated code. Arguments are not validated as they'd otherwise be for members intended to be used directly.</remarks>
        </member>
        <member name="M:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.GetDefaultLength(System.Int32,System.Int32)">
            <summary>Derives a default length with which to seed the handler.</summary>
            <param name="literalLength">The number of constant characters outside of interpolation expressions in the interpolated string.</param>
            <param name="formattedCount">The number of interpolation expressions in the interpolated string.</param>
        </member>
        <member name="M:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.ToString">
            <summary>Gets the built <see cref="T:System.String"/>.</summary>
            <returns>The built string.</returns>
        </member>
        <member name="M:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.ToStringAndClear">
            <summary>Gets the built <see cref="T:System.String"/> and clears the handler.</summary>
            <returns>The built string.</returns>
            <remarks>
            This releases any resources used by the handler. The method should be invoked only
            once and as the last thing performed on the handler. Subsequent use is erroneous, ill-defined,
            and may destabilize the process, as may using any other copies of the handler after ToStringAndClear
            is called on any one of them.
            </remarks>
        </member>
        <member name="M:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.Clear">
            <summary>Clears the handler, returning any rented array to the pool.</summary>
        </member>
        <member name="P:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.Text">
            <summary>Gets a span of the written characters thus far.</summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.AppendLiteral(System.String)">
            <summary>Writes the specified string to the handler.</summary>
            <param name="value">The string to write.</param>
        </member>
        <member name="M:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.AppendFormatted``1(``0)">
            <summary>Writes the specified value to the handler.</summary>
            <param name="value">The value to write.</param>
            <typeparam name="T">The type of the value to write.</typeparam>
        </member>
        <member name="M:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.AppendFormatted``1(``0,System.String)">
            <summary>Writes the specified value to the handler.</summary>
            <param name="value">The value to write.</param>
            <param name="format">The format string.</param>
            <typeparam name="T">The type of the value to write.</typeparam>
        </member>
        <member name="M:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.AppendFormatted``1(``0,System.Int32)">
            <summary>Writes the specified value to the handler.</summary>
            <param name="value">The value to write.</param>
            <param name="alignment">
            Minimum number of characters that should be written for this value.  If the value is negative, it indicates
            left-aligned and the required minimum is the absolute value.
            </param>
            <typeparam name="T">The type of the value to write.</typeparam>
        </member>
        <member name="M:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.AppendFormatted``1(``0,System.Int32,System.String)">
            <summary>Writes the specified value to the handler.</summary>
            <param name="value">The value to write.</param>
            <param name="format">The format string.</param>
            <param name="alignment">
            Minimum number of characters that should be written for this value.  If the value is negative, it indicates
            left-aligned and the required minimum is the absolute value.
            </param>
            <typeparam name="T">The type of the value to write.</typeparam>
        </member>
        <member name="M:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.AppendFormatted(System.ReadOnlySpan{System.Char})">
            <summary>Writes the specified character span to the handler.</summary>
            <param name="value">The span to write.</param>
        </member>
        <member name="M:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.AppendFormatted(System.ReadOnlySpan{System.Char},System.Int32,System.String)">
            <summary>Writes the specified string of chars to the handler.</summary>
            <param name="value">The span to write.</param>
            <param name="alignment">
            Minimum number of characters that should be written for this value.  If the value is negative, it indicates
            left-aligned and the required minimum is the absolute value.
            </param>
            <param name="format">The format string.</param>
        </member>
        <member name="M:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.AppendFormatted(System.String)">
            <summary>Writes the specified value to the handler.</summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.AppendFormattedSlow(System.String)">
            <summary>Writes the specified value to the handler.</summary>
            <param name="value">The value to write.</param>
            <remarks>
            Slow path to handle a custom formatter, potentially null value,
            or a string that doesn't fit in the current buffer.
            </remarks>
        </member>
        <member name="M:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.AppendFormatted(System.String,System.Int32,System.String)">
            <summary>Writes the specified value to the handler.</summary>
            <param name="value">The value to write.</param>
            <param name="alignment">
            Minimum number of characters that should be written for this value.  If the value is negative, it indicates
            left-aligned and the required minimum is the absolute value.
            </param>
            <param name="format">The format string.</param>
        </member>
        <member name="M:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.AppendFormatted(System.Object,System.Int32,System.String)">
            <summary>Writes the specified value to the handler.</summary>
            <param name="value">The value to write.</param>
            <param name="alignment">
            Minimum number of characters that should be written for this value.  If the value is negative, it indicates
            left-aligned and the required minimum is the absolute value.
            </param>
            <param name="format">The format string.</param>
        </member>
        <member name="M:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.HasCustomFormatter(System.IFormatProvider)">
            <summary>Gets whether the provider provides a custom formatter.</summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.AppendCustomFormatter``1(``0,System.String)">
            <summary>Formats the value using the custom formatter from the provider.</summary>
            <param name="value">The value to write.</param>
            <param name="format">The format string.</param>
            <typeparam name="T">The type of the value to write.</typeparam>
        </member>
        <member name="M:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.AppendOrInsertAlignmentIfNeeded(System.Int32,System.Int32)">
            <summary>Handles adding any padding required for aligning a formatted value in an interpolation expression.</summary>
            <param name="startingPos">The position at which the written value started.</param>
            <param name="alignment">
            Non-zero minimum number of characters that should be written for this value.  If the value is negative, it
            indicates left-aligned and the required minimum is the absolute value.
            </param>
        </member>
        <member name="M:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.EnsureCapacityForAdditionalChars(System.Int32)">
            <summary>
            Ensures <see cref="F:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler._chars"/> has the capacity to store <paramref name="additionalChars"/> beyond <see cref="F:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler._pos"/>.
            </summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.GrowThenCopyString(System.String)">
            <summary>
            Fallback for fast path in <see cref="M:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.AppendLiteral(System.String)"/> when there's not enough space in the destination.
            </summary>
            <param name="value">The string to write.</param>
        </member>
        <member name="M:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.GrowThenCopySpan(System.ReadOnlySpan{System.Char})">
            <summary>
            Fallback for <see cref="M:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.AppendFormatted(System.ReadOnlySpan{System.Char})"/> for when not enough space exists in the current buffer.
            </summary>
            <param name="value">The span to write.</param>
        </member>
        <member name="M:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.Grow(System.Int32)">
            <summary>
            Grows <see cref="F:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler._chars"/> to have the capacity to store at least <paramref name="additionalChars"/>
            beyond <see cref="F:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler._pos"/>.
            </summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.Grow">
            <summary>Grows the size of <see cref="F:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler._chars"/>.</summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.GrowCore(System.UInt32)">
            <summary>
            Grow the size of <see cref="F:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler._chars"/> to at least the specified <paramref name="requiredMinCapacity"/>.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute">
            <summary>
            Indicates which arguments to a method involving an interpolated string handler should be passed to that handler.
            </summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute"/> class.
            </summary>
            <param name="argument">The name of the argument that should be passed to the handler.</param>
            <remarks><see langword="null"/> may be used as the name of the receiver in an instance method.</remarks>
        </member>
        <member name="M:System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute.#ctor(System.String[])">
            <summary>
            Initializes a new instance of the <see cref="T:System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute"/> class.
            </summary>
            <param name="arguments">The names of the arguments that should be passed to the handler.</param>
            <remarks><see langword="null"/> may be used as the name of the receiver in an instance method.</remarks>
        </member>
        <member name="P:System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute.Arguments">
            <summary>Gets the names of the arguments that should be passed to the handler.</summary>
            <remarks>
            <see langword="null"/> may be used as the name of the receiver in an instance method.
            </remarks>
        </member>
        <member name="T:System.Runtime.CompilerServices.InterpolatedStringHandlerAttribute">
            <summary>
            Indicates the attributed type is to be used as an interpolated string handler.
            </summary>
        </member>
        <member name="T:System.Runtime.Versioning.OSPlatformAttribute">
            <summary>
            Base type for all platform-specific API attributes.
            </summary>
        </member>
        <member name="T:System.Runtime.Versioning.ObsoletedOSPlatformAttribute">
            <summary>
            Marks APIs that were obsoleted in a given operating system version.
            </summary>
            <remarks>
            Primarily used by OS bindings to indicate APIs that should not be used anymore.
            </remarks>
        </member>
        <member name="T:System.Runtime.Versioning.SupportedOSPlatformAttribute">
             <summary>
             Records the operating system (and minimum version) that supports an API. Multiple attributes can be
             applied to indicate support on multiple operating systems.
             </summary>
             <remarks>
             Callers can apply a <see cref="T:System.Runtime.Versioning.SupportedOSPlatformAttribute" />
             or use guards to prevent calls to APIs on unsupported operating systems.
            
             A given platform should only be specified once.
             </remarks>
        </member>
        <member name="T:System.Runtime.Versioning.SupportedOSPlatformGuardAttribute">
             <summary>
             Annotates a custom guard field, property or method with a supported platform name and optional version.
             Multiple attributes can be applied to indicate guard for multiple supported platforms.
             </summary>
             <remarks>
             Callers can apply a <see cref="T:System.Runtime.Versioning.SupportedOSPlatformGuardAttribute" /> to a field, property or method
             and use that field, property or method in a conditional or assert statements in order to safely call platform specific APIs.
            
             The type of the field or property should be boolean, the method return type should be boolean in order to be used as platform guard.
             </remarks>
        </member>
        <member name="T:System.Runtime.Versioning.TargetPlatformAttribute">
            <summary>
            Records the platform that the project targeted.
            </summary>
        </member>
        <member name="T:System.Runtime.Versioning.UnsupportedOSPlatformAttribute">
            <summary>
            Marks APIs that were removed in a given operating system version.
            </summary>
            <remarks>
            Primarily used by OS bindings to indicate APIs that are only available in
            earlier versions.
            </remarks>
        </member>
        <member name="T:System.Runtime.Versioning.UnsupportedOSPlatformGuardAttribute">
             <summary>
             Annotates the custom guard field, property or method with an unsupported platform name and optional version.
             Multiple attributes can be applied to indicate guard for multiple unsupported platforms.
             </summary>
             <remarks>
             Callers can apply a <see cref="T:System.Runtime.Versioning.UnsupportedOSPlatformGuardAttribute" /> to a field, property or method
             and use that  field, property or method in a conditional or assert statements as a guard to safely call APIs unsupported on those platforms.
            
             The type of the field or property should be boolean, the method return type should be boolean in order to be used as platform guard.
             </remarks>
        </member>
        <member name="T:System.Runtime.InteropServices.SuppressGCTransitionAttribute">
             <summary>
             An attribute used to indicate a GC transition should be skipped when making an unmanaged function call.
             </summary>
             <example>
             Example of a valid use case. The Win32 `GetTickCount()` function is a small performance related function
             that reads some global memory and returns the value. In this case, the GC transition overhead is significantly
             more than the memory read.
             <code>
             using System;
             using System.Runtime.InteropServices;
             class Program
             {
                 [DllImport("Kernel32")]
                 [SuppressGCTransition]
                 static extern int GetTickCount();
                 static void Main()
                 {
                     Console.WriteLine($"{GetTickCount()}");
                 }
             }
             </code>
             </example>
             <remarks>
             This attribute is ignored if applied to a method without the <see cref="T:System.Runtime.InteropServices.DllImportAttribute"/>.
            
             Forgoing this transition can yield benefits when the cost of the transition is more than the execution time
             of the unmanaged function. However, avoiding this transition removes some of the guarantees the runtime
             provides through a normal P/Invoke. When exiting the managed runtime to enter an unmanaged function the
             GC must transition from Cooperative mode into Preemptive mode. Full details on these modes can be found at
             https://github.com/dotnet/runtime/blob/master/docs/coding-guidelines/clr-code-guide.md#2.1.8.
             Suppressing the GC transition is an advanced scenario and should not be done without fully understanding
             potential consequences.
            
             One of these consequences is an impact to Mixed-mode debugging (https://docs.microsoft.com/visualstudio/debugger/how-to-debug-in-mixed-mode).
             During Mixed-mode debugging, it is not possible to step into or set breakpoints in a P/Invoke that
             has been marked with this attribute. A workaround is to switch to native debugging and set a breakpoint in the native function.
             In general, usage of this attribute is not recommended if debugging the P/Invoke is important, for example
             stepping through the native code or diagnosing an exception thrown from the native code.
            
             The runtime may load the native library for method marked with this attribute in advance before the method is called for the first time.
             Usage of this attribute is not recommended for platform neutral libraries with conditional platform specific code.
            
             The P/Invoke method that this attribute is applied to must have all of the following properties:
               * Native function always executes for a trivial amount of time (less than 1 microsecond).
               * Native function does not perform a blocking syscall (e.g. any type of I/O).
               * Native function does not call back into the runtime (e.g. Reverse P/Invoke).
               * Native function does not throw exceptions.
               * Native function does not manipulate locks or other concurrency primitives.
            
             Consequences of invalid uses of this attribute:
               * GC starvation.
               * Immediate runtime termination.
               * Data corruption.
             </remarks>
        </member>
        <member name="T:System.Runtime.InteropServices.UnmanagedCallersOnlyAttribute">
            <summary>
            Any method marked with <see cref="T:System.Runtime.InteropServices.UnmanagedCallersOnlyAttribute" /> can be directly called from
            native code. The function token can be loaded to a local variable using the <see href="https://docs.microsoft.com/dotnet/csharp/language-reference/operators/pointer-related-operators#address-of-operator-">address-of</see> operator
            in C# and passed as a callback to a native method.
            </summary>
            <remarks>
            Methods marked with this attribute have the following restrictions:
              * Method must be marked "static".
              * Must not be called from managed code.
              * Must only have <see href="https://docs.microsoft.com/dotnet/framework/interop/blittable-and-non-blittable-types">blittable</see> arguments.
            </remarks>
        </member>
        <member name="F:System.Runtime.InteropServices.UnmanagedCallersOnlyAttribute.CallConvs">
            <summary>
            Optional. If omitted, the runtime will use the default platform calling convention.
            </summary>
            <remarks>
            Supplied types must be from the official "System.Runtime.CompilerServices" namespace and
            be of the form "CallConvXXX".
            </remarks>
        </member>
        <member name="F:System.Runtime.InteropServices.UnmanagedCallersOnlyAttribute.EntryPoint">
            <summary>
            Optional. If omitted, no named export is emitted during compilation.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.ExperimentalAttribute">
            <summary>
            Indicates that a parameter captures the expression passed for another parameter as a string.
            </summary>
            <summary>
             Indicates that an API is experimental and it may change in the future.
            </summary>
            <remarks>
              This attribute allows call sites to be flagged with a diagnostic that indicates that an experimental
              feature is used. Authors can use this attribute to ship preview features in their assemblies.
            </remarks>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.ExperimentalAttribute.#ctor(System.String)">
            <summary>
             Initializes a new instance of the <see cref="T:System.Diagnostics.CodeAnalysis.ExperimentalAttribute"/> class, specifying the ID that the compiler will use
             when reporting a use of the API the attribute applies to.
            </summary>
            <param name="diagnosticId">The ID that the compiler will use when reporting a use of the API the attribute applies to.</param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.ExperimentalAttribute.DiagnosticId">
            <summary>
             Gets the ID that the compiler will use when reporting a use of the API the attribute applies to.
            </summary>
            <value>The unique diagnostic ID.</value>
            <remarks>
             The diagnostic ID is shown in build output for warnings and errors.
             <para>This property represents the unique ID that can be used to suppress the warnings or errors, if needed.</para>
            </remarks>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.ExperimentalAttribute.UrlFormat">
            <summary>
             Gets or sets the URL for corresponding documentation.
             The API accepts a format string instead of an actual URL, creating a generic URL that includes the diagnostic ID.
            </summary>
            <value>The format string that represents a URL to corresponding documentation.</value>
            <remarks>An example format string is <c>https://contoso.com/obsoletion-warnings/{0}</c>.</remarks>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.AllowNullAttribute">
            <summary>
              Specifies that <see langword="null"/> is allowed as an input even if the
              corresponding type disallows it.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DisallowNullAttribute">
            <summary>
              Specifies that <see langword="null"/> is disallowed as an input even if the
              corresponding type allows it.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute">
            <summary>
              Specifies that a method that will never return under any circumstance.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute">
            <summary>
              Specifies that the method will not return if the associated <see cref="T:System.Boolean"/>
              parameter is passed the specified value.
            </summary>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute.ParameterValue">
            <summary>
              Gets the condition parameter value.
              Code after the method is considered unreachable by diagnostics if the argument
              to the associated parameter matches this value.
            </summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute.#ctor(System.Boolean)">
            <summary>
              Initializes a new instance of the <see cref="T:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute"/>
              class with the specified parameter value.
            </summary>
            <param name="parameterValue">
              The condition parameter value.
              Code after the method is considered unreachable by diagnostics if the argument
              to the associated parameter matches this value.
            </param>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MaybeNullAttribute">
            <summary>
              Specifies that an output may be <see langword="null"/> even if the
              corresponding type disallows it.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute">
            <summary>
              Specifies that when a method returns <see cref="P:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute.ReturnValue"/>,
              the parameter may be <see langword="null"/> even if the corresponding type disallows it.
            </summary>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute.ReturnValue">
            <summary>
              Gets the return value condition.
              If the method returns this value, the associated parameter may be <see langword="null"/>.
            </summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute.#ctor(System.Boolean)">
            <summary>
               Initializes the attribute with the specified return value condition.
            </summary>
            <param name="returnValue">
              The return value condition.
              If the method returns this value, the associated parameter may be <see langword="null"/>.
            </param>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute">
            <summary>
              Specifies that the method or property will ensure that the listed field and property members have
              not-<see langword="null"/> values.
            </summary>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute.Members">
            <summary>
              Gets field or property member names.
            </summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute.#ctor(System.String)">
            <summary>
              Initializes the attribute with a field or property member.
            </summary>
            <param name="member">
              The field or property member that is promised to be not-null.
            </param>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute.#ctor(System.String[])">
            <summary>
              Initializes the attribute with the list of field and property members.
            </summary>
            <param name="members">
              The list of field and property members that are promised to be not-null.
            </param>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute">
            <summary>
              Specifies that the method or property will ensure that the listed field and property members have
              non-<see langword="null"/> values when returning with the specified return value condition.
            </summary>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.ReturnValue">
            <summary>
              Gets the return value condition.
            </summary>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.Members">
            <summary>
              Gets field or property member names.
            </summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.#ctor(System.Boolean,System.String)">
            <summary>
              Initializes the attribute with the specified return value condition and a field or property member.
            </summary>
            <param name="returnValue">
              The return value condition. If the method returns this value,
              the associated parameter will not be <see langword="null"/>.
            </param>
            <param name="member">
              The field or property member that is promised to be not-<see langword="null"/>.
            </param>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.#ctor(System.Boolean,System.String[])">
            <summary>
              Initializes the attribute with the specified return value condition and list
              of field and property members.
            </summary>
            <param name="returnValue">
              The return value condition. If the method returns this value,
              the associated parameter will not be <see langword="null"/>.
            </param>
            <param name="members">
              The list of field and property members that are promised to be not-null.
            </param>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.NotNullAttribute">
            <summary>
              Specifies that an output is not <see langword="null"/> even if the
              corresponding type allows it.
            </summary>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute.ParameterName">
            <summary>
              Gets the associated parameter name.
              The output will be non-<see langword="null"/> if the argument to the
              parameter specified is non-<see langword="null"/>.
            </summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute.#ctor(System.String)">
            <summary>
              Initializes the attribute with the associated parameter name.
            </summary>
            <param name="parameterName">
              The associated parameter name.
              The output will be non-<see langword="null"/> if the argument to the
              parameter specified is non-<see langword="null"/>.
            </param>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute">
            <summary>
              Specifies that when a method returns <see cref="P:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.ReturnValue"/>,
              the parameter will not be <see langword="null"/> even if the corresponding type allows it.
            </summary>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.ReturnValue">
            <summary>
              Gets the return value condition.
              If the method returns this value, the associated parameter will not be <see langword="null"/>.
            </summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.#ctor(System.Boolean)">
            <summary>
              Initializes the attribute with the specified return value condition.
            </summary>
            <param name="returnValue">
              The return value condition.
              If the method returns this value, the associated parameter will not be <see langword="null"/>.
            </param>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.SetsRequiredMembersAttribute">
            <summary>
            Specifies that this constructor sets all required members for the current type, and callers
            do not need to set any required members themselves.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute">
            <summary>
            Specifies the syntax used in a string.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.#ctor(System.String)">
            <summary>
            Initializes the <see cref="T:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute"/> with the identifier of the syntax used.</summary>
            <param name="syntax">The syntax identifier.</param>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.#ctor(System.String,System.Object[])">
            <summary>
            Initializes the <see cref="T:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute"/> with the identifier of the syntax used.</summary>
            <param name="syntax">The syntax identifier.</param>
            <param name="arguments">Optional arguments associated with the specific syntax employed.</param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.Syntax">
            <summary>Gets the identifier of the syntax used.</summary>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.Arguments">
            <summary>Optional arguments associated with the specific syntax employed.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.CompositeFormat">
            <summary>The syntax identifier for strings containing composite formats for string formatting.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.DateOnlyFormat">
            <summary>The syntax identifier for strings containing date format specifiers.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.DateTimeFormat">
            <summary>The syntax identifier for strings containing date and time format specifiers.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.EnumFormat">
            <summary>The syntax identifier for strings containing <see cref="T:System.Enum"/> format specifiers.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.GuidFormat">
            <summary>The syntax identifier for strings containing <see cref="T:System.Guid"/> format specifiers.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.Json">
            <summary>The syntax identifier for strings containing JavaScript Object Notation (JSON).</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.NumericFormat">
            <summary>The syntax identifier for strings containing numeric format specifiers.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.Regex">
            <summary>The syntax identifier for strings containing regular expressions.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.TimeOnlyFormat">
            <summary>The syntax identifier for strings containing time format specifiers.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.TimeSpanFormat">
            <summary>The syntax identifier for strings containing <see cref="T:System.TimeSpan"/> format specifiers.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.Uri">
            <summary>The syntax identifier for strings containing URIs.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.Xml">
            <summary>The syntax identifier for strings containing XML.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DynamicDependencyAttribute">
            <summary>
            States a dependency that one member has on another.
            </summary>
            <remarks>
            This can be used to inform tooling of a dependency that is otherwise not evident purely from
            metadata and IL, for example a member relied on via reflection.
            </remarks>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.DynamicDependencyAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Diagnostics.CodeAnalysis.DynamicDependencyAttribute"/> class
            with the specified signature of a member on the same type as the consumer.
            </summary>
            <param name="memberSignature">The signature of the member depended on.</param>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.DynamicDependencyAttribute.#ctor(System.String,System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Diagnostics.CodeAnalysis.DynamicDependencyAttribute"/> class
            with the specified signature of a member on a <see cref="T:System.Type"/>.
            </summary>
            <param name="memberSignature">The signature of the member depended on.</param>
            <param name="type">The <see cref="T:System.Type"/> containing <paramref name="memberSignature"/>.</param>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.DynamicDependencyAttribute.#ctor(System.String,System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Diagnostics.CodeAnalysis.DynamicDependencyAttribute"/> class
            with the specified signature of a member on a type in an assembly.
            </summary>
            <param name="memberSignature">The signature of the member depended on.</param>
            <param name="typeName">The full name of the type containing the specified member.</param>
            <param name="assemblyName">The assembly name of the type containing the specified member.</param>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.DynamicDependencyAttribute.#ctor(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes,System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Diagnostics.CodeAnalysis.DynamicDependencyAttribute"/> class
            with the specified types of members on a <see cref="T:System.Type"/>.
            </summary>
            <param name="memberTypes">The types of members depended on.</param>
            <param name="type">The <see cref="T:System.Type"/> containing the specified members.</param>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.DynamicDependencyAttribute.#ctor(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes,System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Diagnostics.CodeAnalysis.DynamicDependencyAttribute"/> class
            with the specified types of members on a type in an assembly.
            </summary>
            <param name="memberTypes">The types of members depended on.</param>
            <param name="typeName">The full name of the type containing the specified members.</param>
            <param name="assemblyName">The assembly name of the type containing the specified members.</param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.DynamicDependencyAttribute.MemberSignature">
            <summary>
            Gets the signature of the member depended on.
            </summary>
            <remarks>
            Either <see cref="P:System.Diagnostics.CodeAnalysis.DynamicDependencyAttribute.MemberSignature"/> must be a valid string or <see cref="P:System.Diagnostics.CodeAnalysis.DynamicDependencyAttribute.MemberTypes"/>
            must not equal <see cref="F:System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.None"/>, but not both.
            </remarks>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.DynamicDependencyAttribute.MemberTypes">
            <summary>
            Gets the <see cref="T:System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes"/> which specifies the type
            of members depended on.
            </summary>
            <remarks>
            Either <see cref="P:System.Diagnostics.CodeAnalysis.DynamicDependencyAttribute.MemberSignature"/> must be a valid string or <see cref="P:System.Diagnostics.CodeAnalysis.DynamicDependencyAttribute.MemberTypes"/>
            must not equal <see cref="F:System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.None"/>, but not both.
            </remarks>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.DynamicDependencyAttribute.Type">
            <summary>
            Gets the <see cref="T:System.Type"/> containing the specified member.
            </summary>
            <remarks>
            If neither <see cref="P:System.Diagnostics.CodeAnalysis.DynamicDependencyAttribute.Type"/> nor <see cref="P:System.Diagnostics.CodeAnalysis.DynamicDependencyAttribute.TypeName"/> are specified,
            the type of the consumer is assumed.
            </remarks>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.DynamicDependencyAttribute.TypeName">
            <summary>
            Gets the full name of the type containing the specified member.
            </summary>
            <remarks>
            If neither <see cref="P:System.Diagnostics.CodeAnalysis.DynamicDependencyAttribute.Type"/> nor <see cref="P:System.Diagnostics.CodeAnalysis.DynamicDependencyAttribute.TypeName"/> are specified,
            the type of the consumer is assumed.
            </remarks>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.DynamicDependencyAttribute.AssemblyName">
            <summary>
            Gets the assembly name of the specified type.
            </summary>
            <remarks>
            <see cref="P:System.Diagnostics.CodeAnalysis.DynamicDependencyAttribute.AssemblyName"/> is only valid when <see cref="P:System.Diagnostics.CodeAnalysis.DynamicDependencyAttribute.TypeName"/> is specified.
            </remarks>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.DynamicDependencyAttribute.Condition">
            <summary>
            Gets or sets the condition in which the dependency is applicable, e.g. "DEBUG".
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes">
             <summary>
             Specifies the types of members that are dynamically accessed.
            
             This enumeration has a <see cref="T:System.FlagsAttribute"/> attribute that allows a
             bitwise combination of its member values.
             </summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.None">
            <summary>
            Specifies no members.
            </summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicParameterlessConstructor">
            <summary>
            Specifies the default, parameterless public constructor.
            </summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicConstructors">
            <summary>
            Specifies all public constructors.
            </summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicConstructors">
            <summary>
            Specifies all non-public constructors.
            </summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicMethods">
            <summary>
            Specifies all public methods.
            </summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicMethods">
            <summary>
            Specifies all non-public methods.
            </summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicFields">
            <summary>
            Specifies all public fields.
            </summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicFields">
            <summary>
            Specifies all non-public fields.
            </summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicNestedTypes">
            <summary>
            Specifies all public nested types.
            </summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicNestedTypes">
            <summary>
            Specifies all non-public nested types.
            </summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties">
            <summary>
            Specifies all public properties.
            </summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicProperties">
            <summary>
            Specifies all non-public properties.
            </summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicEvents">
            <summary>
            Specifies all public events.
            </summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicEvents">
            <summary>
            Specifies all non-public events.
            </summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.Interfaces">
            <summary>
            Specifies all interfaces implemented by the type.
            </summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.All">
            <summary>
            Specifies all members.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembersAttribute">
             <summary>
             Indicates that certain members on a specified <see cref="T:System.Type"/> are accessed dynamically,
             for example through <see cref="N:System.Reflection"/>.
             </summary>
             <remarks>
             This allows tools to understand which members are being accessed during the execution
             of a program.
            
             This attribute is valid on members whose type is <see cref="T:System.Type"/> or <see cref="T:System.String"/>.
            
             When this attribute is applied to a location of type <see cref="T:System.String"/>, the assumption is
             that the string represents a fully qualified type name.
            
             If the attribute is applied to a method it's treated as a special case and it implies
             the attribute should be applied to the "this" parameter of the method. As such the attribute
             should only be used on instance methods of types assignable to System.Type (or string, but no methods
             will use it there).
             </remarks>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembersAttribute.#ctor(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembersAttribute"/> class
            with the specified member types.
            </summary>
            <param name="memberTypes">The types of members dynamically accessed.</param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembersAttribute.MemberTypes">
            <summary>
            Gets the <see cref="T:System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes"/> which specifies the type
            of members dynamically accessed.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.RequiresDynamicCodeAttribute">
            <summary>
            Indicates that the specified method requires the ability to generate new code at runtime,
            for example through <see cref="N:System.Reflection"/>.
            </summary>
            <remarks>
            This allows tools to understand which methods are unsafe to call when compiling ahead of time.
            </remarks>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.RequiresDynamicCodeAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Diagnostics.CodeAnalysis.RequiresDynamicCodeAttribute"/> class
            with the specified message.
            </summary>
            <param name="message">
            A message that contains information about the usage of dynamic code.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.RequiresDynamicCodeAttribute.Message">
            <summary>
            Gets a message that contains information about the usage of dynamic code.
            </summary>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.RequiresDynamicCodeAttribute.Url">
            <summary>
            Gets or sets an optional URL that contains more information about the method,
            why it requires dynamic code, and what options a consumer has to deal with it.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.RequiresUnreferencedCodeAttribute">
            <summary>
            Indicates that the specified method requires dynamic access to code that is not referenced
            statically, for example through <see cref="N:System.Reflection"/>.
            </summary>
            <remarks>
            This allows tools to understand which methods are unsafe to call when removing unreferenced
            code from an application.
            </remarks>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.RequiresUnreferencedCodeAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Diagnostics.CodeAnalysis.RequiresUnreferencedCodeAttribute"/> class
            with the specified message.
            </summary>
            <param name="message">
            A message that contains information about the usage of unreferenced code.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.RequiresUnreferencedCodeAttribute.Message">
            <summary>
            Gets a message that contains information about the usage of unreferenced code.
            </summary>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.RequiresUnreferencedCodeAttribute.Url">
            <summary>
            Gets or sets an optional URL that contains more information about the method,
            why it requires unreferenced code, and what options a consumer has to deal with it.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.UnconditionalSuppressMessageAttribute">
            <summary>
            Suppresses reporting of a specific rule violation, allowing multiple suppressions on a
            single code artifact.
            </summary>
            <remarks>
            <see cref="T:System.Diagnostics.CodeAnalysis.UnconditionalSuppressMessageAttribute"/> is different than
            <see cref="T:System.Diagnostics.CodeAnalysis.SuppressMessageAttribute"/> in that it doesn't have a
            <see cref="T:System.Diagnostics.ConditionalAttribute"/>. So it is always preserved in the compiled assembly.
            </remarks>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.UnconditionalSuppressMessageAttribute.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Diagnostics.CodeAnalysis.UnconditionalSuppressMessageAttribute"/>
            class, specifying the category of the tool and the identifier for an analysis rule.
            </summary>
            <param name="category">The category for the attribute.</param>
            <param name="checkId">The identifier of the analysis rule the attribute applies to.</param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.UnconditionalSuppressMessageAttribute.Category">
            <summary>
            Gets the category identifying the classification of the attribute.
            </summary>
            <remarks>
            The <see cref="P:System.Diagnostics.CodeAnalysis.UnconditionalSuppressMessageAttribute.Category"/> property describes the tool or tool analysis category
            for which a message suppression attribute applies.
            </remarks>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.UnconditionalSuppressMessageAttribute.CheckId">
            <summary>
            Gets the identifier of the analysis tool rule to be suppressed.
            </summary>
            <remarks>
            Concatenated together, the <see cref="P:System.Diagnostics.CodeAnalysis.UnconditionalSuppressMessageAttribute.Category"/> and <see cref="P:System.Diagnostics.CodeAnalysis.UnconditionalSuppressMessageAttribute.CheckId"/>
            properties form a unique check identifier.
            </remarks>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.UnconditionalSuppressMessageAttribute.Scope">
            <summary>
            Gets or sets the scope of the code that is relevant for the attribute.
            </summary>
            <remarks>
            The Scope property is an optional argument that specifies the metadata scope for which
            the attribute is relevant.
            </remarks>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.UnconditionalSuppressMessageAttribute.Target">
            <summary>
            Gets or sets a fully qualified path that represents the target of the attribute.
            </summary>
            <remarks>
            The <see cref="P:System.Diagnostics.CodeAnalysis.UnconditionalSuppressMessageAttribute.Target"/> property is an optional argument identifying the analysis target
            of the attribute. An example value is "System.IO.Stream.ctor():System.Void".
            Because it is fully qualified, it can be long, particularly for targets such as parameters.
            The analysis tool user interface should be capable of automatically formatting the parameter.
            </remarks>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.UnconditionalSuppressMessageAttribute.MessageId">
            <summary>
            Gets or sets an optional argument expanding on exclusion criteria.
            </summary>
            <remarks>
            The <see cref="P:System.Diagnostics.CodeAnalysis.UnconditionalSuppressMessageAttribute.MessageId"/> property is an optional argument that specifies additional
            exclusion where the literal metadata target is not sufficiently precise. For example,
            the <see cref="T:System.Diagnostics.CodeAnalysis.UnconditionalSuppressMessageAttribute"/> cannot be applied within a method,
            and it may be desirable to suppress a violation against a statement in the method that will
            give a rule violation, but not against all statements in the method.
            </remarks>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.UnconditionalSuppressMessageAttribute.Justification">
            <summary>
            Gets or sets the justification for suppressing the code analysis message.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.UnscopedRefAttribute">
            <summary>
            Used to indicate a byref escapes and is not scoped.
            </summary>
            <remarks>
            <para>
            There are several cases where the C# compiler treats a <see langword="ref"/> as implicitly
            <see langword="scoped"/> - where the compiler does not allow the <see langword="ref"/> to escape the method.
            </para>
            <para>
            For example:
            <list type="number">
              <item><see langword="this"/> for <see langword="struct"/> instance methods.</item>
              <item><see langword="ref"/> parameters that refer to <see langword="ref"/> <see langword="struct"/> types.</item>
              <item><see langword="out"/> parameters.</item>
            </list>
            </para>
            <para>
            This attribute is used in those instances where the <see langword="ref"/> should be allowed to escape.
            </para>
            <para>
            Applying this attribute, in any form, has impact on consumers of the applicable API. It is necessary for
            API authors to understand the lifetime implications of applying this attribute and how it may impact their users.
            </para>
            </remarks>
        </member>
        <member name="T:System.Diagnostics.StackTraceHiddenAttribute">
            <summary>
            Types and Methods attributed with StackTraceHidden will be omitted from the stack trace text shown in StackTrace.ToString()
            and Exception.StackTrace
            </summary>
        </member>
        <member name="T:System.Diagnostics.UnreachableException">
            <summary>
            Exception thrown when the program executes an instruction that was thought to be unreachable.
            </summary>
            <seealso href="https://learn.microsoft.com/en-us/dotnet/api/system.diagnostics.unreachableexception"/>
            <seealso href="https://source.dot.net/#System.Private.CoreLib/src/libraries/System.Private.CoreLib/src/System/Diagnostics/UnreachableException.cs"/>
        </member>
        <member name="M:System.Diagnostics.UnreachableException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:System.Diagnostics.UnreachableException"/> class with the default error message.
            </summary>
        </member>
        <member name="M:System.Diagnostics.UnreachableException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Diagnostics.UnreachableException"/>
            class with a specified error message.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
        </member>
        <member name="M:System.Diagnostics.UnreachableException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Diagnostics.UnreachableException"/>
            class with a specified error message and a reference to the inner exception that is the cause of
            this exception.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="innerException">The exception that is the cause of the current exception.</param>
        </member>
        <member name="T:System.Index">
            <summary>Represent a type can be used to index a collection either from the start or the end.</summary>
            <remarks>
            Index is used by the C# compiler to support the new index syntax
            <code>
            int[] someArray = new int[5] { 1, 2, 3, 4, 5 } ;
            int lastElement = someArray[^1]; // lastElement = 5
            </code>
            </remarks>
        </member>
        <member name="M:System.Index.#ctor(System.Int32,System.Boolean)">
            <summary>Construct an Index using a value and indicating if the index is from the start or from the end.</summary>
            <param name="value">The index value. it has to be zero or positive number.</param>
            <param name="fromEnd">Indicating if the index is from the start or from the end.</param>
            <remarks>
            If the Index constructed from the end, index value 1 means pointing at the last element and index value 0 means pointing at beyond last element.
            </remarks>
        </member>
        <member name="P:System.Index.Start">
            <summary>Create an Index pointing at first element.</summary>
        </member>
        <member name="P:System.Index.End">
            <summary>Create an Index pointing at beyond last element.</summary>
        </member>
        <member name="M:System.Index.FromStart(System.Int32)">
            <summary>Create an Index from the start at the position indicated by the value.</summary>
            <param name="value">The index value from the start.</param>
        </member>
        <member name="M:System.Index.FromEnd(System.Int32)">
            <summary>Create an Index from the end at the position indicated by the value.</summary>
            <param name="value">The index value from the end.</param>
        </member>
        <member name="P:System.Index.Value">
            <summary>Returns the index value.</summary>
        </member>
        <member name="P:System.Index.IsFromEnd">
            <summary>Indicates whether the index is from the start or the end.</summary>
        </member>
        <member name="M:System.Index.GetOffset(System.Int32)">
            <summary>Calculate the offset from the start using the giving collection length.</summary>
            <param name="length">The length of the collection that the Index will be used with. length has to be a positive value</param>
            <remarks>
            For performance reason, we don't validate the input length parameter and the returned offset value against negative values.
            we don't validate either the returned offset is greater than the input length.
            It is expected Index will be used with collections which always have non negative length/count. If the returned offset is negative and
            then used to index a collection will get out of range exception which will be same affect as the validation.
            </remarks>
        </member>
        <member name="M:System.Index.Equals(System.Object)">
            <summary>Indicates whether the current Index object is equal to another object of the same type.</summary>
            <param name="value">An object to compare with this object</param>
        </member>
        <member name="M:System.Index.Equals(System.Index)">
            <summary>Indicates whether the current Index object is equal to another Index object.</summary>
            <param name="other">An object to compare with this object</param>
        </member>
        <member name="M:System.Index.GetHashCode">
            <summary>Returns the hash code for this instance.</summary>
        </member>
        <member name="M:System.Index.op_Implicit(System.Int32)~System.Index">
            <summary>Converts integer number to an Index.</summary>
        </member>
        <member name="M:System.Index.ToString">
            <summary>Converts the value of the current Index object to its equivalent string representation.</summary>
        </member>
        <member name="T:System.Range">
            <summary>Represent a range has start and end indexes.</summary>
            <remarks>
            Range is used by the C# compiler to support the range syntax.
            <code>
            int[] someArray = new int[5] { 1, 2, 3, 4, 5 };
            int[] subArray1 = someArray[0..2]; // { 1, 2 }
            int[] subArray2 = someArray[1..^0]; // { 2, 3, 4, 5 }
            </code>
            </remarks>
        </member>
        <member name="M:System.Range.#ctor(System.Index,System.Index)">
            <summary>Represent a range has start and end indexes.</summary>
            <remarks>
            Range is used by the C# compiler to support the range syntax.
            <code>
            int[] someArray = new int[5] { 1, 2, 3, 4, 5 };
            int[] subArray1 = someArray[0..2]; // { 1, 2 }
            int[] subArray2 = someArray[1..^0]; // { 2, 3, 4, 5 }
            </code>
            </remarks>
        </member>
        <member name="M:System.Range.ToString">
            <summary>Converts the value of the current Range object to its equivalent string representation.</summary>
        </member>
        <member name="M:System.Range.StartAt(System.Index)">
            <summary>Create a Range object starting from start index to the end of the collection.</summary>
        </member>
        <member name="M:System.Range.EndAt(System.Index)">
            <summary>Create a Range object starting from first element in the collection to the end Index.</summary>
        </member>
        <member name="P:System.Range.All">
            <summary>Create a Range object starting from first element to the end.</summary>
        </member>
        <member name="M:System.Range.GetOffsetAndLength(System.Int32)">
            <summary>Calculate the start offset and length of range object using a collection length.</summary>
            <param name="length">The length of the collection that the range will be used with. length has to be a positive value.</param>
            <remarks>
            For performance reason, we don't validate the input length parameter against negative values.
            It is expected Range will be used with collections which always have non negative length/count.
            We validate the range is inside the length scope though.
            </remarks>
        </member>
        <member name="T:System.Reflection.NullabilityInfo">
            <summary>
            A class that represents nullability info
            </summary>
        </member>
        <member name="P:System.Reflection.NullabilityInfo.Type">
            <summary>
            The <see cref="T:System.Type" /> of the member or generic parameter
            to which this NullabilityInfo belongs
            </summary>
        </member>
        <member name="P:System.Reflection.NullabilityInfo.ReadState">
            <summary>
            The nullability read state of the member
            </summary>
        </member>
        <member name="P:System.Reflection.NullabilityInfo.WriteState">
            <summary>
            The nullability write state of the member
            </summary>
        </member>
        <member name="P:System.Reflection.NullabilityInfo.ElementType">
            <summary>
            If the member type is an array, gives the <see cref="T:System.Reflection.NullabilityInfo" /> of the elements of the array, null otherwise
            </summary>
        </member>
        <member name="P:System.Reflection.NullabilityInfo.GenericTypeArguments">
            <summary>
            If the member type is a generic type, gives the array of <see cref="T:System.Reflection.NullabilityInfo" /> for each type parameter
            </summary>
        </member>
        <member name="T:System.Reflection.NullabilityState">
            <summary>
            An enum that represents nullability state
            </summary>
        </member>
        <member name="F:System.Reflection.NullabilityState.Unknown">
            <summary>
            Nullability context not enabled (oblivious)
            </summary>
        </member>
        <member name="F:System.Reflection.NullabilityState.NotNull">
            <summary>
            Non nullable value or reference type
            </summary>
        </member>
        <member name="F:System.Reflection.NullabilityState.Nullable">
            <summary>
            Nullable value or reference type
            </summary>
        </member>
        <member name="T:System.Reflection.NullabilityInfoContext">
            <summary>
            Provides APIs for populating nullability information/context from reflection members:
            <see cref="T:System.Reflection.ParameterInfo"/>, <see cref="T:System.Reflection.FieldInfo"/>, <see cref="T:System.Reflection.PropertyInfo"/> and <see cref="T:System.Reflection.EventInfo"/>.
            </summary>
        </member>
        <member name="M:System.Reflection.NullabilityInfoContext.Create(System.Reflection.ParameterInfo)">
            <summary>
            Populates <see cref="T:System.Reflection.NullabilityInfo" /> for the given <see cref="T:System.Reflection.ParameterInfo" />.
            If the nullablePublicOnly feature is set for an assembly, like it does in .NET SDK, the private and/or internal member's
            nullability attributes are omitted, in this case the API will return NullabilityState.Unknown state.
            </summary>
            <param name="parameterInfo">The parameter which nullability info gets populated</param>
            <exception cref="T:System.ArgumentNullException">If the parameterInfo parameter is null</exception>
            <returns><see cref="T:System.Reflection.NullabilityInfo" /></returns>
        </member>
        <member name="M:System.Reflection.NullabilityInfoContext.Create(System.Reflection.PropertyInfo)">
            <summary>
            Populates <see cref="T:System.Reflection.NullabilityInfo" /> for the given <see cref="T:System.Reflection.PropertyInfo" />.
            If the nullablePublicOnly feature is set for an assembly, like it does in .NET SDK, the private and/or internal member's
            nullability attributes are omitted, in this case the API will return NullabilityState.Unknown state.
            </summary>
            <param name="propertyInfo">The parameter which nullability info gets populated</param>
            <exception cref="T:System.ArgumentNullException">If the propertyInfo parameter is null</exception>
            <returns><see cref="T:System.Reflection.NullabilityInfo" /></returns>
        </member>
        <member name="M:System.Reflection.NullabilityInfoContext.Create(System.Reflection.EventInfo)">
            <summary>
            Populates <see cref="T:System.Reflection.NullabilityInfo" /> for the given <see cref="T:System.Reflection.EventInfo" />.
            If the nullablePublicOnly feature is set for an assembly, like it does in .NET SDK, the private and/or internal member's
            nullability attributes are omitted, in this case the API will return NullabilityState.Unknown state.
            </summary>
            <param name="eventInfo">The parameter which nullability info gets populated</param>
            <exception cref="T:System.ArgumentNullException">If the eventInfo parameter is null</exception>
            <returns><see cref="T:System.Reflection.NullabilityInfo" /></returns>
        </member>
        <member name="M:System.Reflection.NullabilityInfoContext.Create(System.Reflection.FieldInfo)">
            <summary>
            Populates <see cref="T:System.Reflection.NullabilityInfo" /> for the given <see cref="T:System.Reflection.FieldInfo" />
            If the nullablePublicOnly feature is set for an assembly, like it does in .NET SDK, the private and/or internal member's
            nullability attributes are omitted, in this case the API will return NullabilityState.Unknown state.
            </summary>
            <param name="fieldInfo">The parameter which nullability info gets populated</param>
            <exception cref="T:System.ArgumentNullException">If the fieldInfo parameter is null</exception>
            <returns><see cref="T:System.Reflection.NullabilityInfo" /></returns>
        </member>
        <member name="F:System.Text.RegularExpressions.RegexCache.DefaultMaxCacheSize">
            <summary>The default maximum number of items to store in the cache.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.RegexCache.MaxExamineOnDrop">
            <summary>The maximum number of cached items to examine when we need to replace an existing one in the cache with a new one.</summary>
            <remarks>This is a somewhat arbitrary value, chosen to be small but at least as large as DefaultMaxCacheSize.</remarks>
        </member>
        <member name="F:System.Text.RegularExpressions.RegexCache.s_lastAccessed">
            <summary>A read-through cache of one element, representing the most recently used regular expression.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.RegexCache.s_cacheDictionary">
            <summary>The thread-safe dictionary storing all the items in the cache.</summary>
            <remarks>
            The concurrency level is initialized to 1 as we're using our own global lock for all mutations, so we don't need ConcurrentDictionary's
            striped locking.  Capacity is initialized to 31, which is the same as (the private) ConcurrentDictionary.DefaultCapacity.
            </remarks>
        </member>
        <member name="F:System.Text.RegularExpressions.RegexCache.s_cacheList">
            <summary>A list of all the items in the cache.  Protected by <see cref="P:System.Text.RegularExpressions.RegexCache.SyncObj"/>.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.RegexCache.s_random">
            <summary>Random number generator used to examine a subset of items when we need to drop one from a large list.  Protected by <see cref="P:System.Text.RegularExpressions.RegexCache.SyncObj"/>.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.RegexCache.s_maxCacheSize">
            <summary>The current maximum number of items allowed in the cache.  This rarely changes.  Mostly protected by <see cref="P:System.Text.RegularExpressions.RegexCache.SyncObj"/>.</summary>
        </member>
        <member name="P:System.Text.RegularExpressions.RegexCache.SyncObj">
            <summary>Lock used to protect shared state on mutations.</summary>
        </member>
        <member name="P:System.Text.RegularExpressions.RegexCache.MaxCacheSize">
            <summary>Gets or sets the maximum size of the cache.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.RegexCache.Key">
            <summary>Used as a key for <see cref="T:System.Text.RegularExpressions.RegexCache.Node"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.RegexCache.Node">
            <summary>Node for a cached Regex instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.RegexCache.Node.#ctor(System.Text.RegularExpressions.RegexCache.Key,System.Text.RegularExpressions.Regex)">
            <summary>Node for a cached Regex instance.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.RegexCache.Node.Key">
            <summary>The key associated with this cached instance.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.RegexCache.Node.Regex">
            <summary>The cached Regex instance.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.RegexCache.Node.LastAccessStamp">
            <summary>A "time" stamp representing the approximate last access time for this Regex.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.ValueMatch">
            <summary>
            Represents the results from a single regular expression match.
            </summary>
            <remarks>
            The <see cref="T:System.Text.RegularExpressions.ValueMatch"/> type is immutable and has no public constructor. An instance of the <see cref="T:System.Text.RegularExpressions.ValueMatch"/> struct is returned by the
            <see cref="!:Regex.ValueMatchEnumerator.Current"/> method when iterating over the results from calling <see cref="!:Regex.EnumerateMatches(ReadOnlySpan&lt;char&gt;)"/>.
            </remarks>
        </member>
        <member name="M:System.Text.RegularExpressions.ValueMatch.#ctor(System.Int32,System.Int32)">
            <summary>
            Crates an instance of the <see cref="T:System.Text.RegularExpressions.ValueMatch"/> type based on the passed in <paramref name="index"/> and <paramref name="length"/>.
            </summary>
            <param name="index">The position in the original span where the first character of the captured sliced span is found.</param>
            <param name="length">The length of the captured sliced span.</param>
        </member>
        <member name="P:System.Text.RegularExpressions.ValueMatch.Index">
            <summary>
            Gets the position in the original span where the first character of the captured sliced span is found.
            </summary>
        </member>
        <member name="P:System.Text.RegularExpressions.ValueMatch.Length">
            <summary>
            Gets the length of the captured sliced span.
            </summary>
        </member>
        <member name="T:System.Text.RegularExpressions.ValueMatchEnumerator">
             <summary>
             Represents an enumerator containing the set of successful matches found by iteratively applying a regular expression pattern to the input span.
             </summary>
             <remarks>
             The enumerator has no public constructor. The <see cref="!:Regex.EnumerateMatches(ReadOnlySpan&lt;char&gt;)"/> method returns a <see cref="!:Regex.ValueMatchEnumerator"/>
             object.The enumerator will lazily iterate over zero or more <see cref="T:System.Text.RegularExpressions.ValueMatch"/> objects. If there is at least one successful match in the span, then
             <see cref="M:System.Text.RegularExpressions.ValueMatchEnumerator.MoveNext"/> returns <see langword="true"/> and <see cref="P:System.Text.RegularExpressions.ValueMatchEnumerator.Current"/> will contain the first <see cref="T:System.Text.RegularExpressions.ValueMatch"/>. If there are no successful matches,
             then <see cref="M:System.Text.RegularExpressions.ValueMatchEnumerator.MoveNext"/> returns <see langword="false"/> and <see cref="P:System.Text.RegularExpressions.ValueMatchEnumerator.Current"/> throws an <see cref="T:System.InvalidOperationException"/>.
            
             This type is a ref struct since it stores the input span as a field in order to be able to lazily iterate over it.
             </remarks>
        </member>
        <member name="M:System.Text.RegularExpressions.ValueMatchEnumerator.#ctor(System.Text.RegularExpressions.Regex,System.ReadOnlySpan{System.Char},System.Int32)">
            <summary>
            Creates an instance of the <see cref="T:System.Text.RegularExpressions.ValueMatchEnumerator"/> for the passed in <paramref name="regex"/> which iterates over <paramref name="input"/>.
            </summary>
            <param name="regex">The <see cref="T:System.Text.RegularExpressions.Regex"/> to use for finding matches.</param>
            <param name="input">The input span to iterate over.</param>
            <param name="startAt">The position where the engine should start looking for matches from.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.ValueMatchEnumerator.GetEnumerator">
            <summary>
            Provides an enumerator that iterates through the matches in the input span.
            </summary>
            <returns>A copy of this enumerator.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.ValueMatchEnumerator.MoveNext">
            <summary>
            Advances the enumerator to the next match in the span.
            </summary>
            <returns>
            <see langword="true"/> if the enumerator was successfully advanced to the next element; <see langword="false"/> if the enumerator cannot find additional matches.
            </returns>
        </member>
        <member name="P:System.Text.RegularExpressions.ValueMatchEnumerator.Current">
            <summary>
            Gets the <see cref="T:System.Text.RegularExpressions.ValueMatch"/> element at the current position of the enumerator.
            </summary>
            <exception cref="T:System.InvalidOperationException">Enumeration has either not started or has already finished.</exception>
        </member>
        <member name="T:System.Text.SpanLineEnumerator">
            <summary>
            Enumerates the lines of a <see cref="T:System.ReadOnlySpan`1"/>.
            </summary>
            <remarks>
            To get an instance of this type, use <see cref="!:MemoryExtensions.EnumerateLines(ReadOnlySpan&lt;char&gt;)"/>.
            </remarks>
        </member>
        <member name="P:System.Text.SpanLineEnumerator.Current">
            <summary>
            Gets the line at the current position of the enumerator.
            </summary>
        </member>
        <member name="M:System.Text.SpanLineEnumerator.GetEnumerator">
            <summary>
            Returns this instance as an enumerator.
            </summary>
        </member>
        <member name="M:System.Text.SpanLineEnumerator.MoveNext">
            <summary>
            Advances the enumerator to the next line of the span.
            </summary>
            <returns>
            True if the enumerator successfully advanced to the next line; false if
            the enumerator has advanced past the end of the span.
            </returns>
        </member>
        <member name="T:System.Text.AppendInterpolatedStringHandler">
            <summary>Provides a handler used by the language compiler to append interpolated strings into <see cref="T:System.Text.StringBuilder"/> instances.</summary>
        </member>
        <member name="F:System.Text.AppendInterpolatedStringHandler._stringBuilder">
            <summary>The associated StringBuilder to which to append.</summary>
        </member>
        <member name="F:System.Text.AppendInterpolatedStringHandler._provider">
            <summary>Optional provider to pass to IFormattable.ToString or ISpanFormattable.TryFormat calls.</summary>
        </member>
        <member name="F:System.Text.AppendInterpolatedStringHandler._hasCustomFormatter">
            <summary>Whether <see cref="F:System.Text.AppendInterpolatedStringHandler._provider"/> provides an ICustomFormatter.</summary>
            <remarks>
            Custom formatters are very rare.  We want to support them, but it's ok if we make them more expensive
            in order to make them as pay-for-play as possible.  So, we avoid adding another reference type field
            to reduce the size of the handler and to reduce required zero'ing, by only storing whether the provider
            provides a formatter, rather than actually storing the formatter.  This in turn means, if there is a
            formatter, we pay for the extra interface call on each AppendFormatted that needs it.
            </remarks>
        </member>
        <member name="M:System.Text.AppendInterpolatedStringHandler.#ctor(System.Int32,System.Int32,System.Text.StringBuilder)">
            <summary>Creates a handler used to append an interpolated string into a <see cref="T:System.Text.StringBuilder"/>.</summary>
            <param name="literalLength">The number of constant characters outside of interpolation expressions in the interpolated string.</param>
            <param name="formattedCount">The number of interpolation expressions in the interpolated string.</param>
            <param name="stringBuilder">The associated StringBuilder to which to append.</param>
            <remarks>This is intended to be called only by compiler-generated code. Arguments are not validated as they'd otherwise be for members intended to be used directly.</remarks>
        </member>
        <member name="M:System.Text.AppendInterpolatedStringHandler.#ctor(System.Int32,System.Int32,System.Text.StringBuilder,System.IFormatProvider)">
            <summary>Creates a handler used to translate an interpolated string into a <see cref="T:System.String"/>.</summary>
            <param name="literalLength">The number of constant characters outside of interpolation expressions in the interpolated string.</param>
            <param name="formattedCount">The number of interpolation expressions in the interpolated string.</param>
            <param name="stringBuilder">The associated StringBuilder to which to append.</param>
            <param name="provider">An object that supplies culture-specific formatting information.</param>
            <remarks>This is intended to be called only by compiler-generated code. Arguments are not validated as they'd otherwise be for members intended to be used directly.</remarks>
        </member>
        <member name="M:System.Text.AppendInterpolatedStringHandler.AppendLiteral(System.String)">
            <summary>Writes the specified string to the handler.</summary>
            <param name="value">The string to write.</param>
        </member>
        <member name="M:System.Text.AppendInterpolatedStringHandler.AppendFormatted``1(``0)">
            <summary>Writes the specified value to the handler.</summary>
            <param name="value">The value to write.</param>
            <typeparam name="T">The type of the value to write.</typeparam>
        </member>
        <member name="M:System.Text.AppendInterpolatedStringHandler.AppendFormatted``1(``0,System.String)">
            <summary>Writes the specified value to the handler.</summary>
            <param name="value">The value to write.</param>
            <param name="format">The format string.</param>
            <typeparam name="T">The type of the value to write.</typeparam>
        </member>
        <member name="M:System.Text.AppendInterpolatedStringHandler.AppendFormatted``1(``0,System.Int32)">
            <summary>Writes the specified value to the handler.</summary>
            <param name="value">The value to write.</param>
            <param name="alignment">
            Minimum number of characters that should be written for this value.  If the value is negative, it indicates
            left-aligned and the required minimum is the absolute value.
            </param>
            <typeparam name="T">The type of the value to write.</typeparam>
        </member>
        <member name="M:System.Text.AppendInterpolatedStringHandler.AppendFormatted``1(``0,System.Int32,System.String)">
            <summary>Writes the specified value to the handler.</summary>
            <param name="value">The value to write.</param>
            <param name="format">The format string.</param>
            <param name="alignment">
            Minimum number of characters that should be written for this value.  If the value is negative, it indicates
            left-aligned and the required minimum is the absolute value.
            </param>
            <typeparam name="T">The type of the value to write.</typeparam>
        </member>
        <member name="M:System.Text.AppendInterpolatedStringHandler.AppendFormattedWithTempSpace``1(``0,System.Int32,System.String)">
            <summary>Formats into temporary space and then appends the result into the StringBuilder.</summary>
        </member>
        <member name="M:System.Text.AppendInterpolatedStringHandler.AppendFormatted(System.ReadOnlySpan{System.Char})">
            <summary>Writes the specified character span to the handler.</summary>
            <param name="value">The span to write.</param>
        </member>
        <member name="M:System.Text.AppendInterpolatedStringHandler.AppendFormatted(System.ReadOnlySpan{System.Char},System.Int32,System.String)">
            <summary>Writes the specified string of chars to the handler.</summary>
            <param name="value">The span to write.</param>
            <param name="alignment">
            Minimum number of characters that should be written for this value.  If the value is negative, it indicates
            left-aligned and the required minimum is the absolute value.
            </param>
            <param name="format">The format string.</param>
        </member>
        <member name="M:System.Text.AppendInterpolatedStringHandler.AppendFormatted(System.String)">
            <summary>Writes the specified value to the handler.</summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:System.Text.AppendInterpolatedStringHandler.AppendFormatted(System.String,System.Int32,System.String)">
            <summary>Writes the specified value to the handler.</summary>
            <param name="value">The value to write.</param>
            <param name="alignment">
            Minimum number of characters that should be written for this value.  If the value is negative, it indicates
            left-aligned and the required minimum is the absolute value.
            </param>
            <param name="format">The format string.</param>
        </member>
        <member name="M:System.Text.AppendInterpolatedStringHandler.AppendFormatted(System.Object,System.Int32,System.String)">
            <summary>Writes the specified value to the handler.</summary>
            <param name="value">The value to write.</param>
            <param name="alignment">
            Minimum number of characters that should be written for this value.  If the value is negative, it indicates
            left-aligned and the required minimum is the absolute value.
            </param>
            <param name="format">The format string.</param>
        </member>
        <member name="M:System.Text.AppendInterpolatedStringHandler.AppendCustomFormatter``1(``0,System.String)">
            <summary>Formats the value using the custom formatter from the provider.</summary>
            <param name="value">The value to write.</param>
            <param name="format">The format string.</param>
            <typeparam name="T">The type of the value to write.</typeparam>
        </member>
        <member name="T:System.ISpanFormattable">
            <summary>Provides functionality to format the string representation of an object into a span.</summary>
        </member>
        <member name="M:System.ISpanFormattable.TryFormat(System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)">
            <summary>Tries to format the value of the current instance into the provided span of characters.</summary>
            <param name="destination">When this method returns, this instance's value formatted as a span of characters.</param>
            <param name="charsWritten">When this method returns, the number of characters that were written in <paramref name="destination"/>.</param>
            <param name="format">A span containing the characters that represent a standard or custom format string that defines the acceptable format for <paramref name="destination"/>.</param>
            <param name="provider">An optional object that supplies culture-specific formatting information for <paramref name="destination"/>.</param>
            <returns><see langword="true"/> if the formatting was successful; otherwise, <see langword="false"/>.</returns>
            <remarks>
            An implementation of this interface should produce the same string of characters as an implementation of <see cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)"/>
            on the same type.
            TryFormat should return false only if there is not enough space in the destination buffer. Any other failures should throw an exception.
            </remarks>
        </member>
        <member name="M:EnumPolyfill.GetValues``1">
            <summary>
            Retrieves an array of the values of the constants in a specified enumeration type.
            </summary>
            <returns>An array that contains the values of the constants in TEnum.</returns>
        </member>
        <member name="M:EnumPolyfill.GetNames``1">
            <summary>
            Retrieves an array of the names of the constants in a specified enumeration type.
            </summary>
            <returns>A string array of the names of the constants in TEnum.</returns>
        </member>
        <member name="M:GuidPolyfill.TryParse(System.String,System.IFormatProvider,System.Guid@)">
            <summary>
            Tries to parse a string into a value.
            </summary>
        </member>
        <member name="M:GuidPolyfill.TryParse(System.ReadOnlySpan{System.Byte},System.IFormatProvider,System.Byte@)">
            <summary>
            Tries to parse a span of UTF-8 characters into a value.
            </summary>
        </member>
        <member name="M:BytePolyfill.TryParse(System.String,System.IFormatProvider,System.Byte@)">
            <summary>
            Tries to parse a string into a value.
            </summary>
        </member>
        <member name="M:BytePolyfill.TryParse(System.ReadOnlySpan{System.Byte},System.IFormatProvider,System.Byte@)">
            <summary>
            Tries to parse a span of UTF-8 characters into a value.
            </summary>
        </member>
        <member name="M:BytePolyfill.TryParse(System.ReadOnlySpan{System.Char},System.Byte@)">
            <summary>
            Converts the span representation of a number in a specified style and culture-specific format to its byte equivalent. A return value indicates whether the conversion succeeded.
            </summary>
        </member>
        <member name="M:BytePolyfill.TryParse(System.ReadOnlySpan{System.Char},System.IFormatProvider,System.Byte@)">
            <summary>
            Tries to parse a span of characters into a value.
            </summary>
        </member>
        <member name="M:BytePolyfill.TryParse(System.ReadOnlySpan{System.Byte},System.Globalization.NumberStyles,System.IFormatProvider,System.Byte@)">
            <summary>
            Tries to parse a span of UTF-8 characters into a value.
            </summary>
        </member>
        <member name="M:BytePolyfill.TryParse(System.ReadOnlySpan{System.Byte},System.Byte@)">
            <summary>
            Tries to convert a UTF-8 character span containing the string representation of a number to its byte equivalent.
            </summary>
        </member>
        <member name="M:BytePolyfill.TryParse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider,System.Byte@)">
            <summary>
            Converts the span representation of a number in a specified style and culture-specific format to its byte equivalent. A return value indicates whether the conversion succeeded.
            </summary>
        </member>
        <member name="M:DoublePolyfill.TryParse(System.String,System.IFormatProvider,System.Double@)">
            <summary>
            Tries to parse a string into a value.
            </summary>
        </member>
        <member name="M:DoublePolyfill.TryParse(System.ReadOnlySpan{System.Byte},System.IFormatProvider,System.Double@)">
            <summary>
            Tries to parse a span of UTF-8 characters into a value.
            </summary>
        </member>
        <member name="M:DoublePolyfill.TryParse(System.ReadOnlySpan{System.Char},System.Double@)">
            <summary>
            Converts the span representation of a number in a specified style and culture-specific format to its double-precision floating-point number equivalent. A return value indicates whether the conversion succeeded or failed.
            </summary>
        </member>
        <member name="M:DoublePolyfill.TryParse(System.ReadOnlySpan{System.Char},System.IFormatProvider,System.Double@)">
            <summary>
            Tries to parse a span of characters into a value.
            </summary>
        </member>
        <member name="M:DoublePolyfill.TryParse(System.ReadOnlySpan{System.Byte},System.Globalization.NumberStyles,System.IFormatProvider,System.Double@)">
            <summary>
            Tries to parse a span of UTF-8 characters into a value.
            </summary>
        </member>
        <member name="M:DoublePolyfill.TryParse(System.ReadOnlySpan{System.Byte},System.Double@)">
            <summary>
            Tries to convert a UTF-8 character span containing the string representation of a number to its double-precision floating-point number equivalent..
            </summary>
        </member>
        <member name="M:DoublePolyfill.TryParse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider,System.Double@)">
            <summary>
            Converts the string representation of a number in a specified style and culture-specific format to its double-precision floating-point number equivalent. A return value indicates whether the conversion succeeded or failed.
            </summary>
        </member>
        <member name="M:IntPolyfill.TryParse(System.String,System.IFormatProvider,System.Int32@)">
            <summary>
            Tries to parse a string into a value.
            </summary>
        </member>
        <member name="M:IntPolyfill.TryParse(System.ReadOnlySpan{System.Byte},System.IFormatProvider,System.Int32@)">
            <summary>
            Tries to parse a span of UTF-8 characters into a value.
            </summary>
        </member>
        <member name="M:IntPolyfill.TryParse(System.ReadOnlySpan{System.Char},System.Int32@)">
            <summary>
            Converts the span representation of a number in a specified style and culture-specific format to its 32-bit signed integer equivalent. A return value indicates whether the conversion succeeded.
            </summary>
        </member>
        <member name="M:IntPolyfill.TryParse(System.ReadOnlySpan{System.Char},System.IFormatProvider,System.Int32@)">
            <summary>
            Tries to parse a span of characters into a value.
            </summary>
        </member>
        <member name="M:IntPolyfill.TryParse(System.ReadOnlySpan{System.Byte},System.Globalization.NumberStyles,System.IFormatProvider,System.Int32@)">
            <summary>
            Tries to parse a span of UTF-8 characters into a value.
            </summary>
        </member>
        <member name="M:IntPolyfill.TryParse(System.ReadOnlySpan{System.Byte},System.Int32@)">
            <summary>
            Tries to convert a UTF-8 character span containing the string representation of a number to its 32-bit signed integer equivalent.
            </summary>
        </member>
        <member name="M:IntPolyfill.TryParse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider,System.Int32@)">
            <summary>
            Converts the span representation of a number in a specified style and culture-specific format to its 32-bit signed integer equivalent. A return value indicates whether the conversion succeeded.
            </summary>
        </member>
        <member name="M:LongPolyfill.TryParse(System.String,System.IFormatProvider,System.Int32@)">
            <summary>
            Tries to parse a string into a value.
            </summary>
        </member>
        <member name="M:LongPolyfill.TryParse(System.ReadOnlySpan{System.Byte},System.IFormatProvider,System.Int32@)">
            <summary>
            Tries to parse a span of UTF-8 characters into a value.
            </summary>
        </member>
        <member name="M:LongPolyfill.TryParse(System.ReadOnlySpan{System.Char},System.Int32@)">
            <summary>
            Converts the span representation of a number in a specified style and culture-specific format to its 32-bit signed integer equivalent. A return value indicates whether the conversion succeeded.
            </summary>
        </member>
        <member name="M:LongPolyfill.TryParse(System.ReadOnlySpan{System.Char},System.IFormatProvider,System.Int32@)">
            <summary>
            Tries to parse a span of characters into a value.
            </summary>
        </member>
        <member name="M:LongPolyfill.TryParse(System.ReadOnlySpan{System.Byte},System.Globalization.NumberStyles,System.IFormatProvider,System.Int32@)">
            <summary>
            Tries to parse a span of UTF-8 characters into a value.
            </summary>
        </member>
        <member name="M:LongPolyfill.TryParse(System.ReadOnlySpan{System.Byte},System.Int32@)">
            <summary>
            Tries to convert a UTF-8 character span containing the string representation of a number to its 64-bit signed integer equivalent.
            </summary>
        </member>
        <member name="M:LongPolyfill.TryParse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider,System.Int32@)">
            <summary>
            Converts the span representation of a number in a specified style and culture-specific format to its 64-bit signed integer equivalent. A return value indicates whether the conversion succeeded.
            </summary>
        </member>
        <member name="M:SBytePolyfill.TryParse(System.String,System.IFormatProvider,System.SByte@)">
            <summary>
            Tries to parse a string into a value.
            </summary>
        </member>
        <member name="M:SBytePolyfill.TryParse(System.ReadOnlySpan{System.Byte},System.IFormatProvider,System.SByte@)">
            <summary>
            Tries to parse a span of UTF-8 characters into a value.
            </summary>
        </member>
        <member name="M:SBytePolyfill.TryParse(System.ReadOnlySpan{System.Char},System.SByte@)">
            <summary>
            Converts the span representation of a number in a specified style and culture-specific format to its sbyte equivalent. A return value indicates whether the conversion succeeded.
            </summary>
        </member>
        <member name="M:SBytePolyfill.TryParse(System.ReadOnlySpan{System.Char},System.IFormatProvider,System.SByte@)">
            <summary>
            Tries to parse a span of characters into a value.
            </summary>
        </member>
        <member name="M:SBytePolyfill.TryParse(System.ReadOnlySpan{System.Byte},System.Globalization.NumberStyles,System.IFormatProvider,System.SByte@)">
            <summary>
            Tries to parse a span of UTF-8 characters into a value.
            </summary>
        </member>
        <member name="M:SBytePolyfill.TryParse(System.ReadOnlySpan{System.Byte},System.SByte@)">
            <summary>
            Tries to convert a UTF-8 character span containing the string representation of a number to its sbyte equivalent.
            </summary>
        </member>
        <member name="M:SBytePolyfill.TryParse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider,System.SByte@)">
            <summary>
            Converts the span representation of a number in a specified style and culture-specific format to its sbyte equivalent. A return value indicates whether the conversion succeeded.
            </summary>
        </member>
        <member name="M:ShortPolyfill.TryParse(System.String,System.IFormatProvider,System.Int16@)">
            <summary>
            Tries to parse a string into a value.
            </summary>
        </member>
        <member name="M:ShortPolyfill.TryParse(System.ReadOnlySpan{System.Byte},System.IFormatProvider,System.Int16@)">
            <summary>
            Tries to parse a span of UTF-8 characters into a value.
            </summary>
        </member>
        <member name="M:ShortPolyfill.TryParse(System.ReadOnlySpan{System.Char},System.Int16@)">
            <summary>
            Converts the span representation of a number in a specified style and culture-specific format to its short equivalent. A return value indicates whether the conversion succeeded.
            </summary>
        </member>
        <member name="M:ShortPolyfill.TryParse(System.ReadOnlySpan{System.Char},System.IFormatProvider,System.Int16@)">
            <summary>
            Tries to parse a span of characters into a value.
            </summary>
        </member>
        <member name="M:ShortPolyfill.TryParse(System.ReadOnlySpan{System.Byte},System.Globalization.NumberStyles,System.IFormatProvider,System.Int16@)">
            <summary>
            Tries to parse a span of UTF-8 characters into a value.
            </summary>
        </member>
        <member name="M:ShortPolyfill.TryParse(System.ReadOnlySpan{System.Byte},System.Int16@)">
            <summary>
            Tries to convert a UTF-8 character span containing the string representation of a number to its short equivalent.
            </summary>
        </member>
        <member name="M:ShortPolyfill.TryParse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider,System.Int16@)">
            <summary>
            Converts the span representation of a number in a specified style and culture-specific format to its short equivalent. A return value indicates whether the conversion succeeded.
            </summary>
        </member>
        <member name="M:UIntPolyfill.TryParse(System.String,System.IFormatProvider,System.UInt32@)">
            <summary>
            Tries to parse a string into a value.
            </summary>
        </member>
        <member name="M:UIntPolyfill.TryParse(System.ReadOnlySpan{System.Byte},System.IFormatProvider,System.UInt32@)">
            <summary>
            Tries to parse a span of UTF-8 characters into a value.
            </summary>
        </member>
        <member name="M:UIntPolyfill.TryParse(System.ReadOnlySpan{System.Char},System.UInt32@)">
            <summary>
            Converts the span representation of a number in a specified style and culture-specific format to its uint equivalent. A return value indicates whether the conversion succeeded.
            </summary>
        </member>
        <member name="M:UIntPolyfill.TryParse(System.ReadOnlySpan{System.Char},System.IFormatProvider,System.UInt32@)">
            <summary>
            Tries to parse a span of characters into a value.
            </summary>
        </member>
        <member name="M:UIntPolyfill.TryParse(System.ReadOnlySpan{System.Byte},System.Globalization.NumberStyles,System.IFormatProvider,System.UInt32@)">
            <summary>
            Tries to parse a span of UTF-8 characters into a value.
            </summary>
        </member>
        <member name="M:UIntPolyfill.TryParse(System.ReadOnlySpan{System.Byte},System.UInt32@)">
            <summary>
            Tries to convert a UTF-8 character span containing the string representation of a number to its uint equivalent.
            </summary>
        </member>
        <member name="M:UIntPolyfill.TryParse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider,System.UInt32@)">
            <summary>
            Converts the span representation of a number in a specified style and culture-specific format to its uint equivalent. A return value indicates whether the conversion succeeded.
            </summary>
        </member>
        <member name="M:ULongPolyfill.TryParse(System.String,System.IFormatProvider,System.UInt64@)">
            <summary>
            Tries to parse a string into a value.
            </summary>
        </member>
        <member name="M:ULongPolyfill.TryParse(System.ReadOnlySpan{System.Byte},System.IFormatProvider,System.UInt64@)">
            <summary>
            Tries to parse a span of UTF-8 characters into a value.
            </summary>
        </member>
        <member name="M:ULongPolyfill.TryParse(System.ReadOnlySpan{System.Char},System.UInt64@)">
            <summary>
            Converts the span representation of a number in a specified style and culture-specific format to its ulong equivalent. A return value indicates whether the conversion succeeded.
            </summary>
        </member>
        <member name="M:ULongPolyfill.TryParse(System.ReadOnlySpan{System.Char},System.IFormatProvider,System.UInt64@)">
            <summary>
            Tries to parse a span of characters into a value.
            </summary>
        </member>
        <member name="M:ULongPolyfill.TryParse(System.ReadOnlySpan{System.Byte},System.Globalization.NumberStyles,System.IFormatProvider,System.UInt64@)">
            <summary>
            Tries to parse a span of UTF-8 characters into a value.
            </summary>
        </member>
        <member name="M:ULongPolyfill.TryParse(System.ReadOnlySpan{System.Byte},System.UInt64@)">
            <summary>
            Tries to convert a UTF-8 character span containing the string representation of a number to its ulong equivalent.
            </summary>
        </member>
        <member name="M:ULongPolyfill.TryParse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider,System.UInt64@)">
            <summary>
            Converts the span representation of a number in a specified style and culture-specific format to its ulong equivalent. A return value indicates whether the conversion succeeded.
            </summary>
        </member>
        <member name="M:UShortPolyfill.TryParse(System.String,System.IFormatProvider,System.UInt16@)">
            <summary>
            Tries to parse a string into a value.
            </summary>
        </member>
        <member name="M:UShortPolyfill.TryParse(System.ReadOnlySpan{System.Byte},System.IFormatProvider,System.UInt16@)">
            <summary>
            Tries to parse a span of UTF-8 characters into a value.
            </summary>
        </member>
        <member name="M:UShortPolyfill.TryParse(System.ReadOnlySpan{System.Char},System.UInt16@)">
            <summary>
            Converts the span representation of a number in a specified style and culture-specific format to its ushort equivalent. A return value indicates whether the conversion succeeded.
            </summary>
        </member>
        <member name="M:UShortPolyfill.TryParse(System.ReadOnlySpan{System.Char},System.IFormatProvider,System.UInt16@)">
            <summary>
            Tries to parse a span of characters into a value.
            </summary>
        </member>
        <member name="M:UShortPolyfill.TryParse(System.ReadOnlySpan{System.Byte},System.Globalization.NumberStyles,System.IFormatProvider,System.UInt16@)">
            <summary>
            Tries to parse a span of UTF-8 characters into a value.
            </summary>
        </member>
        <member name="M:UShortPolyfill.TryParse(System.ReadOnlySpan{System.Byte},System.UInt16@)">
            <summary>
            Tries to convert a UTF-8 character span containing the string representation of a number to its ushort equivalent.
            </summary>
        </member>
        <member name="M:UShortPolyfill.TryParse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider,System.UInt16@)">
            <summary>
            Converts the span representation of a number in a specified style and culture-specific format to its ushort equivalent. A return value indicates whether the conversion succeeded.
            </summary>
        </member>
        <member name="M:Polyfill.UnsafeRegister(System.Threading.CancellationToken,System.Action{System.Object},System.Object)">
            <summary>
            Registers a delegate that will be called when this
            <see cref="T:System.Threading.CancellationToken">CancellationToken</see> is canceled.
            </summary>
            <remarks>
            <para>
            If this token is already in the canceled state, the delegate will be run immediately and synchronously.
            Any exception the delegate generates will be propagated out of this method call.
            </para>
            <para>
            <see cref="T:System.Threading.ExecutionContext">ExecutionContext</see> is not captured nor flowed
            to the callback's invocation.
            </para>
            </remarks>
            <param name="callback">The delegate to be executed when the <see cref="T:System.Threading.CancellationToken">CancellationToken</see> is canceled.</param>
            <param name="state">The state to pass to the <paramref name="callback"/> when the delegate is invoked.  This may be null.</param>
            <returns>The <see cref="T:System.Threading.CancellationTokenRegistration"/> instance that can
            be used to unregister the callback.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="callback"/> is null.</exception>
        </member>
        <member name="M:Polyfill.Register(System.Threading.CancellationToken,System.Action{System.Object,System.Threading.CancellationToken},System.Object)">
            <summary>Registers a delegate that will be called when this <see cref="T:System.Threading.CancellationToken">CancellationToken</see> is canceled.</summary>
            <remarks>
            If this token is already in the canceled state, the delegate will be run immediately and synchronously. Any exception the delegate
            generates will be propagated out of this method call. The current <see cref="T:System.Threading.ExecutionContext">ExecutionContext</see>, if one exists,
            will be captured along with the delegate and will be used when executing it. The current <see cref="T:System.Threading.SynchronizationContext"/> is not captured.
            </remarks>
            <param name="callback">The delegate to be executed when the <see cref="T:System.Threading.CancellationToken">CancellationToken</see> is canceled.</param>
            <param name="state">The state to pass to the <paramref name="callback"/> when the delegate is invoked.  This may be null.</param>
            <returns>The <see cref="T:System.Threading.CancellationTokenRegistration"/> instance that can be used to unregister the callback.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="callback"/> is null.</exception>
        </member>
        <member name="M:Polyfill.UnsafeRegister(System.Threading.CancellationToken,System.Action{System.Object,System.Threading.CancellationToken},System.Object)">
            <summary>Registers a delegate that will be called when this <see cref="T:System.Threading.CancellationToken">CancellationToken</see> is canceled.</summary>
            <remarks>
            If this token is already in the canceled state, the delegate will be run immediately and synchronously. Any exception the delegate
            generates will be propagated out of this method call. <see cref="T:System.Threading.ExecutionContext"/> is not captured nor flowed to the callback's invocation.
            </remarks>
            <param name="callback">The delegate to be executed when the <see cref="T:System.Threading.CancellationToken">CancellationToken</see> is canceled.</param>
            <param name="state">The state to pass to the <paramref name="callback"/> when the delegate is invoked.  This may be null.</param>
            <returns>The <see cref="T:System.Threading.CancellationTokenRegistration"/> instance that can be used to unregister the callback.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="callback"/> is null.</exception>
        </member>
        <member name="M:Polyfill.CancelAsync(System.Threading.CancellationTokenSource)">
            <summary>Communicates a request for cancellation asynchronously.</summary>
            <remarks>
            <para>
            The associated <see cref="T:System.Threading.CancellationToken" /> will be notified of the cancellation
            and will synchronously transition to a state where <see cref="P:System.Threading.CancellationToken.IsCancellationRequested"/> returns true.
            Any callbacks or cancelable operations registered with the <see cref="T:System.Threading.CancellationToken"/>  will be executed asynchronously,
            with the returned <see cref="T:System.Threading.Tasks.Task"/> representing their eventual completion.
            </para>
            <para>
            Callbacks registered with the token should not throw exceptions.
            However, any such exceptions that are thrown will be aggregated into an <see cref="T:System.AggregateException"/>,
            such that one callback throwing an exception will not prevent other registered callbacks from being executed.
            </para>
            <para>
            The <see cref="T:System.Threading.ExecutionContext"/> that was captured when each callback was registered
            will be reestablished when the callback is invoked.
            </para>
            </remarks>
            <exception cref="T:System.ObjectDisposedException">This <see cref="T:System.Threading.CancellationTokenSource"/> has been disposed.</exception>
        </member>
        <member name="M:Polyfill.GetOrAdd``3(System.Collections.Concurrent.ConcurrentDictionary{``0,``1},``0,System.Func{``0,``2,``1},``2)">
            <summary>
            Adds a key/value pair to the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>
            if the key does not already exist.
            </summary>
            <param name="key">The key of the element to add.</param>
            <param name="valueFactory">The function used to generate a value for the key</param>
            <param name="factoryArgument">An argument value to pass into <paramref name="valueFactory"/>.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is a null reference
            (Nothing in Visual Basic).</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="valueFactory"/> is a null reference
            (Nothing in Visual Basic).</exception>
            <exception cref="T:System.OverflowException">The dictionary contains too many
            elements.</exception>
            <returns>The value for the key.  This will be either the existing value for the key if the
            key is already in the dictionary, or the new value for the key as returned by valueFactory
            if the key was not in the dictionary.</returns>
        </member>
        <member name="M:Polyfill.AsReadOnly``2(System.Collections.Generic.IDictionary{``0,``1})">
            <summary>
            Returns a read-only <see cref="T:System.Collections.ObjectModel.ReadOnlyDictionary`2"/> wrapper for the current dictionary.
            </summary>
            <typeparam name="TKey">The type of keys in the dictionary.</typeparam>
            <typeparam name="TValue">The type of values in the dictionary.</typeparam>
            <param name="dictionary">The dictionary to wrap.</param>
            <returns>An object that acts as a read-only wrapper around the current <see cref="T:System.Collections.Generic.IDictionary`2"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="dictionary"/> is null.</exception>
        </member>
        <member name="M:Polyfill.Remove``2(System.Collections.Generic.Dictionary{``0,``1},``0,``1@)">
            <summary>
            Removes the value with the specified key from the <see cref="T:System.Collections.Generic.Dictionary`2"/>, and copies the element
            to the value parameter.
            </summary>
            <param name="target">A dictionary with keys of type TKey and values of type TValue.</param>
            <param name="key">The key of the element to remove.</param>
            <param name="value">The removed element.</param>
            <typeparam name="TKey">The type of the keys in the dictionary.</typeparam>
            <typeparam name="TValue">The type of the values in the dictionary.</typeparam>
            <returns><code>true</code> if the element is successfully found and removed; otherwise, <code>false</code>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is <code>null</code>.</exception>
        </member>
        <member name="M:Polyfill.TryGetValue``1(System.Collections.Generic.HashSet{``0},``0,``0@)">
            <summary>
             Searches the set for a given value and returns the equal value it finds, if any.
            </summary>
            <param name="equalValue">The value to search for.</param>
            <param name="actualValue">The value from the set that the search found, or the default value of T when the search yielded no match.</param>
            <returns>A value indicating whether the search was successful.</returns>
        </member>
        <member name="M:Polyfill.GetStreamAsync(System.Net.Http.HttpClient,System.String,System.Threading.CancellationToken)">
            <summary>
            Send a GET request to the specified Uri and return the response body as a stream in an asynchronous operation.
            </summary>
            <remarks>
            This operation will not block. The returned <see cref="T:System.Threading.Tasks.Task`1"/> object will complete after the response headers are read.
            This method does not read nor buffer the response body.
            </remarks>
            <param name="requestUri">The Uri the request is sent to.</param>
            <param name="cancellationToken">The cancellation token to cancel the operation.</param>
            <returns>The task object representing the asynchronous operation.</returns>
        </member>
        <member name="M:Polyfill.GetStreamAsync(System.Net.Http.HttpClient,System.Uri,System.Threading.CancellationToken)">
            <summary>
            Send a GET request to the specified Uri and return the response body as a stream in an asynchronous operation.
            </summary>
            <remarks>
            This operation will not block. The returned <see cref="T:System.Threading.Tasks.Task`1"/> object will complete after the response headers are read.
            This method does not read nor buffer the response body.
            </remarks>
            <param name="requestUri">The Uri the request is sent to.</param>
            <param name="cancellationToken">The cancellation token to cancel the operation.</param>
            <returns>The task object representing the asynchronous operation.</returns>
        </member>
        <member name="M:Polyfill.GetByteArrayAsync(System.Net.Http.HttpClient,System.String,System.Threading.CancellationToken)">
            <summary>
            Send a GET request to the specified Uri and return the response body as a byte array in an asynchronous operation.
            </summary>
            <remarks>
            This operation will not block. The returned Task{Byte[]} object will complete after the response headers are read.
            This method does not read nor buffer the response body.
            </remarks>
            <param name="requestUri">The Uri the request is sent to.</param>
            <param name="cancellationToken">The cancellation token to cancel the operation.</param>
            <returns>The task object representing the asynchronous operation.</returns>
        </member>
        <member name="M:Polyfill.GetByteArrayAsync(System.Net.Http.HttpClient,System.Uri,System.Threading.CancellationToken)">
            <summary>
            Send a GET request to the specified Uri and return the response body as a byte array in an asynchronous operation.
            </summary>
            <remarks>
            This operation will not block. The returned Task{byte[]} object will complete after the response headers are read.
            This method does not read nor buffer the response body.
            </remarks>
            <param name="requestUri">The Uri the request is sent to.</param>
            <param name="cancellationToken">The cancellation token to cancel the operation.</param>
            <returns>The task object representing the asynchronous operation.</returns>
        </member>
        <member name="M:Polyfill.GetStringAsync(System.Net.Http.HttpClient,System.String,System.Threading.CancellationToken)">
            <summary>
            Send a GET request to the specified Uri and return the response body as a string in an asynchronous operation.
            </summary>
            <remarks>
            This operation will not block. The returned <see cref="T:System.Threading.Tasks.Task`1"/> object will complete after the response headers are read.
            This method does not read nor buffer the response body.
            </remarks>
            <param name="requestUri">The Uri the request is sent to.</param>
            <param name="cancellationToken">The cancellation token to cancel the operation.</param>
            <returns>The task object representing the asynchronous operation.</returns>
        </member>
        <member name="M:Polyfill.GetStringAsync(System.Net.Http.HttpClient,System.Uri,System.Threading.CancellationToken)">
            <summary>
            Send a GET request to the specified Uri and return the response body as a string in an asynchronous operation.
            </summary>
            <remarks>
            This operation will not block. The returned <see cref="T:System.Threading.Tasks.Task`1"/> object will complete after the response headers are read.
            This method does not read nor buffer the response body.
            </remarks>
            <param name="requestUri">The Uri the request is sent to.</param>
            <param name="cancellationToken">The cancellation token to cancel the operation.</param>
            <returns>The task object representing the asynchronous operation.</returns>
        </member>
        <member name="M:Polyfill.ReadAsStreamAsync(System.Net.Http.HttpContent,System.Threading.CancellationToken)">
            <summary>
            Serializes the HTTP content and returns a stream that represents the content.
            </summary>
            <remarks>
            Note that this method will internally buffer the content unless <c>CreateContentReadStreamAsync()</c> has been
            implemented to do otherwise.
            </remarks>
            <param name="cancellationToken">
            The token to monitor for cancellation requests. The default value is <see cref="P:System.Threading.CancellationToken.None"/>.
            </param>
            <returns>The task object representing the asynchronous operation.</returns>
        </member>
        <member name="M:Polyfill.ReadAsByteArrayAsync(System.Net.Http.HttpContent,System.Threading.CancellationToken)">
            <summary>
            Serializes the HTTP content to a byte array as an asynchronous operation.
            </summary>
            <remarks>
            Note that this method will internally buffer the content unless <c>CreateContentReadStreamAsync()</c> has been
            implemented to do otherwise.
            </remarks>
            <param name="cancellationToken">
            The token to monitor for cancellation requests. The default value is <see cref="P:System.Threading.CancellationToken.None"/>.
            </param>
            <returns>The task object representing the asynchronous operation.</returns>
        </member>
        <member name="M:Polyfill.ReadAsStringAsync(System.Net.Http.HttpContent,System.Threading.CancellationToken)">
            <summary>
            Serializes the HTTP content to a string as an asynchronous operation.
            </summary>
            <remarks>
            Note that this method will internally buffer the content unless <c>CreateContentReadStreamAsync()</c> has been
            implemented to do otherwise.
            </remarks>
            <param name="cancellationToken">
            The token to monitor for cancellation requests. The default value is <see cref="P:System.Threading.CancellationToken.None"/>.
            </param>
            <returns>The task object representing the asynchronous operation.</returns>
        </member>
        <member name="M:Polyfill.Index``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            https://learn.microsoft.com/en-us/dotnet/core/whats-new/dotnet-9/overview#linq
            </summary>
        </member>
        <member name="M:Polyfill.TryGetNonEnumeratedCount``1(System.Collections.Generic.IEnumerable{``0},System.Int32@)">
             <summary>
               Attempts to determine the number of elements in a sequence without forcing an enumeration.
             </summary>
             <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
             <param name="source">A sequence that contains elements to be counted.</param>
             <param name="count">
                 When this method returns, contains the count of <paramref name="source" /> if successful,
                 or zero if the method failed to determine the count.</param>
             <returns>
               <see langword="true" /> if the count of <paramref name="source"/> can be determined without enumeration;
               otherwise, <see langword="false" />.
             </returns>
             <remarks>
               The method performs a series of type tests, identifying common subtypes whose
               count can be determined without enumerating; this includes <see cref="T:System.Collections.Generic.ICollection`1"/>,
               <see cref="T:System.Collections.ICollection"/> as well as internal types used in the LINQ implementation.
            
               The method is typically a constant-time operation, but ultimately this depends on the complexity
               characteristics of the underlying collection implementation.
             </remarks>
        </member>
        <member name="M:Polyfill.SkipLast``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            Returns a new enumerable collection that contains the elements from source with the last count elements of the
            source collection omitted.
            </summary>
            <param name="source">An enumerable collection instance.</param>
            <param name="count">The number of elements to omit from the end of the collection.</param>
            <typeparam name="TSource">The type of the elements in the enumerable collection.</typeparam>
            <returns>A new enumerable collection that contains the elements from source minus count elements from the end
            of the collection.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Polyfill.ToHashSet``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})" -->
        <member name="M:Polyfill.AggregateBy``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},``2,System.Func{``2,``0,``2},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            https://learn.microsoft.com/en-us/dotnet/core/whats-new/dotnet-9/overview#linq
            </summary>
        </member>
        <member name="M:Polyfill.AggregateBy``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``1,``2},System.Func{``2,``0,``2},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            https://learn.microsoft.com/en-us/dotnet/core/whats-new/dotnet-9/overview#linq
            </summary>
        </member>
        <member name="M:Polyfill.Chunk``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            Split the elements of a sequence into chunks of size at most <paramref name="size"/>.
            </summary>
            <remarks>
            Every chunk except the last will be of size <paramref name="size"/>.
            The last chunk will contain the remaining elements and may be of a smaller size.
            </remarks>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> whose elements to chunk.</param>
            <param name="size">Maximum size of each chunk.</param>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <returns>
            An <see cref="T:System.Collections.Generic.IEnumerable`1"/> that contains the elements the input sequence split into chunks of size <paramref name="size"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="size"/> is below 1.</exception>
        </member>
        <member name="M:Polyfill.CountBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            https://learn.microsoft.com/en-us/dotnet/core/whats-new/dotnet-9/overview#linq
            </summary>
        </member>
        <member name="M:Polyfill.DistinctBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>Returns distinct elements from a sequence according to a specified key selector function.</summary>
            <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
            <typeparam name="TKey">The type of key to distinguish elements by.</typeparam>
            <param name="source">The sequence to remove duplicate elements from.</param>
            <param name="keySelector">A function to extract the key for each element.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains distinct elements from the source sequence.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source" /> is <see langword="null" />.</exception>
            <remarks>
            <para>This method is implemented by using deferred execution. The immediate return value is an object that stores all the information that is required to perform the action. The query represented by this method is not executed until the object is enumerated either by calling its `GetEnumerator` method directly or by using `foreach` in Visual C# or `For Each` in Visual Basic.</para>
            <para>The <see cref="M:Polyfill.DistinctBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" /> method returns an unordered sequence that contains no duplicate values. The default equality comparer, <see cref="P:System.Collections.Generic.EqualityComparer`1.Default" />, is used to compare values.</para>
            </remarks>
        </member>
        <member name="M:Polyfill.DistinctBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>Returns distinct elements from a sequence according to a specified key selector function.</summary>
            <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
            <typeparam name="TKey">The type of key to distinguish elements by.</typeparam>
            <param name="source">The sequence to remove duplicate elements from.</param>
            <param name="keySelector">A function to extract the key for each element.</param>
            <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> to compare keys.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains distinct elements from the source sequence.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source" /> is <see langword="null" />.</exception>
            <remarks>
            <para>This method is implemented by using deferred execution. The immediate return value is an object that stores all the information that is required to perform the action. The query represented by this method is not executed until the object is enumerated either by calling its `GetEnumerator` method directly or by using `foreach` in Visual C# or `For Each` in Visual Basic.</para>
            <para>The <see cref="M:Polyfill.DistinctBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})" /> method returns an unordered sequence that contains no duplicate values. If <paramref name="comparer" /> is <see langword="null" />, the default equality comparer, <see cref="P:System.Collections.Generic.EqualityComparer`1.Default" />, is used to compare values.</para>
            </remarks>
        </member>
        <member name="M:Polyfill.Except``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>
            Produces a set items excluding <paramref name="item"/> by using the default equality comparer to compare values.
            </summary>
            <param name="target">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> whose elements that are not equal to <paramref name="item"/> will be returned.</param>
            <param name="item">An <see cref="!:TSource"/> that is elements equal it will cause those elements to be removed from the returned sequence.</param>
            <typeparam name="TSource">The type of the elements of <paramref name="target" />.</typeparam>
            <returns>A sequence that contains the items of <paramref name="target"/> but excluding <paramref name="item"/>.</returns>
        </member>
        <member name="M:Polyfill.Except``1(System.Collections.Generic.IEnumerable{``0},``0[])">
            <summary>
            Produces the set difference of two sequences by using the default equality comparer to compare values.
            </summary>
            <param name="target">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> whose elements that are not equal to <paramref name="item"/> will be returned.</param>
            <param name="item">An <see cref="!:TSource"/> that is elements equal it will cause those elements to be removed from the returned sequence.</param>
            <typeparam name="TSource">The type of the elements of <paramref name="target" />.</typeparam>
            <returns>A sequence that contains the items of <paramref name="target"/> but excluding <paramref name="item"/>.</returns>
        </member>
        <member name="M:Polyfill.Except``1(System.Collections.Generic.IEnumerable{``0},``0,System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Produces a set items excluding <paramref name="item"/> by using <paramref name="comparer"/> to compare values.
            </summary>
            <param name="target">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> whose elements that are not equal to <paramref name="item"/> will be returned.</param>
            <param name="item">An <see cref="!:TSource"/> that is elements equal it will cause those elements to be removed from the returned sequence.</param>
            <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> to compare values.</param>
            <typeparam name="TSource">The type of the elements of <paramref name="target" />.</typeparam>
            <returns>A sequence that contains the items of <paramref name="target"/> but excluding <paramref name="item"/>.</returns>
        </member>
        <member name="M:Polyfill.Except``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0},``0[])">
            <summary>
            Produces the set difference of two sequences by <paramref name="comparer"/> to compare values.
            </summary>
            <param name="target">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> whose elements that are not equal to <paramref name="item"/> will be returned.</param>
            <param name="item">An <see cref="!:TSource"/> that is elements equal it will cause those elements to be removed from the returned sequence.</param>
            <typeparam name="TSource">The type of the elements of <paramref name="target" />.</typeparam>
            <returns>A sequence that contains the items of <paramref name="target"/> but excluding <paramref name="item"/>.</returns>
        </member>
        <member name="M:Polyfill.ExceptBy``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``1})">
            <summary>
            Produces the set difference of two sequences according to a specified key selector function.
            </summary>
            <typeparam name="TSource">The type of the elements of the input sequence.</typeparam>
            <typeparam name="TKey">The type of key to identify elements by.</typeparam>
            <param name="first">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> whose keys that are not also in <paramref name="second"/> will be returned.</param>
            <param name="second">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> whose keys that also occur in the first sequence will cause those elements to be removed from the returned sequence.</param>
            <param name="keySelector">A function to extract the key for each element.</param>
            <returns>A sequence that contains the set difference of the elements of two sequences.</returns>
        </member>
        <member name="M:Polyfill.ExceptBy``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Produces the set difference of two sequences according to a specified key selector function.
            </summary>
            <typeparam name="TSource">The type of the elements of the input sequence.</typeparam>
            <typeparam name="TKey">The type of key to identify elements by.</typeparam>
            <param name="first">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> whose keys that are not also in <paramref name="second"/> will be returned.</param>
            <param name="second">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> whose keys that also occur in the first sequence will cause those elements to be removed from the returned sequence.</param>
            <param name="keySelector">A function to extract the key for each element.</param>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> to compare values.</param>
            <returns>A sequence that contains the set difference of the elements of two sequences.</returns>
        </member>
        <member name="M:Polyfill.FirstOrDefault``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean},``0)">
            <summary>Returns the first element of the sequence that satisfies a condition or a default value if no such element is found.</summary>
            <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> to return an element from.</param>
            <param name="predicate">A function to test each element for a condition.</param>
            <param name="defaultValue">The default value to return if the sequence is empty.</param>
            <returns><paramref name="defaultValue" /> if <paramref name="source" /> is empty or if no element passes the test specified by <paramref name="predicate" />; otherwise, the first element in <paramref name="source" /> that passes the test specified by <paramref name="predicate" />.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source" /> or <paramref name="predicate" /> is <see langword="null" />.</exception>
        </member>
        <member name="M:Polyfill.FirstOrDefault``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>Returns the first element of a sequence, or a default value if the sequence contains no elements.</summary>
            <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
            <param name="source">The <see cref="T:System.Collections.Generic.IEnumerable`1" /> to return the first element of.</param>
            <param name="defaultValue">The default value to return if the sequence is empty.</param>
            <returns><paramref name="defaultValue" /> if <paramref name="source" /> is empty; otherwise, the first element in <paramref name="source" />.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source" /> is <see langword="null" />.</exception>
        </member>
        <member name="M:Polyfill.LastOrDefault``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>Returns the last element of a sequence, or a default value if the sequence contains no elements.</summary>
            <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> to return the last element of.</param>
            <param name="defaultValue">The default value to return if the sequence is empty.</param>
            <returns><paramref name="defaultValue" /> if the source sequence is empty; otherwise, the last element in the <see cref="T:System.Collections.Generic.IEnumerable`1" />.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source" /> is <see langword="null" />.</exception>
        </member>
        <member name="M:Polyfill.LastOrDefault``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean},``0)">
            <summary>Returns the last element of a sequence that satisfies a condition or a default value if no such element is found.</summary>
            <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> to return an element from.</param>
            <param name="predicate">A function to test each element for a condition.</param>
            <param name="defaultValue">The default value to return if the sequence is empty.</param>
            <returns><paramref name="defaultValue" /> if the sequence is empty or if no elements pass the test in the predicate function; otherwise, the last element that passes the test in the predicate function.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source" /> or <paramref name="predicate" /> is <see langword="null" />.</exception>
        </member>
        <member name="M:Polyfill.MaxBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>
            Returns the maximum value in a generic sequence according to a specified key selector function.
            </summary>
            <typeparam name="TSource">The type of the elements of <paramref name="target" />.</typeparam>
            <typeparam name="TKey">The type of key to compare elements by.</typeparam>
            <param name="source">A sequence of values to determine the maximum value of.</param>
            <param name="keySelector">A function to extract the key for each element.</param>
            <returns>The value with the maximum key in the sequence.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source" /> is <see langword="null" />.</exception>
            <exception cref="T:System.ArgumentException">No key extracted from <paramref name="source" /> implements the <see cref="T:System.IComparable" /> or <see cref="T:System.IComparable`1" /> interface.</exception>
            <remarks>
            <para>If <typeparamref name="TKey" /> is a reference type and the source sequence is empty or contains only values that are <see langword="null" />, this method returns <see langword="null" />.</para>
            </remarks>
        </member>
        <member name="M:Polyfill.MaxBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})">
            <summary>Returns the maximum value in a generic sequence according to a specified key selector function.</summary>
            <typeparam name="TSource">The type of the elements of <paramref name="target" />.</typeparam>
            <typeparam name="TKey">The type of key to compare elements by.</typeparam>
            <param name="source">A sequence of values to determine the maximum value of.</param>
            <param name="keySelector">A function to extract the key for each element.</param>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IComparer`1" /> to compare keys.</param>
            <returns>The value with the maximum key in the sequence.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source" /> is <see langword="null" />.</exception>
            <exception cref="T:System.ArgumentException">No key extracted from <paramref name="source" /> implements the <see cref="T:System.IComparable" /> or <see cref="T:System.IComparable`1" /> interface.</exception>
            <remarks>
            <para>If <typeparamref name="TKey" /> is a reference type and the source sequence is empty or contains only values that are <see langword="null" />, this method returns <see langword="null" />.</para>
            </remarks>
        </member>
        <member name="M:Polyfill.MinBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>
            Returns the minimum value in a generic sequence according to a specified key selector function.
            </summary>
            <typeparam name="TSource">The type of the elements of <paramref name="target" />.</typeparam>
            <typeparam name="TKey">The type of key to compare elements by.</typeparam>
            <param name="source">A sequence of values to determine the minby value of.</param>
            <param name="keySelector">A function to extract the key for each element.</param>
            <returns>The value with the minimum key in the sequence.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source" /> is <see langword="null" />.</exception>
            <exception cref="T:System.ArgumentException">No key extracted from <paramref name="source" /> implements the <see cref="T:System.IComparable" /> or <see cref="T:System.IComparable`1" /> interface.</exception>
            <remarks>
            <para>If <typeparamref name="TKey" /> is a reference type and the source sequence is empty or contains only values that are <see langword="null" />, this method returns <see langword="null" />.</para>
            </remarks>
        </member>
        <member name="M:Polyfill.MinBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})">
            <summary>Returns the minimum value in a generic sequence according to a specified key selector function.</summary>
            <typeparam name="TSource">The type of the elements of <paramref name="target" />.</typeparam>
            <typeparam name="TKey">The type of key to compare elements by.</typeparam>
            <param name="source">A sequence of values to determine the minimum value of.</param>
            <param name="keySelector">A function to extract the key for each element.</param>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IComparer`1" /> to compare keys.</param>
            <returns>The value with the minimum key in the sequence.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source" /> is <see langword="null" />.</exception>
            <exception cref="T:System.ArgumentException">No key extracted from <paramref name="target" /> implements the <see cref="T:System.IComparable" /> or <see cref="T:System.IComparable`1" /> interface.</exception>
            <remarks>
            <para>If <typeparamref name="TKey" /> is a reference type and the source sequence is empty or contains only values that are <see langword="null" />, this method returns <see langword="null" />.</para>
            </remarks>
        </member>
        <member name="M:Polyfill.SingleOrDefault``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean},``0)">
            <summary>Returns the only element of a sequence that satisfies a specified condition or a default value if no such element exists; this method throws an exception if more than one element satisfies the condition.</summary>
            <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> to return a single element from.</param>
            <param name="predicate">A function to test an element for a condition.</param>
            <param name="defaultValue">The default value to return if the sequence is empty.</param>
            <returns>The single element of the input sequence that satisfies the condition, or <paramref name="defaultValue" /> if no such element is found.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source" /> or <paramref name="predicate" /> is <see langword="null" />.</exception>
            <exception cref="T:System.InvalidOperationException">More than one element satisfies the condition in <paramref name="predicate" />.</exception>
        </member>
        <member name="M:Polyfill.SingleOrDefault``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>Returns the only element of a sequence, or a default value if the sequence is empty; this method throws an exception if there is more than one element in the sequence.</summary>
            <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> to return the single element of.</param>
            <param name="defaultValue">The default value to return if the sequence is empty.</param>
            <returns>The single element of the input sequence, or <paramref name="defaultValue" /> if the sequence contains no elements.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source" /> is <see langword="null" />.</exception>
            <exception cref="T:System.InvalidOperationException">The input sequence contains more than one element.</exception>
        </member>
        <member name="M:Polyfill.Zip``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Collections.Generic.IEnumerable{``2})">
            <summary>
            Produces a sequence of tuples with elements from the three specified sequences.
            </summary>
            <typeparam name="TFirst">The type of the elements of the first input sequence.</typeparam>
            <typeparam name="TSecond">The type of the elements of the second input sequence.</typeparam>
            <typeparam name="TThird">The type of the elements of the third input sequence.</typeparam>
            <param name="first">The first sequence to merge.</param>
            <param name="second">The second sequence to merge.</param>
            <param name="third">The third sequence to merge.</param>
            <returns>A sequence of tuples with elements taken from the first, second, and third sequences, in that order.</returns>
        </member>
        <member name="M:Polyfill.Zip``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
            <summary>
            Produces a sequence of tuples with elements from the two specified sequences.
            </summary>
            <typeparam name="TFirst">The type of the elements of the first input sequence.</typeparam>
            <typeparam name="TSecond">The type of the elements of the second input sequence.</typeparam>
            <param name="first">The first sequence to merge.</param>
            <param name="second">The second sequence to merge.</param>
            <returns>A sequence of tuples with elements taken from the first, and second sequences, in that order.</returns>
        </member>
        <member name="M:Polyfill.GetValueOrDefault``2(System.Collections.Generic.IReadOnlyDictionary{``0,``1},``0)">
            <summary>
            Tries to get the value associated with the specified key in the dictionary.
            </summary>
            <param name="target">A dictionary with keys of type TKey and values of type TValue.</param>
            <param name="key">The key of the value to get.</param>
            <typeparam name="TKey">The type of the keys in the dictionary.</typeparam>
            <typeparam name="TValue">The type of the values in the dictionary.</typeparam>
            <returns>
            A TValue instance. When the method is successful, the returned object is the value associated with
            the specified key. When the method fails, it returns the default value for TValue.
            </returns>
        </member>
        <member name="M:Polyfill.GetValueOrDefault``2(System.Collections.Generic.IReadOnlyDictionary{``0,``1},``0,``1)">
            <summary>
            Tries to get the value associated with the specified key in the dictionary.
            </summary>
            <param name="target">A dictionary with keys of type TKey and values of type TValue.</param>
            <param name="key">The key of the value to get.</param>
            <param name="defaultValue">A dictionary with keys of type TKey and values of type TValue.</param>
            <typeparam name="TKey">The type of the keys in the dictionary.</typeparam>
            <typeparam name="TValue">The type of the values in the dictionary.</typeparam>
            <returns>
            A TValue instance. When the method is successful, the returned object is the value associated with
            the specified key. When the method fails, it returns the default value for TValue.
            </returns>
        </member>
        <member name="M:Polyfill.Deconstruct``2(System.Collections.Generic.KeyValuePair{``0,``1},``0@,``1@)">
            <summary>
            Deconstructs the current <see cref="T:System.Collections.Generic.KeyValuePair`2"/>
            </summary>
            <param name="key">The key of the current <see cref="T:System.Collections.Generic.KeyValuePair`2"/>.</param>
            <param name="value">The value of the current <see cref="T:System.Collections.Generic.KeyValuePair`2"/>.</param>
        </member>
        <member name="M:Polyfill.AsReadOnly``1(System.Collections.Generic.IList{``0})">
            <summary>Returns a read-only <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> wrapper for the current collection.</summary>
            <returns>An object that acts as a read-only wrapper around the current <see cref="T:System.Collections.Generic.IList`1" />.</returns>
        </member>
        <member name="M:Polyfill.AddRange``1(System.Collections.Generic.List{``0},System.ReadOnlySpan{``0})">
            <summary>Adds the elements of the specified span to the end of the <see cref="T:System.Collections.Generic.List`1"/>.</summary>
            <typeparam name="T">The type of elements in the list.</typeparam>
            <param name="list">The list to which the elements should be added.</param>
            <param name="source">The span whose elements should be added to the end of the <see cref="T:System.Collections.Generic.List`1"/>.</param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="list"/> is null.</exception>
        </member>
        <member name="M:Polyfill.InsertRange``1(System.Collections.Generic.List{``0},System.Int32,System.ReadOnlySpan{``0})">
            <summary>Inserts the elements of a span into the <see cref="T:System.Collections.Generic.List`1"/> at the specified index.</summary>
            <typeparam name="T">The type of elements in the list.</typeparam>
            <param name="list">The list into which the elements should be inserted.</param>
            <param name="index">The zero-based index at which the new elements should be inserted.</param>
            <param name="source">The span whose elements should be added to the <see cref="T:System.Collections.Generic.List`1"/>.</param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="list"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is less than 0 or greater than <paramref name="list"/>'s <see cref="P:System.Collections.Generic.List`1.Count"/>.</exception>
        </member>
        <member name="M:Polyfill.CopyTo``1(System.Collections.Generic.List{``0},System.Span{``0})">
            <summary>Copies the entire <see cref="T:System.Collections.Generic.List`1"/> to a span.</summary>
            <typeparam name="T">The type of elements in the list.</typeparam>
            <param name="list">The list from which the elements are copied.</param>
            <param name="destination">The span that is the destination of the elements copied from <paramref name="list"/>.</param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="list"/> is null.</exception>
            <exception cref="T:System.ArgumentException">The number of elements in the source <see cref="T:System.Collections.Generic.List`1"/> is greater than the number of elements that the destination span can contain.</exception>
        </member>
        <member name="M:Polyfill.EnumerateLines(System.ReadOnlySpan{System.Char})">
            <summary>
            Returns an enumeration of lines over the provided span.
            </summary>
            <remarks>
            It is recommended that protocol parsers not utilize this API. See the documentation
            for <see cref="!:string.ReplaceLineEndings"/> for more information on how newline
            sequences are detected.
            </remarks>
        </member>
        <member name="M:Polyfill.EnumerateLines(System.Span{System.Char})">
            <summary>
            Returns an enumeration of lines over the provided span.
            </summary>
            <remarks>
            It is recommended that protocol parsers not utilize this API. See the documentation
            for <see cref="!:string.ReplaceLineEndings"/> for more information on how newline
            sequences are detected.
            </remarks>
        </member>
        <member name="M:Polyfill.TrimStart(System.Span{System.Char})">
            <summary>
            Removes all leading white-space characters from the span.
            </summary>
            <param name="span">The source span from which the characters are removed.</param>
        </member>
        <member name="M:Polyfill.TrimEnd(System.Span{System.Char})">
            <summary>
            Removes all trailing white-space characters from the span.
            </summary>
            <param name="span">The source span from which the characters are removed.</param>
        </member>
        <member name="M:Polyfill.ClampStart(System.ReadOnlySpan{System.Char})">
            <summary>
            Delimits all leading occurrences of whitespace charecters from the span.
            </summary>
            <param name="span">The source span from which the characters are removed.</param>
        </member>
        <member name="M:Polyfill.ClampEnd(System.ReadOnlySpan{System.Char},System.Int32)">
            <summary>
            Delimits all trailing occurrences of whitespace charecters from the span.
            </summary>
            <param name="span">The source span from which the characters are removed.</param>
            <param name="start">The start index from which to being searching.</param>
        </member>
        <member name="M:Polyfill.Contains``1(System.ReadOnlySpan{``0},``0)">
            <summary>
            Indicates whether a specified value is found in a read-only span. Values are compared using IEquatable{T}.Equals(T).
            </summary>
            <param name="value">The value to search for.</param>
            <returns><c>true</c> if found, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Polyfill.Contains``1(System.Span{``0},``0)">
            <summary>
            Indicates whether a specified value is found in a only span. Values are compared using IEquatable{T}.Equals(T).
            </summary>
            <param name="value">The value to search for.</param>
            <returns><c>true</c> if found, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Polyfill.SequenceEqual(System.ReadOnlySpan{System.Char},System.String)">
            <summary>
            Determines whether two sequences are equal by comparing the elements using IEquatable{T}.Equals(T).
            </summary>
            <param name="target">The first sequence to compare.</param>
            <param name="other">The second sequence to compare.</param>
            <returns><c>true</c> if the two sequences are equal; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Polyfill.SequenceEqual(System.Span{System.Char},System.String)">
            <summary>
            Determines whether two sequences are equal by comparing the elements using IEquatable{T}.Equals(T).
            </summary>
            <param name="target">The first sequence to compare.</param>
            <param name="other">The second sequence to compare.</param>
            <returns><c>true</c> if the two sequences are equal; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Polyfill.StartsWith(System.ReadOnlySpan{System.Char},System.String,System.StringComparison)">
            <summary>
            Determines whether a read-only character span begins with a specified value when compared using a specified <see cref="T:System.StringComparison"/> value.
            </summary>
            <param name="target">The source span.</param>
            <param name="other">The sequence to compare to the beginning of the source span.</param>
            <param name="comparison">An enumeration value that determines how span and value are compared.</param>
            <returns><c>true</c> if value matches the beginning of span; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Polyfill.StartsWith(System.Span{System.Char},System.String)">
            <summary>
            Determines whether a specified sequence appears at the start of a span.
            </summary>
            <param name="target">The source span.</param>
            <param name="other">The sequence to compare to the beginning of the source span.</param>
            <returns><c>true</c> if value matches the beginning of span; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Polyfill.EndsWith(System.ReadOnlySpan{System.Char},System.String,System.StringComparison)">
            <summary>
            Determines whether the end of the span matches the specified value when compared using the specified <paramref name="comparison"/> option.
            </summary>
            <param name="target">The source span.</param>
            <param name="other">The sequence to compare to the end of the source span.</param>
            <param name="comparison">An enumeration value that determines how span and value are compared.</param>
            <returns><c>true</c> if value matches the end of span; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Polyfill.EndsWith(System.Span{System.Char},System.String)">
            <summary>
            Determines whether the specified sequence appears at the end of a span.
            </summary>
            <param name="target">The source span.</param>
            <param name="other">The sequence to compare to the end of the source span.</param>
            <returns><c>true</c> if value matches the end of span; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Polyfill.Nanoseconds(System.TimeSpan)">
            <summary>
            Gets the nanosecond component of the time represented by the current <see cref="T:System.TimeSpan"/> object.
            </summary>
        </member>
        <member name="M:Polyfill.Nanosecond(System.DateTime)">
            <summary>
            Gets the nanosecond component of the time represented by the current <see cref="T:System.DateTime"/> object.
            </summary>
        </member>
        <member name="M:Polyfill.Nanosecond(System.DateTimeOffset)">
            <summary>
            Gets the nanosecond component of the time represented by the current <see cref="T:System.DateTimeOffset"/> object.
            </summary>
        </member>
        <member name="M:Polyfill.Microseconds(System.TimeSpan)">
            <summary>
            Gets the microsecond component of the time represented by the current <see cref="T:System.TimeSpan"/> object.
            </summary>
        </member>
        <member name="M:Polyfill.Microsecond(System.DateTime)">
            <summary>
            Gets the microsecond component of the time represented by the current <see cref="T:System.DateTime"/> object.
            </summary>
        </member>
        <member name="M:Polyfill.Microsecond(System.DateTimeOffset)">
            <summary>
            Gets the microsecond component of the time represented by the current <see cref="T:System.DateTimeOffset"/> object.
            </summary>
        </member>
        <member name="M:Polyfill.AddMicroseconds(System.DateTime,System.Double)">
            <summary>
            Returns a new <see cref="T:System.DateTime"/> object that adds a specified number of microseconds to the value of this instance..
            </summary>
        </member>
        <member name="M:Polyfill.AddMicroseconds(System.DateTimeOffset,System.Double)">
            <summary>
            Returns a new <see cref="T:System.DateTimeOffset"/> object that adds a specified number of microseconds to the value of this instance..
            </summary>
        </member>
        <member name="M:Polyfill.WaitForExitAsync(System.Diagnostics.Process,System.Threading.CancellationToken)">
            <summary>
            Instructs the Process component to wait for the associated process to exit, or
            for the <paramref name="cancellationToken"/> to be canceled.
            </summary>
            <remarks>
            Calling this method will set <see cref="!:EnableRaisingEvents"/> to <see langword="true" />.
            </remarks>
            <returns>
            A task that will complete when the process has exited, cancellation has been requested,
            or an error occurs.
            </returns>
        </member>
        <member name="M:Polyfill.GetKeyAtIndex``2(System.Collections.Generic.SortedList{``0,``1},System.Int32)">
            <summary>
            Gets the key corresponding to the specified index.
            </summary>
            <param name="index">The zero-based index of the key within the entire <see cref="T:System.Collections.Generic.SortedList`2"/>.</param>
            <returns>The key corresponding to the specified index.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">The specified index is out of range.</exception>
        </member>
        <member name="M:Polyfill.GetValueAtIndex``2(System.Collections.Generic.SortedList{``0,``1},System.Int32)">
            <summary>
            Gets the value corresponding to the specified index.
            </summary>
            <param name="index">The zero-based index of the value within the entire <see cref="T:System.Collections.Generic.SortedList`2"/>.</param>
            <returns>The value corresponding to the specified index.</returns>
        </member>
        <member name="M:Polyfill.CopyTo(System.String,System.Span{System.Char})">
            <summary>
            Copies the contents of this string into the destination span.
            </summary>
            <param name="destination">The span into which to copy this string's contents</param>
        </member>
        <member name="M:Polyfill.TryCopyTo(System.String,System.Span{System.Char})">
            <summary>
            Copies the contents of this string into the destination span.
            </summary>
            <param name="destination">The span into which to copy this string's contents</param>
            <returns>true if the data was copied; false if the destination was too short to fit the contents of the string.</returns>
        </member>
        <member name="M:Polyfill.GetHashCode(System.String,System.StringComparison)">
            <summary>
            Returns the hash code for this string using the specified rules.
            </summary>
            <param name="comparisonType">One of the enumeration values that specifies the rules to use in the comparison.</param>
            <returns>A 32-bit signed integer hash code.</returns>
        </member>
        <member name="M:Polyfill.Contains(System.String,System.String,System.StringComparison)">
            <summary>
            Returns a value indicating whether a specified string occurs within this string, using the specified comparison rules.
            </summary>
            <param name="value">The string to seek.</param>
            <param name="comparisonType">One of the enumeration values that specifies the rules to use in the comparison.</param>
            <returns>true if the value parameter occurs within this string, or if value is the empty string (""); otherwise, false.</returns>
        </member>
        <member name="M:Polyfill.StartsWith(System.String,System.Char)">
            <summary>
            Determines whether this string instance starts with the specified character.
            </summary>
            <param name="value">The character to compare.</param>
            <remarks>This method performs an ordinal (case-sensitive and culture-insensitive) comparison.</remarks>
            <returns>true if value matches the beginning of this string; otherwise, false.</returns>
        </member>
        <member name="M:Polyfill.EndsWith(System.String,System.Char)">
            <summary>
            Returns a value indicating whether a specified character occurs within this string.
            </summary>
            <param name="value">The character to seek.</param>
            <remarks>This method performs an ordinal (case-sensitive and culture-insensitive) comparison.</remarks>
            <returns>true if the value parameter occurs within this string; otherwise, false.</returns>
        </member>
        <member name="M:Polyfill.Split(System.String,System.Char,System.StringSplitOptions)">
            <summary>
            Splits a string into a maximum number of substrings based on a specified delimiting character and, optionally,
            options. Splits a string into a maximum number of substrings based on the provided character separator,
            optionally omitting empty substrings from the result.
            </summary>
            <param name="separator">A character that delimits the substrings in this instance.</param>
            <param name="options">A bitwise combination of the enumeration values that specifies whether to trim substrings
            and include empty substrings.</param>
            <returns>An array that contains at most count substrings from this instance that are delimited by separator.</returns>
        </member>
        <member name="M:Polyfill.Split(System.String,System.Char,System.Int32,System.StringSplitOptions)">
            <summary>
            Splits a string into a maximum number of substrings based on a specified delimiting character and, optionally,
            options. Splits a string into a maximum number of substrings based on the provided character separator,
            optionally omitting empty substrings from the result.
            </summary>
            <param name="separator">A character that delimits the substrings in this instance.</param>
            <param name="count">The maximum number of elements expected in the array.</param>
            <param name="options">A bitwise combination of the enumeration values that specifies whether to trim substrings
            and include empty substrings.</param>
            <returns>An array that contains at most count substrings from this instance that are delimited by separator.</returns>
        </member>
        <member name="M:Polyfill.Contains(System.String,System.Char)">
            <summary>
            Returns a value indicating whether a specified character occurs within this string.
            </summary>
            <remarks>This method performs an ordinal (case-sensitive and culture-insensitive) comparison.</remarks>
            <param name="value">The character to seek.</param>
            <returns>true if the value parameter occurs within this string; otherwise, false.</returns>
        </member>
        <member name="M:Polyfill.CopyTo(System.Text.StringBuilder,System.Int32,System.Span{System.Char},System.Int32)">
            <summary>
            Copies the characters from a specified segment of this instance to a destination Char span.
            </summary>
            <param name="sourceIndex">The starting position in this instance where characters will be copied from. The index is zero-based.</param>
            <param name="destination">The writable span where characters will be copied.</param>
            <param name="count">The number of characters to be copied.</param>
        </member>
        <member name="M:Polyfill.Append(System.Text.StringBuilder,System.ReadOnlySpan{System.Char})">
            <summary>
            Appends the string representation of a specified read-only character span to this instance.
            </summary>
            <param name="value">The read-only character span to append.</param>
            <returns>A reference to this instance after the append operation is completed.</returns>
        </member>
        <member name="M:Polyfill.Equals(System.Text.StringBuilder,System.ReadOnlySpan{System.Char})">
            <summary>
            Returns a value indicating whether the characters in this instance are equal to the characters in a specified
            read-only character span.
            </summary>
            <param name="span">The character span to compare with the current instance.</param>
            <remarks>
            The Equals method performs an ordinal comparison to determine whether the characters in the current instance
            and span are equal.
            </remarks>
            <returns>true if the characters in this instance and span are the same; otherwise, false.</returns>
        </member>
        <member name="M:Polyfill.Append(System.Text.StringBuilder,System.Text.AppendInterpolatedStringHandler@)">
            <summary>Appends the specified interpolated string to this instance.</summary>
            <param name="handler">The interpolated string to append.</param>
            <returns>A reference to this instance after the append operation has completed.</returns>
        </member>
        <member name="M:Polyfill.Append(System.Text.StringBuilder,System.IFormatProvider,System.Text.AppendInterpolatedStringHandler@)">
            <summary>Appends the specified interpolated string to this instance.</summary>
            <param name="provider">An object that supplies culture-specific formatting information.</param>
            <param name="handler">The interpolated string to append.</param>
            <returns>A reference to this instance after the append operation has completed.</returns>
        </member>
        <member name="M:Polyfill.AppendLine(System.Text.StringBuilder,System.Text.AppendInterpolatedStringHandler@)">
            <summary>Appends the specified interpolated string followed by the default line terminator to the end of the current StringBuilder object.</summary>
            <param name="handler">The interpolated string to append.</param>
            <returns>A reference to this instance after the append operation has completed.</returns>
        </member>
        <member name="M:Polyfill.AppendLine(System.Text.StringBuilder,System.IFormatProvider,System.Text.AppendInterpolatedStringHandler@)">
            <summary>Appends the specified interpolated string followed by the default line terminator to the end of the current StringBuilder object.</summary>
            <param name="provider">An object that supplies culture-specific formatting information.</param>
            <param name="handler">The interpolated string to append.</param>
            <returns>A reference to this instance after the append operation has completed.</returns>
        </member>
        <member name="M:Polyfill.AppendJoin(System.Text.StringBuilder,System.String,System.String[])">
            <summary>Concatenates the strings of the provided array, using the specified separator between each string, then appends the result to the current instance of the string builder.</summary>
            <param name="separator">The string to use as a separator. separator is included in the joined strings only if values has more than one element.</param>
            <param name="values">An array that contains the strings to concatenate and append to the current instance of the string builder.</param>
            <returns>A reference to this instance after the append operation has completed.</returns>
        </member>
        <member name="M:Polyfill.AppendJoin(System.Text.StringBuilder,System.String,System.Object[])">
            <summary>Concatenates the string representations of the elements in the provided array of objects, using the specified separator between each member, then appends the result to the current instance of the string builder.</summary>
            <param name="separator">The string to use as a separator. separator is included in the joined strings only if values has more than one element.</param>
            <param name="values">An array that contains the strings to concatenate and append to the current instance of the string builder.</param>
            <returns>A reference to this instance after the append operation has completed.</returns>
        </member>
        <member name="M:Polyfill.AppendJoin(System.Text.StringBuilder,System.Char,System.String[])">
            <summary>Concatenates the strings of the provided array, using the specified char separator between each string, then appends the result to the current instance of the string builder.</summary>
            <param name="separator">The character to use as a separator. separator is included in the joined strings only if values has more than one element.</param>
            <param name="values">An array that contains the strings to concatenate and append to the current instance of the string builder.</param>
            <returns>A reference to this instance after the append operation has completed.</returns>
        </member>
        <member name="M:Polyfill.AppendJoin(System.Text.StringBuilder,System.Char,System.Object[])">
            <summary>Concatenates the string representations of the elements in the provided array of objects, using the specified char separator between each member, then appends the result to the current instance of the string builder.</summary>
            <param name="separator">The character to use as a separator. separator is included in the joined strings only if values has more than one element.</param>
            <param name="values">An array that contains the strings to concatenate and append to the current instance of the string builder.</param>
            <returns>A reference to this instance after the append operation has completed.</returns>
        </member>
        <member name="M:Polyfill.AppendJoin``1(System.Text.StringBuilder,System.Char,``0[])">
            <summary>Concatenates and appends the members of a collection, using the specified char separator between each member.</summary>
            <param name="separator">The character to use as a separator. separator is included in the joined strings only if values has more than one element.</param>
            <param name="values">A collection that contains the objects to concatenate and append to the current instance of the string builder.</param>
            <returns>A reference to this instance after the append operation has completed.</returns>
        </member>
        <member name="M:Polyfill.AppendJoin``1(System.Text.StringBuilder,System.String,``0[])">
            <summary>Concatenates and appends the members of a collection, using the specified char separator between each member.</summary>
            <param name="separator">The string to use as a separator. separator is included in the concatenated and appended strings only if values has more than one element.</param>
            <param name="values">A collection that contains the objects to concatenate and append to the current instance of the string builder.</param>
            <returns>A reference to this instance after the append operation has completed.</returns>
        </member>
        <member name="M:Polyfill.Replace(System.Text.StringBuilder,System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})">
            <summary>
            Replaces all instances of one string with another in part of this builder.
            </summary>
            <param name="oldValue">The string to replace.</param>
            <param name="newValue">The string to replace <paramref name="oldValue"/> with.</param>
            <param name="startIndex">The index to start in this builder.</param>
            <param name="count">The number of characters to read in this builder.</param>
            <remarks>
            If <paramref name="newValue"/> is <c>null</c>, instances of <paramref name="oldValue"/> are removed from this builder.
            </remarks>
        </member>
        <member name="M:Polyfill.Replace(System.Text.StringBuilder,System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.Int32,System.Int32)">
            <summary>
            Replaces all instances of one read-only character span with another in part of this builder.
            </summary>
            <param name="oldValue">The read-only character span to replace.</param>
            <param name="newValue">The read-only character span to replace <paramref name="oldValue"/> with.</param>
            <param name="startIndex">The index to start in this builder.</param>
            <param name="count">The number of characters to read in this builder.</param>
            <remarks>
            If <paramref name="newValue"/> is empty, instances of <paramref name="oldValue"/> are removed from this builder.
            </remarks>
        </member>
        <member name="M:Polyfill.GetChunks(System.Text.StringBuilder)">
             <summary>
             GetChunks returns ChunkEnumerator that follows the IEnumerable pattern and
             thus can be used in a C# 'foreach' statements to retrieve the data in the StringBuilder
             as chunks (ReadOnlyMemory) of characters.  An example use is:
            
                  foreach (ReadOnlyMemory&lt;char&gt; chunk in sb.GetChunks())
                     foreach (char c in chunk.Span)
                         { /* operation on c }
            
             It is undefined what happens if the StringBuilder is modified while the chunk
             enumeration is incomplete.  StringBuilder is also not thread-safe, so operating
             on it with concurrent threads is illegal.  Finally the ReadOnlyMemory chunks returned
             are NOT guaranteed to remain unchanged if the StringBuilder is modified, so do
             not cache them for later use either.  This API's purpose is efficiently extracting
             the data of a CONSTANT StringBuilder.
            
             Creating a ReadOnlySpan from a ReadOnlyMemory  (the .Span property) is expensive
             compared to the fetching of the character, so create a local variable for the SPAN
             if you need to use it in a nested for statement.  For example
            
                foreach (ReadOnlyMemory&lt;char&gt; chunk in sb.GetChunks())
                {
                     var span = chunk.Span;
                     for (int i = 0; i &lt; span.Length; i++)
                         { /* operation on span[i] */ }
                }
             </summary>
        </member>
        <member name="T:Polyfill.ChunkEnumerator">
            <summary>
            ChunkEnumerator supports both the IEnumerable and IEnumerator pattern so foreach
            works (see GetChunks).  It needs to be public (so the compiler can use it
            when building a foreach statement) but users typically don't use it explicitly.
            (which is why it is a nested type).
            </summary>
        </member>
        <member name="M:Polyfill.ChunkEnumerator.GetEnumerator">
            <summary>
            Implement IEnumerable.GetEnumerator() to return  'this' as the IEnumerator
            </summary>
        </member>
        <member name="M:Polyfill.ChunkEnumerator.MoveNext">
            <summary>
            Implements the IEnumerator pattern.
            </summary>
        </member>
        <member name="P:Polyfill.ChunkEnumerator.Current">
            <summary>
            Implements the IEnumerator pattern.
            </summary>
        </member>
        <member name="T:Polyfill.ChunkEnumerator.ManyChunkInfo">
            <summary>
            Used to hold all the chunks indexes when you have many chunks.
            </summary>
        </member>
        <member name="M:Polyfill.WaitAsync(System.Threading.Tasks.Task,System.Threading.CancellationToken)">
            <summary>Gets a <see cref="T:System.Threading.Tasks.Task"/> that will complete when this <see cref="T:System.Threading.Tasks.Task"/> completes or when the specified <see cref="T:System.Threading.CancellationToken"/> has cancellation requested.</summary>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken"/> to monitor for a cancellation request.</param>
            <returns>The <see cref="T:System.Threading.Tasks.Task"/> representing the asynchronous wait.  It may or may not be the same instance as the current instance.</returns>
        </member>
        <member name="M:Polyfill.WaitAsync(System.Threading.Tasks.Task,System.TimeSpan)">
            <summary>Gets a <see cref="T:System.Threading.Tasks.Task"/> that will complete when this <see cref="T:System.Threading.Tasks.Task"/> completes or when the specified timeout expires.</summary>
            <param name="timeout">The timeout after which the <see cref="T:System.Threading.Tasks.Task"/> should be faulted with a <see cref="T:System.TimeoutException"/> if it hasn't otherwise completed.</param>
            <returns>The <see cref="T:System.Threading.Tasks.Task"/> representing the asynchronous wait.  It may or may not be the same instance as the current instance.</returns>
        </member>
        <member name="M:Polyfill.WaitAsync(System.Threading.Tasks.Task,System.TimeSpan,System.Threading.CancellationToken)">
            <summary>Gets a <see cref="T:System.Threading.Tasks.Task"/> that will complete when this <see cref="T:System.Threading.Tasks.Task"/> completes, when the specified timeout expires, or when the specified <see cref="T:System.Threading.CancellationToken"/> has cancellation requested.</summary>
            <param name="timeout">The timeout after which the <see cref="T:System.Threading.Tasks.Task"/> should be faulted with a <see cref="T:System.TimeoutException"/> if it hasn't otherwise completed.</param>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken"/> to monitor for a cancellation request.</param>
            <returns>The <see cref="T:System.Threading.Tasks.Task"/> representing the asynchronous wait.  It may or may not be the same instance as the current instance.</returns>
        </member>
        <member name="M:Polyfill.WaitAsync``1(System.Threading.Tasks.Task{``0},System.Threading.CancellationToken)">
            <summary>
            Gets a <see cref="T:System.Threading.Tasks.Task"/> that will complete when this <see cref="T:System.Threading.Tasks.Task"/> completes, or when the specified <see cref="T:System.Threading.CancellationToken"/> has cancellation requested.
            </summary>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken"/> to monitor for a cancellation request.</param>
            <returns>The <see cref="T:System.Threading.Tasks.Task"/> representing the asynchronous wait.  It may or may not be the same instance as the current instance.</returns>
        </member>
        <member name="M:Polyfill.WaitAsync``1(System.Threading.Tasks.Task{``0},System.TimeSpan)">
            <summary>
            Gets a <see cref="T:System.Threading.Tasks.Task"/> that will complete when this <see cref="T:System.Threading.Tasks.Task"/> completes, or when the specified timeout expires.
            </summary>
            <param name="timeout">The timeout after which the <see cref="T:System.Threading.Tasks.Task"/> should be faulted with a <see cref="T:System.TimeoutException"/> if it hasn't otherwise completed.</param>
            <returns>The <see cref="T:System.Threading.Tasks.Task"/> representing the asynchronous wait.  It may or may not be the same instance as the current instance.</returns>
        </member>
        <member name="M:Polyfill.WaitAsync``1(System.Threading.Tasks.Task{``0},System.TimeSpan,System.Threading.CancellationToken)">
            <summary>
            Gets a <see cref="T:System.Threading.Tasks.Task"/> that will complete when this <see cref="T:System.Threading.Tasks.Task"/> completes, when the specified timeout expires, or when the specified <see cref="T:System.Threading.CancellationToken"/> has cancellation requested.
            </summary>
            <param name="timeout">The timeout after which the <see cref="T:System.Threading.Tasks.Task"/> should be faulted with a <see cref="T:System.TimeoutException"/> if it hasn't otherwise completed.</param>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken"/> to monitor for a cancellation request.</param>
            <returns>The <see cref="T:System.Threading.Tasks.Task"/> representing the asynchronous wait.  It may or may not be the same instance as the current instance.</returns>
        </member>
        <member name="M:Polyfill.ReadToEndAsync(System.IO.TextReader,System.Threading.CancellationToken)">
            <summary>
            Reads all characters from the current position to the end of the stream asynchronously and returns them as one string.
            </summary>
            <param name="cancellationToken">The token to monitor for cancellation requests.</param>
            <returns>A task that represents the asynchronous read operation. The value of the <c>TResult</c> parameter contains
            a string with the characters from the current position to the end of the stream.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">The number of characters is larger than <see cref="F:System.Int32.MaxValue"/>.</exception>
            <exception cref="T:System.ObjectDisposedException">The stream reader has been disposed.</exception>
            <exception cref="T:System.InvalidOperationException">The reader is currently in use by a previous read operation.</exception>
        </member>
        <member name="M:Polyfill.ReadLineAsync(System.IO.TextReader,System.Threading.CancellationToken)">
            <summary>
            Reads a line of characters asynchronously and returns the data as a string.
            </summary>
            <param name="cancellationToken">The token to monitor for cancellation requests.</param>
            <returns>A value task that represents the asynchronous read operation. The value of the <c>TResult</c>
            parameter contains the next line from the text reader, or is <see langword="null" /> if all of the characters have been read.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">The number of characters in the next line is larger than <see cref="F:System.Int32.MaxValue"/>.</exception>
            <exception cref="T:System.ObjectDisposedException">The text reader has been disposed.</exception>
            <exception cref="T:System.InvalidOperationException">The reader is currently in use by a previous read operation.</exception>
        </member>
        <member name="M:Polyfill.Write(System.IO.TextWriter,System.ReadOnlySpan{System.Char})">
            <summary>
            Writes a character span to the text stream.
            </summary>
            <param name="buffer">The character span to write.</param>
        </member>
        <member name="M:Polyfill.WriteLine(System.IO.TextWriter,System.ReadOnlySpan{System.Char})">
            <summary>
            Writes the text representation of a character span to the text stream, followed by a line terminator.
            </summary>
            <param name="buffer">The char span value to write to the text stream.</param>
        </member>
        <member name="M:Polyfill.TryFormat(System.TimeSpan,System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)">
            <summary>
            Tries to format the value of the current instance as UTF-8 into the provided span of bytes.
            </summary>
        </member>
        <member name="M:Polyfill.TryFormat(System.Guid,System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char})">
            <summary>
            Tries to format the value of the current instance as UTF-8 into the provided span of bytes.
            </summary>
        </member>
        <member name="M:Polyfill.TryFormat(System.SByte,System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)">
            <summary>
            Tries to format the value of the current instance into the provided span of characters.
            </summary>
        </member>
        <member name="M:Polyfill.TryFormat(System.Byte,System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)">
            <summary>
            Tries to format the value of the current instance into the provided span of characters.
            </summary>
        </member>
        <member name="M:Polyfill.TryFormat(System.Int16,System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)">
            <summary>
            Tries to format the value of the current instance into the provided span of characters.
            </summary>
        </member>
        <member name="M:Polyfill.TryFormat(System.UInt16,System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)">
            <summary>
            Tries to format the value of the current instance into the provided span of characters.
            </summary>
        </member>
        <member name="M:Polyfill.TryFormat(System.Int32,System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)">
            <summary>
            Tries to format the value of the current instance into the provided span of characters.
            </summary>
        </member>
        <member name="M:Polyfill.TryFormat(System.UInt32,System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)">
            <summary>
            Tries to format the value of the current instance into the provided span of characters.
            </summary>
        </member>
        <member name="M:Polyfill.TryFormat(System.Int64,System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)">
            <summary>
            Tries to format the value of the current instance into the provided span of characters.
            </summary>
        </member>
        <member name="M:Polyfill.TryFormat(System.UInt64,System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)">
            <summary>
            Tries to format the value of the current instance into the provided span of characters.
            </summary>
        </member>
        <member name="M:Polyfill.TryFormat(System.Single,System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)">
            <summary>
            Tries to format the value of the current instance into the provided span of characters.
            </summary>
        </member>
        <member name="M:Polyfill.TryFormat(System.Double,System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)">
            <summary>
            Tries to format the value of the current instance into the provided span of characters.
            </summary>
        </member>
        <member name="M:Polyfill.TryFormat(System.Decimal,System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)">
            <summary>
            Tries to format the value of the current instance into the provided span of characters.
            </summary>
        </member>
        <member name="M:Polyfill.TryFormat(System.Boolean,System.Span{System.Char},System.Int32@)">
            <summary>
            Tries to format the value of the current instance into the provided span of characters.
            </summary>
        </member>
        <member name="M:Polyfill.TryFormat(System.DateTimeOffset,System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)">
            <summary>
            Tries to format the value of the current instance into the provided span of characters.
            </summary>
        </member>
        <member name="M:Polyfill.TryFormat(System.DateTime,System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)">
            <summary>
            Tries to format the value of the current instance into the provided span of characters.
            </summary>
        </member>
        <member name="M:Polyfill.IsGenericMethodParameter(System.Type)">
            <summary>
            Gets a value that indicates whether the current Type represents a type parameter in the definition of a generic method.
            </summary>
        </member>
        <member name="M:Polyfill.IsAssignableTo``1(System.Type)">
            <summary>
            Generic version of Type.IsAssignableTo https://learn.microsoft.com/en-us/dotnet/api/system.type.isassignableto.
            </summary>
        </member>
        <member name="M:Polyfill.IsAssignableFrom``1(System.Type)">
            <summary>
            Generic version of Type.IsAssignableFrom https://learn.microsoft.com/en-us/dotnet/api/system.type.isassignablefrom.
            </summary>
        </member>
        <member name="M:Polyfill.IsAssignableTo(System.Type,System.Type)">
            <summary>
            Determines whether the current type can be assigned to a variable of the specified targetType.
            </summary>
        </member>
        <member name="M:Polyfill.GetMemberWithSameMetadataDefinitionAs(System.Type,System.Reflection.MemberInfo)">
            <summary>
            Searches for the MemberInfo on the current Type that matches the specified MemberInfo.
            </summary>
            <param name="type">The MemberInfo to find on the current Type.</param>
            <param name="member">The MemberInfo to find on the current Type.</param>
            <returns>An object representing the member on the current Type that matches the specified member.</returns>
        </member>
        <member name="M:Polyfill.IsMatch(System.Text.RegularExpressions.Regex,System.ReadOnlySpan{System.Char},System.Int32)">
            <summary>
            Indicates whether the regular expression specified in the Regex constructor finds a match in a specified input span.
            </summary>
            <returns>true if the regular expression finds a match; otherwise, false.</returns>
        </member>
        <member name="M:Polyfill.IsMatch(System.Text.RegularExpressions.Regex,System.ReadOnlySpan{System.Char})">
            <summary>
            Indicates whether the regular expression specified in the Regex constructor finds a match in a specified input span.
            </summary>
            <returns>true if the regular expression finds a match; otherwise, false.</returns>
        </member>
        <member name="M:Polyfill.EnumerateMatches(System.Text.RegularExpressions.Regex,System.ReadOnlySpan{System.Char})">
            <summary>
            Searches an input span for all occurrences of a regular expression and returns a Regex.ValueMatchEnumerator to iterate over the matches.
            </summary>
            <returns>A Regex.ValueMatchEnumerator to iterate over the matches.</returns>
        </member>
        <member name="M:Polyfill.EnumerateMatches(System.Text.RegularExpressions.Regex,System.ReadOnlySpan{System.Char},System.Int32)">
            <summary>
            Searches an input span for all occurrences of a regular expression and returns a Regex.ValueMatchEnumerator to iterate over the matches.
            </summary>
            <returns>A Regex.ValueMatchEnumerator to iterate over the matches.</returns>
        </member>
        <member name="M:RegexPolyfill.IsMatch(System.ReadOnlySpan{System.Char},System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
            <summary>
            Indicates whether the specified regular expression finds a match in the specified input span, using the specified matching options and time-out interval.
            </summary>
            <returns>true if the regular expression finds a match; otherwise, false.</returns>
        </member>
        <member name="M:RegexPolyfill.IsMatch(System.ReadOnlySpan{System.Char},System.String,System.Text.RegularExpressions.RegexOptions)">
            <summary>
            Indicates whether the specified regular expression finds a match in the specified input span, using the specified matching options.
            </summary>
            <returns>true if the regular expression finds a match; otherwise, false.</returns>
        </member>
        <member name="M:RegexPolyfill.IsMatch(System.ReadOnlySpan{System.Char},System.String)">
            <summary>
            Indicates whether the specified regular expression finds a match in the specified input span.
            </summary>
            <returns>true if the regular expression finds a match; otherwise, false.</returns>
        </member>
        <member name="M:RegexPolyfill.EnumerateMatches(System.ReadOnlySpan{System.Char},System.String)">
            <summary>
            Searches an input span for all occurrences of a regular expression and returns a Regex.ValueMatchEnumerator to iterate over the matches.
            </summary>
            <returns>A Regex.ValueMatchEnumerator to iterate over the matches.</returns>
        </member>
        <member name="M:RegexPolyfill.EnumerateMatches(System.ReadOnlySpan{System.Char},System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
            <summary>
            Searches an input span for all occurrences of a regular expression and returns a Regex.ValueMatchEnumerator to iterate over the matches.
            </summary>
            <returns>A Regex.ValueMatchEnumerator to iterate over the matches.</returns>
        </member>
        <member name="M:RegexPolyfill.EnumerateMatches(System.ReadOnlySpan{System.Char},System.String,System.Text.RegularExpressions.RegexOptions)">
            <summary>
            Searches an input span for all occurrences of a regular expression and returns a Regex.ValueMatchEnumerator to iterate over the matches.
            </summary>
            <returns>A Regex.ValueMatchEnumerator to iterate over the matches.</returns>
        </member>
        <member name="M:StringPolyfill.Join(System.Char,System.String[])">
            <summary>
            Concatenates an array of strings, using the specified separator between each member.
            </summary>
        </member>
        <member name="M:StringPolyfill.Join(System.Char,System.Object[])">
            <summary>
            Concatenates the string representations of an array of objects, using the specified separator between each member.
            </summary>
        </member>
        <member name="M:StringPolyfill.Join(System.Char,System.String[],System.Int32,System.Int32)">
            <summary>
            Concatenates the specified elements of a string array, using the specified separator between each element.
            </summary>
        </member>
        <member name="M:StringPolyfill.Join``1(System.Char,System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Concatenates the specified elements of a string array, using the specified separator between each element.
            </summary>
        </member>
        <member name="T:Humanizer.EnglishArticle">
            <summary>
            Contains methods for removing, appending and prepending article prefixes for sorting strings ignoring the article.
            </summary>
        </member>
        <member name="M:Humanizer.EnglishArticle.AppendArticlePrefix(System.String[])">
            <summary>
            Removes the prefixed article and appends it to the same string.
            </summary>
            <param name="items">The input array of strings</param>
            <returns>Sorted string array</returns>
        </member>
        <member name="M:Humanizer.EnglishArticle.PrependArticleSuffix(System.String[])">
            <summary>
            Removes the previously appended article and prepends it to the same string.
            </summary>
            <param name="appended">Sorted string array</param>
            <returns>String array</returns>
        </member>
        <member name="T:Humanizer.ByteRate">
            <summary>
            Class to hold a ByteSize and a measurement interval, for the purpose of calculating the rate of transfer
            </summary>
        </member>
        <member name="P:Humanizer.ByteRate.Size">
            <summary>
            Quantity of bytes
            </summary>
        </member>
        <member name="P:Humanizer.ByteRate.Interval">
            <summary>
            Interval that bytes were transferred in
            </summary>
        </member>
        <member name="M:Humanizer.ByteRate.#ctor(Humanizer.ByteSize,System.TimeSpan)">
            <summary>
            Create a ByteRate with given quantity of bytes across an interval
            </summary>
        </member>
        <member name="M:Humanizer.ByteRate.Humanize(Humanizer.TimeUnit)">
            <summary>
            Calculate rate for the quantity of bytes and interval defined by this instance
            </summary>
            <param name="timeUnit">Unit of time to calculate rate for (defaults is per second)</param>
        </member>
        <member name="M:Humanizer.ByteRate.Humanize(System.String,Humanizer.TimeUnit,System.Globalization.CultureInfo)">
            <summary>
            Calculate rate for the quantity of bytes and interval defined by this instance
            </summary>
            <param name="timeUnit">Unit of time to calculate rate for (defaults is per second)</param>
            <param name="format">The string format to use for the number of bytes</param>
            <param name="culture">Culture to use. If null, current thread's UI culture is used.</param>
        </member>
        <member name="M:Humanizer.ByteSize.ToString">
            <summary>
            Converts the value of the current ByteSize object to a string.
            The metric prefix symbol (bit, byte, kilo, mega, giga, tera) used is
            the largest metric prefix such that the corresponding value is greater
             than or equal to one.
            </summary>
        </member>
        <member name="M:Humanizer.ByteSize.ToFullWords(System.String,System.IFormatProvider)">
            <summary>
            Converts the value of the current ByteSize object to a string with
            full words. The metric prefix symbol (bit, byte, kilo, mega, giga,
            tera) used is the largest metric prefix such that the corresponding
            value is greater than or equal to one.
            </summary>
        </member>
        <member name="T:Humanizer.ByteSizeExtensions">
            <summary>
            Provides extension methods for ByteSize
            </summary>
        </member>
        <member name="M:Humanizer.ByteSizeExtensions.Bits(System.Byte)">
            <summary>
            Considers input as bits
            </summary>
        </member>
        <member name="M:Humanizer.ByteSizeExtensions.Bits(System.SByte)">
            <summary>
            Considers input as bits
            </summary>
        </member>
        <member name="M:Humanizer.ByteSizeExtensions.Bits(System.Int16)">
            <summary>
            Considers input as bits
            </summary>
        </member>
        <member name="M:Humanizer.ByteSizeExtensions.Bits(System.UInt16)">
            <summary>
            Considers input as bits
            </summary>
        </member>
        <member name="M:Humanizer.ByteSizeExtensions.Bits(System.Int32)">
            <summary>
            Considers input as bits
            </summary>
        </member>
        <member name="M:Humanizer.ByteSizeExtensions.Bits(System.UInt32)">
            <summary>
            Considers input as bits
            </summary>
        </member>
        <member name="M:Humanizer.ByteSizeExtensions.Bits(System.Int64)">
            <summary>
            Considers input as bits
            </summary>
        </member>
        <member name="M:Humanizer.ByteSizeExtensions.Bytes(System.Byte)">
            <summary>
            Considers input as bytes
            </summary>
        </member>
        <member name="M:Humanizer.ByteSizeExtensions.Bytes(System.SByte)">
            <summary>
            Considers input as bytes
            </summary>
        </member>
        <member name="M:Humanizer.ByteSizeExtensions.Bytes(System.Int16)">
            <summary>
            Considers input as bytes
            </summary>
        </member>
        <member name="M:Humanizer.ByteSizeExtensions.Bytes(System.UInt16)">
            <summary>
            Considers input as bytes
            </summary>
        </member>
        <member name="M:Humanizer.ByteSizeExtensions.Bytes(System.Int32)">
            <summary>
            Considers input as bytes
            </summary>
        </member>
        <member name="M:Humanizer.ByteSizeExtensions.Bytes(System.UInt32)">
            <summary>
            Considers input as bytes
            </summary>
        </member>
        <member name="M:Humanizer.ByteSizeExtensions.Bytes(System.Double)">
            <summary>
            Considers input as bytes
            </summary>
        </member>
        <member name="M:Humanizer.ByteSizeExtensions.Bytes(System.Int64)">
            <summary>
            Considers input as bytes
            </summary>
        </member>
        <member name="M:Humanizer.ByteSizeExtensions.Kilobytes(System.Byte)">
            <summary>
            Considers input as kilobytes
            </summary>
        </member>
        <member name="M:Humanizer.ByteSizeExtensions.Kilobytes(System.SByte)">
            <summary>
            Considers input as kilobytes
            </summary>
        </member>
        <member name="M:Humanizer.ByteSizeExtensions.Kilobytes(System.Int16)">
            <summary>
            Considers input as kilobytes
            </summary>
        </member>
        <member name="M:Humanizer.ByteSizeExtensions.Kilobytes(System.UInt16)">
            <summary>
            Considers input as kilobytes
            </summary>
        </member>
        <member name="M:Humanizer.ByteSizeExtensions.Kilobytes(System.Int32)">
            <summary>
            Considers input as kilobytes
            </summary>
        </member>
        <member name="M:Humanizer.ByteSizeExtensions.Kilobytes(System.UInt32)">
            <summary>
            Considers input as kilobytes
            </summary>
        </member>
        <member name="M:Humanizer.ByteSizeExtensions.Kilobytes(System.Double)">
            <summary>
            Considers input as kilobytes
            </summary>
        </member>
        <member name="M:Humanizer.ByteSizeExtensions.Kilobytes(System.Int64)">
            <summary>
            Considers input as kilobytes
            </summary>
        </member>
        <member name="M:Humanizer.ByteSizeExtensions.Megabytes(System.Byte)">
            <summary>
            Considers input as megabytes
            </summary>
        </member>
        <member name="M:Humanizer.ByteSizeExtensions.Megabytes(System.SByte)">
            <summary>
            Considers input as megabytes
            </summary>
        </member>
        <member name="M:Humanizer.ByteSizeExtensions.Megabytes(System.Int16)">
            <summary>
            Considers input as megabytes
            </summary>
        </member>
        <member name="M:Humanizer.ByteSizeExtensions.Megabytes(System.UInt16)">
            <summary>
            Considers input as megabytes
            </summary>
        </member>
        <member name="M:Humanizer.ByteSizeExtensions.Megabytes(System.Int32)">
            <summary>
            Considers input as megabytes
            </summary>
        </member>
        <member name="M:Humanizer.ByteSizeExtensions.Megabytes(System.UInt32)">
            <summary>
            Considers input as megabytes
            </summary>
        </member>
        <member name="M:Humanizer.ByteSizeExtensions.Megabytes(System.Double)">
            <summary>
            Considers input as megabytes
            </summary>
        </member>
        <member name="M:Humanizer.ByteSizeExtensions.Megabytes(System.Int64)">
            <summary>
            Considers input as megabytes
            </summary>
        </member>
        <member name="M:Humanizer.ByteSizeExtensions.Gigabytes(System.Byte)">
            <summary>
            Considers input as gigabytes
            </summary>
        </member>
        <member name="M:Humanizer.ByteSizeExtensions.Gigabytes(System.SByte)">
            <summary>
            Considers input as gigabytes
            </summary>
        </member>
        <member name="M:Humanizer.ByteSizeExtensions.Gigabytes(System.Int16)">
            <summary>
            Considers input as gigabytes
            </summary>
        </member>
        <member name="M:Humanizer.ByteSizeExtensions.Gigabytes(System.UInt16)">
            <summary>
            Considers input as gigabytes
            </summary>
        </member>
        <member name="M:Humanizer.ByteSizeExtensions.Gigabytes(System.Int32)">
            <summary>
            Considers input as gigabytes
            </summary>
        </member>
        <member name="M:Humanizer.ByteSizeExtensions.Gigabytes(System.UInt32)">
            <summary>
            Considers input as gigabytes
            </summary>
        </member>
        <member name="M:Humanizer.ByteSizeExtensions.Gigabytes(System.Double)">
            <summary>
            Considers input as gigabytes
            </summary>
        </member>
        <member name="M:Humanizer.ByteSizeExtensions.Gigabytes(System.Int64)">
            <summary>
            Considers input as gigabytes
            </summary>
        </member>
        <member name="M:Humanizer.ByteSizeExtensions.Terabytes(System.Byte)">
            <summary>
            Considers input as terabytes
            </summary>
        </member>
        <member name="M:Humanizer.ByteSizeExtensions.Terabytes(System.SByte)">
            <summary>
            Considers input as terabytes
            </summary>
        </member>
        <member name="M:Humanizer.ByteSizeExtensions.Terabytes(System.Int16)">
            <summary>
            Considers input as terabytes
            </summary>
        </member>
        <member name="M:Humanizer.ByteSizeExtensions.Terabytes(System.UInt16)">
            <summary>
            Considers input as terabytes
            </summary>
        </member>
        <member name="M:Humanizer.ByteSizeExtensions.Terabytes(System.Int32)">
            <summary>
            Considers input as terabytes
            </summary>
        </member>
        <member name="M:Humanizer.ByteSizeExtensions.Terabytes(System.UInt32)">
            <summary>
            Considers input as terabytes
            </summary>
        </member>
        <member name="M:Humanizer.ByteSizeExtensions.Terabytes(System.Double)">
            <summary>
            Considers input as terabytes
            </summary>
        </member>
        <member name="M:Humanizer.ByteSizeExtensions.Terabytes(System.Int64)">
            <summary>
            Considers input as terabytes
            </summary>
        </member>
        <member name="M:Humanizer.ByteSizeExtensions.Humanize(Humanizer.ByteSize,System.String)">
            <summary>
            Turns a byte quantity into human readable form, eg 2 GB
            </summary>
            <param name="format">The string format to use</param>
        </member>
        <member name="M:Humanizer.ByteSizeExtensions.Humanize(Humanizer.ByteSize,System.IFormatProvider)">
            <summary>
            Turns a byte quantity into human readable form, eg 2 GB
            </summary>
            <param name="formatProvider">The format provider to use</param>
        </member>
        <member name="M:Humanizer.ByteSizeExtensions.Humanize(Humanizer.ByteSize,System.String,System.IFormatProvider)">
            <summary>
            Turns a byte quantity into human readable form, eg 2 GB
            </summary>
            <param name="format">The string format to use</param>
            <param name="formatProvider">The format provider to use</param>
        </member>
        <member name="M:Humanizer.ByteSizeExtensions.Per(Humanizer.ByteSize,System.TimeSpan)">
            <summary>
            Turns a quantity of bytes in a given interval into a rate that can be manipulated
            </summary>
            <param name="size">Quantity of bytes</param>
            <param name="interval">Interval to create rate for</param>
        </member>
        <member name="T:Humanizer.CasingExtensions">
            <summary>
            ApplyCase method to allow changing the case of a sentence easily
            </summary>
        </member>
        <member name="M:Humanizer.CasingExtensions.ApplyCase(System.String,Humanizer.LetterCasing)">
            <summary>
            Changes the casing of the provided input
            </summary>
        </member>
        <member name="T:Humanizer.ClockNotationRounding">
            <summary>
            Options for specifying readable clock notation
            </summary>
        </member>
        <member name="F:Humanizer.ClockNotationRounding.None">
            <summary>
            Do not round minutes
            </summary>
        </member>
        <member name="F:Humanizer.ClockNotationRounding.NearestFiveMinutes">
            <summary>
            Round time to nearest five minutes
            </summary>
        </member>
        <member name="T:Humanizer.CollectionHumanizeExtensions">
            <summary>
            Humanizes an IEnumerable into a human readable list
            </summary>
        </member>
        <member name="M:Humanizer.CollectionHumanizeExtensions.Humanize``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Formats the collection for display, calling ToString() on each object and
            using the default separator for the current culture.
            </summary>
        </member>
        <member name="M:Humanizer.CollectionHumanizeExtensions.Humanize``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.String})">
            <summary>
            Formats the collection for display, calling <paramref name="displayFormatter"/> on each element
            and using the default separator for the current culture.
            </summary>
        </member>
        <member name="M:Humanizer.CollectionHumanizeExtensions.Humanize``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Object})">
            <summary>
            Formats the collection for display, calling <paramref name="displayFormatter"/> on each element
            and using the default separator for the current culture.
            </summary>
        </member>
        <member name="M:Humanizer.CollectionHumanizeExtensions.Humanize``1(System.Collections.Generic.IEnumerable{``0},System.String)">
            <summary>
            Formats the collection for display, calling ToString() on each object
            and using the provided separator.
            </summary>
        </member>
        <member name="M:Humanizer.CollectionHumanizeExtensions.Humanize``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.String},System.String)">
            <summary>
            Formats the collection for display, calling <paramref name="displayFormatter"/> on each element
            and using the provided separator.
            </summary>
        </member>
        <member name="M:Humanizer.CollectionHumanizeExtensions.Humanize``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Object},System.String)">
            <summary>
            Formats the collection for display, calling <paramref name="displayFormatter"/> on each element
            and using the provided separator.
            </summary>
        </member>
        <member name="T:Humanizer.Configurator">
            <summary>
            Provides a configuration point for Humanizer
            </summary>
        </member>
        <member name="P:Humanizer.Configurator.CollectionFormatters">
            <summary>
            A registry of formatters used to format collections based on the current locale
            </summary>
        </member>
        <member name="P:Humanizer.Configurator.Formatters">
            <summary>
            A registry of formatters used to format strings based on the current locale
            </summary>
        </member>
        <member name="P:Humanizer.Configurator.NumberToWordsConverters">
            <summary>
            A registry of number to words converters used to localise ToWords and ToOrdinalWords methods
            </summary>
        </member>
        <member name="P:Humanizer.Configurator.Ordinalizers">
            <summary>
            A registry of ordinalizers used to localise Ordinalize method
            </summary>
        </member>
        <member name="P:Humanizer.Configurator.DateToOrdinalWordsConverters">
            <summary>
            A registry of ordinalizers used to localise Ordinalize method
            </summary>
        </member>
        <member name="M:Humanizer.Configurator.GetFormatter(System.Globalization.CultureInfo)">
            <summary>
            The formatter to be used
            </summary>
            <param name="culture">The culture to retrieve formatter for. Null means that current thread's UI culture should be used.</param>
        </member>
        <member name="M:Humanizer.Configurator.GetNumberToWordsConverter(System.Globalization.CultureInfo)">
            <summary>
            The converter to be used
            </summary>
            <param name="culture">The culture to retrieve number to words converter for. Null means that current thread's UI culture should be used.</param>
        </member>
        <member name="P:Humanizer.Configurator.Ordinalizer">
            <summary>
            The ordinalizer to be used
            </summary>
        </member>
        <member name="P:Humanizer.Configurator.DateToOrdinalWordsConverter">
            <summary>
            The ordinalizer to be used
            </summary>
        </member>
        <member name="P:Humanizer.Configurator.DateTimeHumanizeStrategy">
            <summary>
            The strategy to be used for DateTime.Humanize
            </summary>
        </member>
        <member name="P:Humanizer.Configurator.DateTimeOffsetHumanizeStrategy">
            <summary>
            The strategy to be used for DateTimeOffset.Humanize
            </summary>
        </member>
        <member name="M:Humanizer.Configurator.UseEnumDescriptionPropertyLocator(System.Func{System.Reflection.PropertyInfo,System.Boolean})">
            <summary>
            Use a predicate function for description property of attribute to use for Enum.Humanize
            </summary>
        </member>
        <member name="T:Humanizer.LocaliserRegistry`1">
            <summary>
            A registry of localised system components with their associated locales
            </summary>
        </member>
        <member name="M:Humanizer.LocaliserRegistry`1.#ctor(`0)">
            <summary>
            Creates a localiser registry with the default localiser set to the provided value
            </summary>
        </member>
        <member name="M:Humanizer.LocaliserRegistry`1.#ctor(System.Func{System.Globalization.CultureInfo,`0})">
            <summary>
            Creates a localiser registry with the default localiser factory set to the provided value
            </summary>
        </member>
        <member name="M:Humanizer.LocaliserRegistry`1.ResolveForUiCulture">
            <summary>
            Gets the localiser for the current thread's UI culture
            </summary>
        </member>
        <member name="M:Humanizer.LocaliserRegistry`1.ResolveForCulture(System.Globalization.CultureInfo)">
            <summary>
            Gets the localiser for the specified culture
            </summary>
            <param name="culture">The culture to retrieve localiser for. If not specified, current thread's UI culture is used.</param>
        </member>
        <member name="M:Humanizer.LocaliserRegistry`1.Register(System.String,`0)">
            <summary>
            Registers the localiser for the culture provided
            </summary>
        </member>
        <member name="M:Humanizer.LocaliserRegistry`1.Register(System.String,System.Func{System.Globalization.CultureInfo,`0})">
            <summary>
            Registers the localiser factory for the culture provided
            </summary>
        </member>
        <member name="T:Humanizer.DateHumanizeExtensions">
            <summary>
            Humanizes DateTime into human readable sentence
            </summary>
        </member>
        <member name="M:Humanizer.DateHumanizeExtensions.Humanize(System.DateTime,System.Nullable{System.Boolean},System.Nullable{System.DateTime},System.Globalization.CultureInfo)">
            <summary>
            Turns the current or provided date into a human readable sentence
            </summary>
            <param name="input">The date to be humanized</param>
            <param name="utcDate">Nullable boolean value indicating whether the date is in UTC or local. If null, current date is used with the same DateTimeKind of input</param>
            <param name="dateToCompareAgainst">Date to compare the input against. If null, current date is used as base</param>
            <param name="culture">Culture to use. If null, current thread's UI culture is used.</param>
            <returns>distance of time in words</returns>
        </member>
        <member name="M:Humanizer.DateHumanizeExtensions.Humanize(System.Nullable{System.DateTime},System.Nullable{System.Boolean},System.Nullable{System.DateTime},System.Globalization.CultureInfo)">
            <summary>
            Turns the current or provided date into a human readable sentence, overload for the nullable DateTime, returning 'never' in case null
            </summary>
            <param name="input">The date to be humanized</param>
            <param name="utcDate">Nullable boolean value indicating whether the date is in UTC or local. If null, current date is used with the same DateTimeKind of input</param>
            <param name="dateToCompareAgainst">Date to compare the input against. If null, current date is used as base</param>
            <param name="culture">Culture to use. If null, current thread's UI culture is used.</param>
            <returns>distance of time in words</returns>
        </member>
        <member name="M:Humanizer.DateHumanizeExtensions.Humanize(System.DateTimeOffset,System.Nullable{System.DateTimeOffset},System.Globalization.CultureInfo)">
            <summary>
            Turns the current or provided date into a human readable sentence
            </summary>
            <param name="input">The date to be humanized</param>
            <param name="dateToCompareAgainst">Date to compare the input against. If null, current date is used as base</param>
            <param name="culture">Culture to use. If null, current thread's UI culture is used.</param>
            <returns>distance of time in words</returns>
        </member>
        <member name="M:Humanizer.DateHumanizeExtensions.Humanize(System.Nullable{System.DateTimeOffset},System.Nullable{System.DateTimeOffset},System.Globalization.CultureInfo)">
            <summary>
            Turns the current or provided date into a human readable sentence, overload for the nullable DateTimeOffset, returning 'never' in case null
            </summary>
            <param name="input">The date to be humanized</param>
            <param name="dateToCompareAgainst">Date to compare the input against. If null, current date is used as base</param>
            <param name="culture">Culture to use. If null, current thread's UI culture is used.</param>
            <returns>distance of time in words</returns>
        </member>
        <member name="T:Humanizer.DateTimeHumanizeAlgorithms">
            <summary>
            Algorithms used to convert distance between two dates into words.
            </summary>
        </member>
        <member name="M:Humanizer.DateTimeHumanizeAlgorithms.PrecisionHumanize(System.DateTime,System.DateTime,System.Double,System.Globalization.CultureInfo)">
            <summary>
            Returns localized &amp; humanized distance of time between two dates; given a specific precision.
            </summary>
        </member>
        <member name="M:Humanizer.DateTimeHumanizeAlgorithms.DefaultHumanize(System.DateTime,System.DateTime,System.Globalization.CultureInfo)">
            <summary>
            Calculates the distance of time in words between two provided dates
            </summary>
        </member>
        <member name="T:Humanizer.DefaultDateTimeHumanizeStrategy">
            <summary>
            The default 'distance of time' -> words calculator.
            </summary>
        </member>
        <member name="M:Humanizer.DefaultDateTimeHumanizeStrategy.Humanize(System.DateTime,System.DateTime,System.Globalization.CultureInfo)">
            <summary>
            Calculates the distance of time in words between two provided dates
            </summary>
        </member>
        <member name="T:Humanizer.DefaultDateTimeOffsetHumanizeStrategy">
            <summary>
            The default 'distance of time' -> words calculator.
            </summary>
        </member>
        <member name="M:Humanizer.DefaultDateTimeOffsetHumanizeStrategy.Humanize(System.DateTimeOffset,System.DateTimeOffset,System.Globalization.CultureInfo)">
            <summary>
            Calculates the distance of time in words between two provided dates
            </summary>
        </member>
        <member name="T:Humanizer.IDateTimeHumanizeStrategy">
            <summary>
            Implement this interface to create a new strategy for DateTime.Humanize and hook it in the Configurator.DateTimeHumanizeStrategy
            </summary>
        </member>
        <member name="M:Humanizer.IDateTimeHumanizeStrategy.Humanize(System.DateTime,System.DateTime,System.Globalization.CultureInfo)">
            <summary>
            Calculates the distance of time in words between two provided dates used for DateTime.Humanize
            </summary>
        </member>
        <member name="T:Humanizer.IDateTimeOffsetHumanizeStrategy">
            <summary>
            Implement this interface to create a new strategy for DateTime.Humanize and hook it in the Configurator.DateTimeOffsetHumanizeStrategy
            </summary>
        </member>
        <member name="M:Humanizer.IDateTimeOffsetHumanizeStrategy.Humanize(System.DateTimeOffset,System.DateTimeOffset,System.Globalization.CultureInfo)">
            <summary>
            Calculates the distance of time in words between two provided dates used for DateTimeOffset.Humanize
            </summary>
        </member>
        <member name="T:Humanizer.PrecisionDateTimeHumanizeStrategy">
            <summary>
            Precision-based calculator for distance between two times
            </summary>
        </member>
        <member name="M:Humanizer.PrecisionDateTimeHumanizeStrategy.#ctor(System.Double)">
            <summary>
            Constructs a precision-based calculator for distance of time with default precision 0.75.
            </summary>
            <param name="precision">precision of approximation, if not provided  0.75 will be used as a default precision.</param>
        </member>
        <member name="M:Humanizer.PrecisionDateTimeHumanizeStrategy.Humanize(System.DateTime,System.DateTime,System.Globalization.CultureInfo)">
            <summary>
            Returns localized &amp; humanized distance of time between two dates; given a specific precision.
            </summary>
        </member>
        <member name="T:Humanizer.PrecisionDateTimeOffsetHumanizeStrategy">
            <summary>
            Precision-based calculator for distance between two times
            </summary>
        </member>
        <member name="M:Humanizer.PrecisionDateTimeOffsetHumanizeStrategy.#ctor(System.Double)">
            <summary>
            Constructs a precision-based calculator for distance of time with default precision 0.75.
            </summary>
            <param name="precision">precision of approximation, if not provided  0.75 will be used as a default precision.</param>
        </member>
        <member name="M:Humanizer.PrecisionDateTimeOffsetHumanizeStrategy.Humanize(System.DateTimeOffset,System.DateTimeOffset,System.Globalization.CultureInfo)">
            <summary>
            Returns localized &amp; humanized distance of time between two dates; given a specific precision.
            </summary>
        </member>
        <member name="T:Humanizer.DateToOrdinalWordsExtensions">
            <summary>
            Humanizes DateTime into human readable sentence
            </summary>
        </member>
        <member name="M:Humanizer.DateToOrdinalWordsExtensions.ToOrdinalWords(System.DateTime)">
            <summary>
            Turns the provided date into ordinal words
            </summary>
            <param name="input">The date to be made into ordinal words</param>
            <returns>The date in ordinal words</returns>
        </member>
        <member name="M:Humanizer.DateToOrdinalWordsExtensions.ToOrdinalWords(System.DateTime,Humanizer.GrammaticalCase)">
            <summary>
            Turns the provided date into ordinal words
            </summary>
            <param name="input">The date to be made into ordinal words</param>
            <param name="grammaticalCase">The grammatical case to use for output words</param>
            <returns>The date in ordinal words</returns>
        </member>
        <member name="T:Humanizer.EnumDehumanizeExtensions">
            <summary>
            Contains extension methods for dehumanizing Enum string values.
            </summary>
        </member>
        <member name="M:Humanizer.EnumDehumanizeExtensions.DehumanizeTo``1(System.String)">
            <summary>
            Dehumanizes a string into the Enum it was originally Humanized from!
            </summary>
            <typeparam name="TTargetEnum">The target enum</typeparam>
            <param name="input">The string to be converted</param>
            <exception cref="T:System.ArgumentException">If TTargetEnum is not an enum</exception>
            <exception cref="T:Humanizer.NoMatchFoundException">Couldn't find any enum member that matches the string</exception>
        </member>
        <member name="M:Humanizer.EnumDehumanizeExtensions.DehumanizeTo``1(System.String,Humanizer.OnNoMatch)">
            <summary>
            Dehumanizes a string into the Enum it was originally Humanized from!
            </summary>
            <typeparam name="TTargetEnum">The target enum</typeparam>
            <param name="input">The string to be converted</param>
            <exception cref="T:System.ArgumentException">If TTargetEnum is not an enum</exception>
            <exception cref="T:Humanizer.NoMatchFoundException">Couldn't find any enum member that matches the string</exception>
        </member>
        <member name="M:Humanizer.EnumDehumanizeExtensions.DehumanizeTo(System.String,System.Type,Humanizer.OnNoMatch)">
            <summary>
            Dehumanizes a string into the Enum it was originally Humanized from!
            </summary>
            <param name="input">The string to be converted</param>
            <param name="targetEnum">The target enum</param>
            <param name="onNoMatch">What to do when input is not matched to the enum.</param>
            <exception cref="T:Humanizer.NoMatchFoundException">Couldn't find any enum member that matches the string</exception>
            <exception cref="T:System.ArgumentException">If targetEnum is not an enum</exception>
        </member>
        <member name="T:Humanizer.EnumHumanizeExtensions">
            <summary>
            Contains extension methods for humanizing Enums
            </summary>
        </member>
        <member name="M:Humanizer.EnumHumanizeExtensions.Humanize``1(``0)">
            <summary>
            Turns an enum member into a human readable string; e.g. AnonymousUser -> Anonymous user. It also honors DescriptionAttribute data annotation
            </summary>
            <param name="input">The enum member to be humanized</param>
        </member>
        <member name="M:Humanizer.EnumHumanizeExtensions.Humanize``1(``0,Humanizer.LetterCasing)">
            <summary>
            Turns an enum member into a human readable string with the provided casing; e.g. AnonymousUser with Title casing -> Anonymous User. It also honors DescriptionAttribute data annotation
            </summary>
            <param name="input">The enum member to be humanized</param>
            <param name="casing">The casing to use for humanizing the enum member</param>
        </member>
        <member name="T:Humanizer.In">
            <summary>
            </summary>
        </member>
        <member name="M:Humanizer.In.TheYear(System.Int32)">
            <summary>
            Returns the first of January of the provided year
            </summary>
        </member>
        <member name="P:Humanizer.In.January">
            <summary>
            Returns 1st of January of the current year
            </summary>
        </member>
        <member name="M:Humanizer.In.JanuaryOf(System.Int32)">
            <summary>
            Returns 1st of January of the year passed in
            </summary>
        </member>
        <member name="P:Humanizer.In.February">
            <summary>
            Returns 1st of February of the current year
            </summary>
        </member>
        <member name="M:Humanizer.In.FebruaryOf(System.Int32)">
            <summary>
            Returns 1st of February of the year passed in
            </summary>
        </member>
        <member name="P:Humanizer.In.March">
            <summary>
            Returns 1st of March of the current year
            </summary>
        </member>
        <member name="M:Humanizer.In.MarchOf(System.Int32)">
            <summary>
            Returns 1st of March of the year passed in
            </summary>
        </member>
        <member name="P:Humanizer.In.April">
            <summary>
            Returns 1st of April of the current year
            </summary>
        </member>
        <member name="M:Humanizer.In.AprilOf(System.Int32)">
            <summary>
            Returns 1st of April of the year passed in
            </summary>
        </member>
        <member name="P:Humanizer.In.May">
            <summary>
            Returns 1st of May of the current year
            </summary>
        </member>
        <member name="M:Humanizer.In.MayOf(System.Int32)">
            <summary>
            Returns 1st of May of the year passed in
            </summary>
        </member>
        <member name="P:Humanizer.In.June">
            <summary>
            Returns 1st of June of the current year
            </summary>
        </member>
        <member name="M:Humanizer.In.JuneOf(System.Int32)">
            <summary>
            Returns 1st of June of the year passed in
            </summary>
        </member>
        <member name="P:Humanizer.In.July">
            <summary>
            Returns 1st of July of the current year
            </summary>
        </member>
        <member name="M:Humanizer.In.JulyOf(System.Int32)">
            <summary>
            Returns 1st of July of the year passed in
            </summary>
        </member>
        <member name="P:Humanizer.In.August">
            <summary>
            Returns 1st of August of the current year
            </summary>
        </member>
        <member name="M:Humanizer.In.AugustOf(System.Int32)">
            <summary>
            Returns 1st of August of the year passed in
            </summary>
        </member>
        <member name="P:Humanizer.In.September">
            <summary>
            Returns 1st of September of the current year
            </summary>
        </member>
        <member name="M:Humanizer.In.SeptemberOf(System.Int32)">
            <summary>
            Returns 1st of September of the year passed in
            </summary>
        </member>
        <member name="P:Humanizer.In.October">
            <summary>
            Returns 1st of October of the current year
            </summary>
        </member>
        <member name="M:Humanizer.In.OctoberOf(System.Int32)">
            <summary>
            Returns 1st of October of the year passed in
            </summary>
        </member>
        <member name="P:Humanizer.In.November">
            <summary>
            Returns 1st of November of the current year
            </summary>
        </member>
        <member name="M:Humanizer.In.NovemberOf(System.Int32)">
            <summary>
            Returns 1st of November of the year passed in
            </summary>
        </member>
        <member name="P:Humanizer.In.December">
            <summary>
            Returns 1st of December of the current year
            </summary>
        </member>
        <member name="M:Humanizer.In.DecemberOf(System.Int32)">
            <summary>
            Returns 1st of December of the year passed in
            </summary>
        </member>
        <member name="T:Humanizer.In.One">
            <summary>
            </summary>
        </member>
        <member name="P:Humanizer.In.One.Second">
            <summary>
            1 seconds from now
            </summary>
        </member>
        <member name="M:Humanizer.In.One.SecondFrom(System.DateTime)">
            <summary>
            1 seconds from the provided date
            </summary>
        </member>
        <member name="P:Humanizer.In.One.Minute">
            <summary>
            1 minutes from now
            </summary>
        </member>
        <member name="M:Humanizer.In.One.MinuteFrom(System.DateTime)">
            <summary>
            1 minutes from the provided date
            </summary>
        </member>
        <member name="P:Humanizer.In.One.Hour">
            <summary>
            1 hours from now
            </summary>
        </member>
        <member name="M:Humanizer.In.One.HourFrom(System.DateTime)">
            <summary>
            1 hours from the provided date
            </summary>
        </member>
        <member name="P:Humanizer.In.One.Day">
            <summary>
            1 days from now
            </summary>
        </member>
        <member name="M:Humanizer.In.One.DayFrom(System.DateTime)">
            <summary>
            1 days from the provided date
            </summary>
        </member>
        <member name="P:Humanizer.In.One.Week">
            <summary>
            1 weeks from now
            </summary>
        </member>
        <member name="M:Humanizer.In.One.WeekFrom(System.DateTime)">
            <summary>
            1 weeks from the provided date
            </summary>
        </member>
        <member name="P:Humanizer.In.One.Month">
            <summary>
            1 months from now
            </summary>
        </member>
        <member name="M:Humanizer.In.One.MonthFrom(System.DateTime)">
            <summary>
            1 months from the provided date
            </summary>
        </member>
        <member name="P:Humanizer.In.One.Year">
            <summary>
            1 years from now
            </summary>
        </member>
        <member name="M:Humanizer.In.One.YearFrom(System.DateTime)">
            <summary>
            1 years from the provided date
            </summary>
        </member>
        <member name="T:Humanizer.In.Two">
            <summary>
            </summary>
        </member>
        <member name="P:Humanizer.In.Two.Seconds">
            <summary>
            2 seconds from now
            </summary>
        </member>
        <member name="M:Humanizer.In.Two.SecondsFrom(System.DateTime)">
            <summary>
            2 seconds from the provided date
            </summary>
        </member>
        <member name="P:Humanizer.In.Two.Minutes">
            <summary>
            2 minutes from now
            </summary>
        </member>
        <member name="M:Humanizer.In.Two.MinutesFrom(System.DateTime)">
            <summary>
            2 minutes from the provided date
            </summary>
        </member>
        <member name="P:Humanizer.In.Two.Hours">
            <summary>
            2 hours from now
            </summary>
        </member>
        <member name="M:Humanizer.In.Two.HoursFrom(System.DateTime)">
            <summary>
            2 hours from the provided date
            </summary>
        </member>
        <member name="P:Humanizer.In.Two.Days">
            <summary>
            2 days from now
            </summary>
        </member>
        <member name="M:Humanizer.In.Two.DaysFrom(System.DateTime)">
            <summary>
            2 days from the provided date
            </summary>
        </member>
        <member name="P:Humanizer.In.Two.Weeks">
            <summary>
            2 weeks from now
            </summary>
        </member>
        <member name="M:Humanizer.In.Two.WeeksFrom(System.DateTime)">
            <summary>
            2 weeks from the provided date
            </summary>
        </member>
        <member name="P:Humanizer.In.Two.Months">
            <summary>
            2 months from now
            </summary>
        </member>
        <member name="M:Humanizer.In.Two.MonthsFrom(System.DateTime)">
            <summary>
            2 months from the provided date
            </summary>
        </member>
        <member name="P:Humanizer.In.Two.Years">
            <summary>
            2 years from now
            </summary>
        </member>
        <member name="M:Humanizer.In.Two.YearsFrom(System.DateTime)">
            <summary>
            2 years from the provided date
            </summary>
        </member>
        <member name="T:Humanizer.In.Three">
            <summary>
            </summary>
        </member>
        <member name="P:Humanizer.In.Three.Seconds">
            <summary>
            3 seconds from now
            </summary>
        </member>
        <member name="M:Humanizer.In.Three.SecondsFrom(System.DateTime)">
            <summary>
            3 seconds from the provided date
            </summary>
        </member>
        <member name="P:Humanizer.In.Three.Minutes">
            <summary>
            3 minutes from now
            </summary>
        </member>
        <member name="M:Humanizer.In.Three.MinutesFrom(System.DateTime)">
            <summary>
            3 minutes from the provided date
            </summary>
        </member>
        <member name="P:Humanizer.In.Three.Hours">
            <summary>
            3 hours from now
            </summary>
        </member>
        <member name="M:Humanizer.In.Three.HoursFrom(System.DateTime)">
            <summary>
            3 hours from the provided date
            </summary>
        </member>
        <member name="P:Humanizer.In.Three.Days">
            <summary>
            3 days from now
            </summary>
        </member>
        <member name="M:Humanizer.In.Three.DaysFrom(System.DateTime)">
            <summary>
            3 days from the provided date
            </summary>
        </member>
        <member name="P:Humanizer.In.Three.Weeks">
            <summary>
            3 weeks from now
            </summary>
        </member>
        <member name="M:Humanizer.In.Three.WeeksFrom(System.DateTime)">
            <summary>
            3 weeks from the provided date
            </summary>
        </member>
        <member name="P:Humanizer.In.Three.Months">
            <summary>
            3 months from now
            </summary>
        </member>
        <member name="M:Humanizer.In.Three.MonthsFrom(System.DateTime)">
            <summary>
            3 months from the provided date
            </summary>
        </member>
        <member name="P:Humanizer.In.Three.Years">
            <summary>
            3 years from now
            </summary>
        </member>
        <member name="M:Humanizer.In.Three.YearsFrom(System.DateTime)">
            <summary>
            3 years from the provided date
            </summary>
        </member>
        <member name="T:Humanizer.In.Four">
            <summary>
            </summary>
        </member>
        <member name="P:Humanizer.In.Four.Seconds">
            <summary>
            4 seconds from now
            </summary>
        </member>
        <member name="M:Humanizer.In.Four.SecondsFrom(System.DateTime)">
            <summary>
            4 seconds from the provided date
            </summary>
        </member>
        <member name="P:Humanizer.In.Four.Minutes">
            <summary>
            4 minutes from now
            </summary>
        </member>
        <member name="M:Humanizer.In.Four.MinutesFrom(System.DateTime)">
            <summary>
            4 minutes from the provided date
            </summary>
        </member>
        <member name="P:Humanizer.In.Four.Hours">
            <summary>
            4 hours from now
            </summary>
        </member>
        <member name="M:Humanizer.In.Four.HoursFrom(System.DateTime)">
            <summary>
            4 hours from the provided date
            </summary>
        </member>
        <member name="P:Humanizer.In.Four.Days">
            <summary>
            4 days from now
            </summary>
        </member>
        <member name="M:Humanizer.In.Four.DaysFrom(System.DateTime)">
            <summary>
            4 days from the provided date
            </summary>
        </member>
        <member name="P:Humanizer.In.Four.Weeks">
            <summary>
            4 weeks from now
            </summary>
        </member>
        <member name="M:Humanizer.In.Four.WeeksFrom(System.DateTime)">
            <summary>
            4 weeks from the provided date
            </summary>
        </member>
        <member name="P:Humanizer.In.Four.Months">
            <summary>
            4 months from now
            </summary>
        </member>
        <member name="M:Humanizer.In.Four.MonthsFrom(System.DateTime)">
            <summary>
            4 months from the provided date
            </summary>
        </member>
        <member name="P:Humanizer.In.Four.Years">
            <summary>
            4 years from now
            </summary>
        </member>
        <member name="M:Humanizer.In.Four.YearsFrom(System.DateTime)">
            <summary>
            4 years from the provided date
            </summary>
        </member>
        <member name="T:Humanizer.In.Five">
            <summary>
            </summary>
        </member>
        <member name="P:Humanizer.In.Five.Seconds">
            <summary>
            5 seconds from now
            </summary>
        </member>
        <member name="M:Humanizer.In.Five.SecondsFrom(System.DateTime)">
            <summary>
            5 seconds from the provided date
            </summary>
        </member>
        <member name="P:Humanizer.In.Five.Minutes">
            <summary>
            5 minutes from now
            </summary>
        </member>
        <member name="M:Humanizer.In.Five.MinutesFrom(System.DateTime)">
            <summary>
            5 minutes from the provided date
            </summary>
        </member>
        <member name="P:Humanizer.In.Five.Hours">
            <summary>
            5 hours from now
            </summary>
        </member>
        <member name="M:Humanizer.In.Five.HoursFrom(System.DateTime)">
            <summary>
            5 hours from the provided date
            </summary>
        </member>
        <member name="P:Humanizer.In.Five.Days">
            <summary>
            5 days from now
            </summary>
        </member>
        <member name="M:Humanizer.In.Five.DaysFrom(System.DateTime)">
            <summary>
            5 days from the provided date
            </summary>
        </member>
        <member name="P:Humanizer.In.Five.Weeks">
            <summary>
            5 weeks from now
            </summary>
        </member>
        <member name="M:Humanizer.In.Five.WeeksFrom(System.DateTime)">
            <summary>
            5 weeks from the provided date
            </summary>
        </member>
        <member name="P:Humanizer.In.Five.Months">
            <summary>
            5 months from now
            </summary>
        </member>
        <member name="M:Humanizer.In.Five.MonthsFrom(System.DateTime)">
            <summary>
            5 months from the provided date
            </summary>
        </member>
        <member name="P:Humanizer.In.Five.Years">
            <summary>
            5 years from now
            </summary>
        </member>
        <member name="M:Humanizer.In.Five.YearsFrom(System.DateTime)">
            <summary>
            5 years from the provided date
            </summary>
        </member>
        <member name="T:Humanizer.In.Six">
            <summary>
            </summary>
        </member>
        <member name="P:Humanizer.In.Six.Seconds">
            <summary>
            6 seconds from now
            </summary>
        </member>
        <member name="M:Humanizer.In.Six.SecondsFrom(System.DateTime)">
            <summary>
            6 seconds from the provided date
            </summary>
        </member>
        <member name="P:Humanizer.In.Six.Minutes">
            <summary>
            6 minutes from now
            </summary>
        </member>
        <member name="M:Humanizer.In.Six.MinutesFrom(System.DateTime)">
            <summary>
            6 minutes from the provided date
            </summary>
        </member>
        <member name="P:Humanizer.In.Six.Hours">
            <summary>
            6 hours from now
            </summary>
        </member>
        <member name="M:Humanizer.In.Six.HoursFrom(System.DateTime)">
            <summary>
            6 hours from the provided date
            </summary>
        </member>
        <member name="P:Humanizer.In.Six.Days">
            <summary>
            6 days from now
            </summary>
        </member>
        <member name="M:Humanizer.In.Six.DaysFrom(System.DateTime)">
            <summary>
            6 days from the provided date
            </summary>
        </member>
        <member name="P:Humanizer.In.Six.Weeks">
            <summary>
            6 weeks from now
            </summary>
        </member>
        <member name="M:Humanizer.In.Six.WeeksFrom(System.DateTime)">
            <summary>
            6 weeks from the provided date
            </summary>
        </member>
        <member name="P:Humanizer.In.Six.Months">
            <summary>
            6 months from now
            </summary>
        </member>
        <member name="M:Humanizer.In.Six.MonthsFrom(System.DateTime)">
            <summary>
            6 months from the provided date
            </summary>
        </member>
        <member name="P:Humanizer.In.Six.Years">
            <summary>
            6 years from now
            </summary>
        </member>
        <member name="M:Humanizer.In.Six.YearsFrom(System.DateTime)">
            <summary>
            6 years from the provided date
            </summary>
        </member>
        <member name="T:Humanizer.In.Seven">
            <summary>
            </summary>
        </member>
        <member name="P:Humanizer.In.Seven.Seconds">
            <summary>
            7 seconds from now
            </summary>
        </member>
        <member name="M:Humanizer.In.Seven.SecondsFrom(System.DateTime)">
            <summary>
            7 seconds from the provided date
            </summary>
        </member>
        <member name="P:Humanizer.In.Seven.Minutes">
            <summary>
            7 minutes from now
            </summary>
        </member>
        <member name="M:Humanizer.In.Seven.MinutesFrom(System.DateTime)">
            <summary>
            7 minutes from the provided date
            </summary>
        </member>
        <member name="P:Humanizer.In.Seven.Hours">
            <summary>
            7 hours from now
            </summary>
        </member>
        <member name="M:Humanizer.In.Seven.HoursFrom(System.DateTime)">
            <summary>
            7 hours from the provided date
            </summary>
        </member>
        <member name="P:Humanizer.In.Seven.Days">
            <summary>
            7 days from now
            </summary>
        </member>
        <member name="M:Humanizer.In.Seven.DaysFrom(System.DateTime)">
            <summary>
            7 days from the provided date
            </summary>
        </member>
        <member name="P:Humanizer.In.Seven.Weeks">
            <summary>
            7 weeks from now
            </summary>
        </member>
        <member name="M:Humanizer.In.Seven.WeeksFrom(System.DateTime)">
            <summary>
            7 weeks from the provided date
            </summary>
        </member>
        <member name="P:Humanizer.In.Seven.Months">
            <summary>
            7 months from now
            </summary>
        </member>
        <member name="M:Humanizer.In.Seven.MonthsFrom(System.DateTime)">
            <summary>
            7 months from the provided date
            </summary>
        </member>
        <member name="P:Humanizer.In.Seven.Years">
            <summary>
            7 years from now
            </summary>
        </member>
        <member name="M:Humanizer.In.Seven.YearsFrom(System.DateTime)">
            <summary>
            7 years from the provided date
            </summary>
        </member>
        <member name="T:Humanizer.In.Eight">
            <summary>
            </summary>
        </member>
        <member name="P:Humanizer.In.Eight.Seconds">
            <summary>
            8 seconds from now
            </summary>
        </member>
        <member name="M:Humanizer.In.Eight.SecondsFrom(System.DateTime)">
            <summary>
            8 seconds from the provided date
            </summary>
        </member>
        <member name="P:Humanizer.In.Eight.Minutes">
            <summary>
            8 minutes from now
            </summary>
        </member>
        <member name="M:Humanizer.In.Eight.MinutesFrom(System.DateTime)">
            <summary>
            8 minutes from the provided date
            </summary>
        </member>
        <member name="P:Humanizer.In.Eight.Hours">
            <summary>
            8 hours from now
            </summary>
        </member>
        <member name="M:Humanizer.In.Eight.HoursFrom(System.DateTime)">
            <summary>
            8 hours from the provided date
            </summary>
        </member>
        <member name="P:Humanizer.In.Eight.Days">
            <summary>
            8 days from now
            </summary>
        </member>
        <member name="M:Humanizer.In.Eight.DaysFrom(System.DateTime)">
            <summary>
            8 days from the provided date
            </summary>
        </member>
        <member name="P:Humanizer.In.Eight.Weeks">
            <summary>
            8 weeks from now
            </summary>
        </member>
        <member name="M:Humanizer.In.Eight.WeeksFrom(System.DateTime)">
            <summary>
            8 weeks from the provided date
            </summary>
        </member>
        <member name="P:Humanizer.In.Eight.Months">
            <summary>
            8 months from now
            </summary>
        </member>
        <member name="M:Humanizer.In.Eight.MonthsFrom(System.DateTime)">
            <summary>
            8 months from the provided date
            </summary>
        </member>
        <member name="P:Humanizer.In.Eight.Years">
            <summary>
            8 years from now
            </summary>
        </member>
        <member name="M:Humanizer.In.Eight.YearsFrom(System.DateTime)">
            <summary>
            8 years from the provided date
            </summary>
        </member>
        <member name="T:Humanizer.In.Nine">
            <summary>
            </summary>
        </member>
        <member name="P:Humanizer.In.Nine.Seconds">
            <summary>
            9 seconds from now
            </summary>
        </member>
        <member name="M:Humanizer.In.Nine.SecondsFrom(System.DateTime)">
            <summary>
            9 seconds from the provided date
            </summary>
        </member>
        <member name="P:Humanizer.In.Nine.Minutes">
            <summary>
            9 minutes from now
            </summary>
        </member>
        <member name="M:Humanizer.In.Nine.MinutesFrom(System.DateTime)">
            <summary>
            9 minutes from the provided date
            </summary>
        </member>
        <member name="P:Humanizer.In.Nine.Hours">
            <summary>
            9 hours from now
            </summary>
        </member>
        <member name="M:Humanizer.In.Nine.HoursFrom(System.DateTime)">
            <summary>
            9 hours from the provided date
            </summary>
        </member>
        <member name="P:Humanizer.In.Nine.Days">
            <summary>
            9 days from now
            </summary>
        </member>
        <member name="M:Humanizer.In.Nine.DaysFrom(System.DateTime)">
            <summary>
            9 days from the provided date
            </summary>
        </member>
        <member name="P:Humanizer.In.Nine.Weeks">
            <summary>
            9 weeks from now
            </summary>
        </member>
        <member name="M:Humanizer.In.Nine.WeeksFrom(System.DateTime)">
            <summary>
            9 weeks from the provided date
            </summary>
        </member>
        <member name="P:Humanizer.In.Nine.Months">
            <summary>
            9 months from now
            </summary>
        </member>
        <member name="M:Humanizer.In.Nine.MonthsFrom(System.DateTime)">
            <summary>
            9 months from the provided date
            </summary>
        </member>
        <member name="P:Humanizer.In.Nine.Years">
            <summary>
            9 years from now
            </summary>
        </member>
        <member name="M:Humanizer.In.Nine.YearsFrom(System.DateTime)">
            <summary>
            9 years from the provided date
            </summary>
        </member>
        <member name="T:Humanizer.In.Ten">
            <summary>
            </summary>
        </member>
        <member name="P:Humanizer.In.Ten.Seconds">
            <summary>
            10 seconds from now
            </summary>
        </member>
        <member name="M:Humanizer.In.Ten.SecondsFrom(System.DateTime)">
            <summary>
            10 seconds from the provided date
            </summary>
        </member>
        <member name="P:Humanizer.In.Ten.Minutes">
            <summary>
            10 minutes from now
            </summary>
        </member>
        <member name="M:Humanizer.In.Ten.MinutesFrom(System.DateTime)">
            <summary>
            10 minutes from the provided date
            </summary>
        </member>
        <member name="P:Humanizer.In.Ten.Hours">
            <summary>
            10 hours from now
            </summary>
        </member>
        <member name="M:Humanizer.In.Ten.HoursFrom(System.DateTime)">
            <summary>
            10 hours from the provided date
            </summary>
        </member>
        <member name="P:Humanizer.In.Ten.Days">
            <summary>
            10 days from now
            </summary>
        </member>
        <member name="M:Humanizer.In.Ten.DaysFrom(System.DateTime)">
            <summary>
            10 days from the provided date
            </summary>
        </member>
        <member name="P:Humanizer.In.Ten.Weeks">
            <summary>
            10 weeks from now
            </summary>
        </member>
        <member name="M:Humanizer.In.Ten.WeeksFrom(System.DateTime)">
            <summary>
            10 weeks from the provided date
            </summary>
        </member>
        <member name="P:Humanizer.In.Ten.Months">
            <summary>
            10 months from now
            </summary>
        </member>
        <member name="M:Humanizer.In.Ten.MonthsFrom(System.DateTime)">
            <summary>
            10 months from the provided date
            </summary>
        </member>
        <member name="P:Humanizer.In.Ten.Years">
            <summary>
            10 years from now
            </summary>
        </member>
        <member name="M:Humanizer.In.Ten.YearsFrom(System.DateTime)">
            <summary>
            10 years from the provided date
            </summary>
        </member>
        <member name="T:Humanizer.On.January">
            <summary>
            Provides fluent date accessors for January
            </summary>
        </member>
        <member name="M:Humanizer.On.January.The(System.Int32)">
            <summary>
            The nth day of January of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.January.The1st">
            <summary>
            The 1st day of January of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.January.The2nd">
            <summary>
            The 2nd day of January of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.January.The3rd">
            <summary>
            The 3rd day of January of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.January.The4th">
            <summary>
            The 4th day of January of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.January.The5th">
            <summary>
            The 5th day of January of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.January.The6th">
            <summary>
            The 6th day of January of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.January.The7th">
            <summary>
            The 7th day of January of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.January.The8th">
            <summary>
            The 8th day of January of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.January.The9th">
            <summary>
            The 9th day of January of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.January.The10th">
            <summary>
            The 10th day of January of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.January.The11th">
            <summary>
            The 11th day of January of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.January.The12th">
            <summary>
            The 12th day of January of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.January.The13th">
            <summary>
            The 13th day of January of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.January.The14th">
            <summary>
            The 14th day of January of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.January.The15th">
            <summary>
            The 15th day of January of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.January.The16th">
            <summary>
            The 16th day of January of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.January.The17th">
            <summary>
            The 17th day of January of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.January.The18th">
            <summary>
            The 18th day of January of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.January.The19th">
            <summary>
            The 19th day of January of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.January.The20th">
            <summary>
            The 20th day of January of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.January.The21st">
            <summary>
            The 21st day of January of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.January.The22nd">
            <summary>
            The 22nd day of January of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.January.The23rd">
            <summary>
            The 23rd day of January of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.January.The24th">
            <summary>
            The 24th day of January of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.January.The25th">
            <summary>
            The 25th day of January of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.January.The26th">
            <summary>
            The 26th day of January of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.January.The27th">
            <summary>
            The 27th day of January of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.January.The28th">
            <summary>
            The 28th day of January of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.January.The29th">
            <summary>
            The 29th day of January of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.January.The30th">
            <summary>
            The 30th day of January of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.January.The31st">
            <summary>
            The 31st day of January of the current year
            </summary>
        </member>
        <member name="T:Humanizer.On.February">
            <summary>
            Provides fluent date accessors for February
            </summary>
        </member>
        <member name="M:Humanizer.On.February.The(System.Int32)">
            <summary>
            The nth day of February of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.February.The1st">
            <summary>
            The 1st day of February of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.February.The2nd">
            <summary>
            The 2nd day of February of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.February.The3rd">
            <summary>
            The 3rd day of February of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.February.The4th">
            <summary>
            The 4th day of February of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.February.The5th">
            <summary>
            The 5th day of February of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.February.The6th">
            <summary>
            The 6th day of February of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.February.The7th">
            <summary>
            The 7th day of February of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.February.The8th">
            <summary>
            The 8th day of February of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.February.The9th">
            <summary>
            The 9th day of February of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.February.The10th">
            <summary>
            The 10th day of February of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.February.The11th">
            <summary>
            The 11th day of February of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.February.The12th">
            <summary>
            The 12th day of February of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.February.The13th">
            <summary>
            The 13th day of February of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.February.The14th">
            <summary>
            The 14th day of February of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.February.The15th">
            <summary>
            The 15th day of February of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.February.The16th">
            <summary>
            The 16th day of February of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.February.The17th">
            <summary>
            The 17th day of February of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.February.The18th">
            <summary>
            The 18th day of February of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.February.The19th">
            <summary>
            The 19th day of February of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.February.The20th">
            <summary>
            The 20th day of February of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.February.The21st">
            <summary>
            The 21st day of February of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.February.The22nd">
            <summary>
            The 22nd day of February of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.February.The23rd">
            <summary>
            The 23rd day of February of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.February.The24th">
            <summary>
            The 24th day of February of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.February.The25th">
            <summary>
            The 25th day of February of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.February.The26th">
            <summary>
            The 26th day of February of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.February.The27th">
            <summary>
            The 27th day of February of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.February.The28th">
            <summary>
            The 28th day of February of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.February.The29th">
            <summary>
            The 29th day of February of the current year
            </summary>
        </member>
        <member name="T:Humanizer.On.March">
            <summary>
            Provides fluent date accessors for March
            </summary>
        </member>
        <member name="M:Humanizer.On.March.The(System.Int32)">
            <summary>
            The nth day of March of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.March.The1st">
            <summary>
            The 1st day of March of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.March.The2nd">
            <summary>
            The 2nd day of March of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.March.The3rd">
            <summary>
            The 3rd day of March of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.March.The4th">
            <summary>
            The 4th day of March of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.March.The5th">
            <summary>
            The 5th day of March of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.March.The6th">
            <summary>
            The 6th day of March of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.March.The7th">
            <summary>
            The 7th day of March of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.March.The8th">
            <summary>
            The 8th day of March of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.March.The9th">
            <summary>
            The 9th day of March of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.March.The10th">
            <summary>
            The 10th day of March of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.March.The11th">
            <summary>
            The 11th day of March of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.March.The12th">
            <summary>
            The 12th day of March of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.March.The13th">
            <summary>
            The 13th day of March of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.March.The14th">
            <summary>
            The 14th day of March of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.March.The15th">
            <summary>
            The 15th day of March of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.March.The16th">
            <summary>
            The 16th day of March of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.March.The17th">
            <summary>
            The 17th day of March of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.March.The18th">
            <summary>
            The 18th day of March of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.March.The19th">
            <summary>
            The 19th day of March of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.March.The20th">
            <summary>
            The 20th day of March of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.March.The21st">
            <summary>
            The 21st day of March of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.March.The22nd">
            <summary>
            The 22nd day of March of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.March.The23rd">
            <summary>
            The 23rd day of March of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.March.The24th">
            <summary>
            The 24th day of March of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.March.The25th">
            <summary>
            The 25th day of March of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.March.The26th">
            <summary>
            The 26th day of March of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.March.The27th">
            <summary>
            The 27th day of March of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.March.The28th">
            <summary>
            The 28th day of March of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.March.The29th">
            <summary>
            The 29th day of March of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.March.The30th">
            <summary>
            The 30th day of March of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.March.The31st">
            <summary>
            The 31st day of March of the current year
            </summary>
        </member>
        <member name="T:Humanizer.On.April">
            <summary>
            Provides fluent date accessors for April
            </summary>
        </member>
        <member name="M:Humanizer.On.April.The(System.Int32)">
            <summary>
            The nth day of April of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.April.The1st">
            <summary>
            The 1st day of April of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.April.The2nd">
            <summary>
            The 2nd day of April of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.April.The3rd">
            <summary>
            The 3rd day of April of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.April.The4th">
            <summary>
            The 4th day of April of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.April.The5th">
            <summary>
            The 5th day of April of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.April.The6th">
            <summary>
            The 6th day of April of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.April.The7th">
            <summary>
            The 7th day of April of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.April.The8th">
            <summary>
            The 8th day of April of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.April.The9th">
            <summary>
            The 9th day of April of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.April.The10th">
            <summary>
            The 10th day of April of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.April.The11th">
            <summary>
            The 11th day of April of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.April.The12th">
            <summary>
            The 12th day of April of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.April.The13th">
            <summary>
            The 13th day of April of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.April.The14th">
            <summary>
            The 14th day of April of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.April.The15th">
            <summary>
            The 15th day of April of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.April.The16th">
            <summary>
            The 16th day of April of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.April.The17th">
            <summary>
            The 17th day of April of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.April.The18th">
            <summary>
            The 18th day of April of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.April.The19th">
            <summary>
            The 19th day of April of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.April.The20th">
            <summary>
            The 20th day of April of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.April.The21st">
            <summary>
            The 21st day of April of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.April.The22nd">
            <summary>
            The 22nd day of April of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.April.The23rd">
            <summary>
            The 23rd day of April of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.April.The24th">
            <summary>
            The 24th day of April of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.April.The25th">
            <summary>
            The 25th day of April of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.April.The26th">
            <summary>
            The 26th day of April of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.April.The27th">
            <summary>
            The 27th day of April of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.April.The28th">
            <summary>
            The 28th day of April of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.April.The29th">
            <summary>
            The 29th day of April of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.April.The30th">
            <summary>
            The 30th day of April of the current year
            </summary>
        </member>
        <member name="T:Humanizer.On.May">
            <summary>
            Provides fluent date accessors for May
            </summary>
        </member>
        <member name="M:Humanizer.On.May.The(System.Int32)">
            <summary>
            The nth day of May of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.May.The1st">
            <summary>
            The 1st day of May of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.May.The2nd">
            <summary>
            The 2nd day of May of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.May.The3rd">
            <summary>
            The 3rd day of May of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.May.The4th">
            <summary>
            The 4th day of May of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.May.The5th">
            <summary>
            The 5th day of May of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.May.The6th">
            <summary>
            The 6th day of May of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.May.The7th">
            <summary>
            The 7th day of May of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.May.The8th">
            <summary>
            The 8th day of May of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.May.The9th">
            <summary>
            The 9th day of May of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.May.The10th">
            <summary>
            The 10th day of May of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.May.The11th">
            <summary>
            The 11th day of May of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.May.The12th">
            <summary>
            The 12th day of May of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.May.The13th">
            <summary>
            The 13th day of May of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.May.The14th">
            <summary>
            The 14th day of May of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.May.The15th">
            <summary>
            The 15th day of May of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.May.The16th">
            <summary>
            The 16th day of May of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.May.The17th">
            <summary>
            The 17th day of May of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.May.The18th">
            <summary>
            The 18th day of May of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.May.The19th">
            <summary>
            The 19th day of May of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.May.The20th">
            <summary>
            The 20th day of May of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.May.The21st">
            <summary>
            The 21st day of May of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.May.The22nd">
            <summary>
            The 22nd day of May of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.May.The23rd">
            <summary>
            The 23rd day of May of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.May.The24th">
            <summary>
            The 24th day of May of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.May.The25th">
            <summary>
            The 25th day of May of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.May.The26th">
            <summary>
            The 26th day of May of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.May.The27th">
            <summary>
            The 27th day of May of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.May.The28th">
            <summary>
            The 28th day of May of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.May.The29th">
            <summary>
            The 29th day of May of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.May.The30th">
            <summary>
            The 30th day of May of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.May.The31st">
            <summary>
            The 31st day of May of the current year
            </summary>
        </member>
        <member name="T:Humanizer.On.June">
            <summary>
            Provides fluent date accessors for June
            </summary>
        </member>
        <member name="M:Humanizer.On.June.The(System.Int32)">
            <summary>
            The nth day of June of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.June.The1st">
            <summary>
            The 1st day of June of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.June.The2nd">
            <summary>
            The 2nd day of June of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.June.The3rd">
            <summary>
            The 3rd day of June of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.June.The4th">
            <summary>
            The 4th day of June of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.June.The5th">
            <summary>
            The 5th day of June of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.June.The6th">
            <summary>
            The 6th day of June of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.June.The7th">
            <summary>
            The 7th day of June of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.June.The8th">
            <summary>
            The 8th day of June of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.June.The9th">
            <summary>
            The 9th day of June of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.June.The10th">
            <summary>
            The 10th day of June of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.June.The11th">
            <summary>
            The 11th day of June of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.June.The12th">
            <summary>
            The 12th day of June of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.June.The13th">
            <summary>
            The 13th day of June of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.June.The14th">
            <summary>
            The 14th day of June of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.June.The15th">
            <summary>
            The 15th day of June of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.June.The16th">
            <summary>
            The 16th day of June of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.June.The17th">
            <summary>
            The 17th day of June of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.June.The18th">
            <summary>
            The 18th day of June of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.June.The19th">
            <summary>
            The 19th day of June of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.June.The20th">
            <summary>
            The 20th day of June of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.June.The21st">
            <summary>
            The 21st day of June of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.June.The22nd">
            <summary>
            The 22nd day of June of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.June.The23rd">
            <summary>
            The 23rd day of June of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.June.The24th">
            <summary>
            The 24th day of June of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.June.The25th">
            <summary>
            The 25th day of June of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.June.The26th">
            <summary>
            The 26th day of June of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.June.The27th">
            <summary>
            The 27th day of June of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.June.The28th">
            <summary>
            The 28th day of June of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.June.The29th">
            <summary>
            The 29th day of June of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.June.The30th">
            <summary>
            The 30th day of June of the current year
            </summary>
        </member>
        <member name="T:Humanizer.On.July">
            <summary>
            Provides fluent date accessors for July
            </summary>
        </member>
        <member name="M:Humanizer.On.July.The(System.Int32)">
            <summary>
            The nth day of July of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.July.The1st">
            <summary>
            The 1st day of July of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.July.The2nd">
            <summary>
            The 2nd day of July of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.July.The3rd">
            <summary>
            The 3rd day of July of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.July.The4th">
            <summary>
            The 4th day of July of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.July.The5th">
            <summary>
            The 5th day of July of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.July.The6th">
            <summary>
            The 6th day of July of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.July.The7th">
            <summary>
            The 7th day of July of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.July.The8th">
            <summary>
            The 8th day of July of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.July.The9th">
            <summary>
            The 9th day of July of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.July.The10th">
            <summary>
            The 10th day of July of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.July.The11th">
            <summary>
            The 11th day of July of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.July.The12th">
            <summary>
            The 12th day of July of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.July.The13th">
            <summary>
            The 13th day of July of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.July.The14th">
            <summary>
            The 14th day of July of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.July.The15th">
            <summary>
            The 15th day of July of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.July.The16th">
            <summary>
            The 16th day of July of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.July.The17th">
            <summary>
            The 17th day of July of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.July.The18th">
            <summary>
            The 18th day of July of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.July.The19th">
            <summary>
            The 19th day of July of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.July.The20th">
            <summary>
            The 20th day of July of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.July.The21st">
            <summary>
            The 21st day of July of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.July.The22nd">
            <summary>
            The 22nd day of July of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.July.The23rd">
            <summary>
            The 23rd day of July of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.July.The24th">
            <summary>
            The 24th day of July of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.July.The25th">
            <summary>
            The 25th day of July of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.July.The26th">
            <summary>
            The 26th day of July of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.July.The27th">
            <summary>
            The 27th day of July of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.July.The28th">
            <summary>
            The 28th day of July of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.July.The29th">
            <summary>
            The 29th day of July of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.July.The30th">
            <summary>
            The 30th day of July of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.July.The31st">
            <summary>
            The 31st day of July of the current year
            </summary>
        </member>
        <member name="T:Humanizer.On.August">
            <summary>
            Provides fluent date accessors for August
            </summary>
        </member>
        <member name="M:Humanizer.On.August.The(System.Int32)">
            <summary>
            The nth day of August of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.August.The1st">
            <summary>
            The 1st day of August of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.August.The2nd">
            <summary>
            The 2nd day of August of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.August.The3rd">
            <summary>
            The 3rd day of August of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.August.The4th">
            <summary>
            The 4th day of August of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.August.The5th">
            <summary>
            The 5th day of August of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.August.The6th">
            <summary>
            The 6th day of August of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.August.The7th">
            <summary>
            The 7th day of August of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.August.The8th">
            <summary>
            The 8th day of August of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.August.The9th">
            <summary>
            The 9th day of August of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.August.The10th">
            <summary>
            The 10th day of August of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.August.The11th">
            <summary>
            The 11th day of August of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.August.The12th">
            <summary>
            The 12th day of August of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.August.The13th">
            <summary>
            The 13th day of August of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.August.The14th">
            <summary>
            The 14th day of August of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.August.The15th">
            <summary>
            The 15th day of August of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.August.The16th">
            <summary>
            The 16th day of August of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.August.The17th">
            <summary>
            The 17th day of August of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.August.The18th">
            <summary>
            The 18th day of August of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.August.The19th">
            <summary>
            The 19th day of August of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.August.The20th">
            <summary>
            The 20th day of August of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.August.The21st">
            <summary>
            The 21st day of August of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.August.The22nd">
            <summary>
            The 22nd day of August of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.August.The23rd">
            <summary>
            The 23rd day of August of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.August.The24th">
            <summary>
            The 24th day of August of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.August.The25th">
            <summary>
            The 25th day of August of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.August.The26th">
            <summary>
            The 26th day of August of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.August.The27th">
            <summary>
            The 27th day of August of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.August.The28th">
            <summary>
            The 28th day of August of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.August.The29th">
            <summary>
            The 29th day of August of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.August.The30th">
            <summary>
            The 30th day of August of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.August.The31st">
            <summary>
            The 31st day of August of the current year
            </summary>
        </member>
        <member name="T:Humanizer.On.September">
            <summary>
            Provides fluent date accessors for September
            </summary>
        </member>
        <member name="M:Humanizer.On.September.The(System.Int32)">
            <summary>
            The nth day of September of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.September.The1st">
            <summary>
            The 1st day of September of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.September.The2nd">
            <summary>
            The 2nd day of September of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.September.The3rd">
            <summary>
            The 3rd day of September of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.September.The4th">
            <summary>
            The 4th day of September of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.September.The5th">
            <summary>
            The 5th day of September of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.September.The6th">
            <summary>
            The 6th day of September of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.September.The7th">
            <summary>
            The 7th day of September of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.September.The8th">
            <summary>
            The 8th day of September of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.September.The9th">
            <summary>
            The 9th day of September of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.September.The10th">
            <summary>
            The 10th day of September of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.September.The11th">
            <summary>
            The 11th day of September of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.September.The12th">
            <summary>
            The 12th day of September of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.September.The13th">
            <summary>
            The 13th day of September of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.September.The14th">
            <summary>
            The 14th day of September of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.September.The15th">
            <summary>
            The 15th day of September of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.September.The16th">
            <summary>
            The 16th day of September of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.September.The17th">
            <summary>
            The 17th day of September of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.September.The18th">
            <summary>
            The 18th day of September of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.September.The19th">
            <summary>
            The 19th day of September of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.September.The20th">
            <summary>
            The 20th day of September of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.September.The21st">
            <summary>
            The 21st day of September of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.September.The22nd">
            <summary>
            The 22nd day of September of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.September.The23rd">
            <summary>
            The 23rd day of September of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.September.The24th">
            <summary>
            The 24th day of September of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.September.The25th">
            <summary>
            The 25th day of September of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.September.The26th">
            <summary>
            The 26th day of September of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.September.The27th">
            <summary>
            The 27th day of September of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.September.The28th">
            <summary>
            The 28th day of September of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.September.The29th">
            <summary>
            The 29th day of September of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.September.The30th">
            <summary>
            The 30th day of September of the current year
            </summary>
        </member>
        <member name="T:Humanizer.On.October">
            <summary>
            Provides fluent date accessors for October
            </summary>
        </member>
        <member name="M:Humanizer.On.October.The(System.Int32)">
            <summary>
            The nth day of October of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.October.The1st">
            <summary>
            The 1st day of October of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.October.The2nd">
            <summary>
            The 2nd day of October of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.October.The3rd">
            <summary>
            The 3rd day of October of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.October.The4th">
            <summary>
            The 4th day of October of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.October.The5th">
            <summary>
            The 5th day of October of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.October.The6th">
            <summary>
            The 6th day of October of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.October.The7th">
            <summary>
            The 7th day of October of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.October.The8th">
            <summary>
            The 8th day of October of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.October.The9th">
            <summary>
            The 9th day of October of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.October.The10th">
            <summary>
            The 10th day of October of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.October.The11th">
            <summary>
            The 11th day of October of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.October.The12th">
            <summary>
            The 12th day of October of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.October.The13th">
            <summary>
            The 13th day of October of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.October.The14th">
            <summary>
            The 14th day of October of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.October.The15th">
            <summary>
            The 15th day of October of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.October.The16th">
            <summary>
            The 16th day of October of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.October.The17th">
            <summary>
            The 17th day of October of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.October.The18th">
            <summary>
            The 18th day of October of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.October.The19th">
            <summary>
            The 19th day of October of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.October.The20th">
            <summary>
            The 20th day of October of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.October.The21st">
            <summary>
            The 21st day of October of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.October.The22nd">
            <summary>
            The 22nd day of October of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.October.The23rd">
            <summary>
            The 23rd day of October of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.October.The24th">
            <summary>
            The 24th day of October of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.October.The25th">
            <summary>
            The 25th day of October of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.October.The26th">
            <summary>
            The 26th day of October of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.October.The27th">
            <summary>
            The 27th day of October of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.October.The28th">
            <summary>
            The 28th day of October of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.October.The29th">
            <summary>
            The 29th day of October of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.October.The30th">
            <summary>
            The 30th day of October of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.October.The31st">
            <summary>
            The 31st day of October of the current year
            </summary>
        </member>
        <member name="T:Humanizer.On.November">
            <summary>
            Provides fluent date accessors for November
            </summary>
        </member>
        <member name="M:Humanizer.On.November.The(System.Int32)">
            <summary>
            The nth day of November of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.November.The1st">
            <summary>
            The 1st day of November of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.November.The2nd">
            <summary>
            The 2nd day of November of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.November.The3rd">
            <summary>
            The 3rd day of November of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.November.The4th">
            <summary>
            The 4th day of November of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.November.The5th">
            <summary>
            The 5th day of November of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.November.The6th">
            <summary>
            The 6th day of November of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.November.The7th">
            <summary>
            The 7th day of November of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.November.The8th">
            <summary>
            The 8th day of November of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.November.The9th">
            <summary>
            The 9th day of November of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.November.The10th">
            <summary>
            The 10th day of November of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.November.The11th">
            <summary>
            The 11th day of November of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.November.The12th">
            <summary>
            The 12th day of November of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.November.The13th">
            <summary>
            The 13th day of November of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.November.The14th">
            <summary>
            The 14th day of November of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.November.The15th">
            <summary>
            The 15th day of November of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.November.The16th">
            <summary>
            The 16th day of November of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.November.The17th">
            <summary>
            The 17th day of November of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.November.The18th">
            <summary>
            The 18th day of November of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.November.The19th">
            <summary>
            The 19th day of November of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.November.The20th">
            <summary>
            The 20th day of November of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.November.The21st">
            <summary>
            The 21st day of November of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.November.The22nd">
            <summary>
            The 22nd day of November of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.November.The23rd">
            <summary>
            The 23rd day of November of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.November.The24th">
            <summary>
            The 24th day of November of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.November.The25th">
            <summary>
            The 25th day of November of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.November.The26th">
            <summary>
            The 26th day of November of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.November.The27th">
            <summary>
            The 27th day of November of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.November.The28th">
            <summary>
            The 28th day of November of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.November.The29th">
            <summary>
            The 29th day of November of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.November.The30th">
            <summary>
            The 30th day of November of the current year
            </summary>
        </member>
        <member name="T:Humanizer.On.December">
            <summary>
            Provides fluent date accessors for December
            </summary>
        </member>
        <member name="M:Humanizer.On.December.The(System.Int32)">
            <summary>
            The nth day of December of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.December.The1st">
            <summary>
            The 1st day of December of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.December.The2nd">
            <summary>
            The 2nd day of December of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.December.The3rd">
            <summary>
            The 3rd day of December of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.December.The4th">
            <summary>
            The 4th day of December of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.December.The5th">
            <summary>
            The 5th day of December of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.December.The6th">
            <summary>
            The 6th day of December of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.December.The7th">
            <summary>
            The 7th day of December of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.December.The8th">
            <summary>
            The 8th day of December of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.December.The9th">
            <summary>
            The 9th day of December of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.December.The10th">
            <summary>
            The 10th day of December of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.December.The11th">
            <summary>
            The 11th day of December of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.December.The12th">
            <summary>
            The 12th day of December of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.December.The13th">
            <summary>
            The 13th day of December of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.December.The14th">
            <summary>
            The 14th day of December of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.December.The15th">
            <summary>
            The 15th day of December of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.December.The16th">
            <summary>
            The 16th day of December of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.December.The17th">
            <summary>
            The 17th day of December of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.December.The18th">
            <summary>
            The 18th day of December of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.December.The19th">
            <summary>
            The 19th day of December of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.December.The20th">
            <summary>
            The 20th day of December of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.December.The21st">
            <summary>
            The 21st day of December of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.December.The22nd">
            <summary>
            The 22nd day of December of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.December.The23rd">
            <summary>
            The 23rd day of December of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.December.The24th">
            <summary>
            The 24th day of December of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.December.The25th">
            <summary>
            The 25th day of December of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.December.The26th">
            <summary>
            The 26th day of December of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.December.The27th">
            <summary>
            The 27th day of December of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.December.The28th">
            <summary>
            The 28th day of December of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.December.The29th">
            <summary>
            The 29th day of December of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.December.The30th">
            <summary>
            The 30th day of December of the current year
            </summary>
        </member>
        <member name="P:Humanizer.On.December.The31st">
            <summary>
            The 31st day of December of the current year
            </summary>
        </member>
        <member name="T:Humanizer.PrepositionsExtensions">
            <summary>
            <see cref="T:System.DateTime"/> extensions related to spatial or temporal relations
            </summary>
        </member>
        <member name="M:Humanizer.PrepositionsExtensions.At(System.DateTime,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns a new <see cref="T:System.DateTime"/> with the specified hour and, optionally
            provided minutes, seconds, and milliseconds.
            </summary>
        </member>
        <member name="M:Humanizer.PrepositionsExtensions.AtMidnight(System.DateTime)">
            <summary>
            Returns a new instance of DateTime based on the provided date where the time is set to midnight
            </summary>
        </member>
        <member name="M:Humanizer.PrepositionsExtensions.AtNoon(System.DateTime)">
            <summary>
            Returns a new instance of DateTime based on the provided date where the time is set to noon
            </summary>
        </member>
        <member name="M:Humanizer.PrepositionsExtensions.In(System.DateTime,System.Int32)">
            <summary>
            Returns a new instance of DateTime based on the provided date where the year is set to the provided year
            </summary>
        </member>
        <member name="T:Humanizer.GrammaticalCase">
            <summary>
            Options for specifying the desired grammatical case for the output words
            </summary>
        </member>
        <member name="F:Humanizer.GrammaticalCase.Nominative">
            <summary>
            Indicates the subject of a finite verb
            </summary>
        </member>
        <member name="F:Humanizer.GrammaticalCase.Genitive">
            <summary>
            Indicates the possessor of another noun
            </summary>
        </member>
        <member name="F:Humanizer.GrammaticalCase.Dative">
            <summary>
            Indicates the indirect object of a verb
            </summary>
        </member>
        <member name="F:Humanizer.GrammaticalCase.Accusative">
            <summary>
            Indicates the direct object of a verb
            </summary>
        </member>
        <member name="F:Humanizer.GrammaticalCase.Instrumental">
            <summary>
            Indicates an object used in performing an action
            </summary>
        </member>
        <member name="F:Humanizer.GrammaticalCase.Prepositional">
            <summary>
            Indicates the object of a preposition
            </summary>
        </member>
        <member name="T:Humanizer.GrammaticalGender">
            <summary>
            Options for specifying the desired grammatical gender for the output words
            </summary>
        </member>
        <member name="F:Humanizer.GrammaticalGender.Masculine">
            <summary>
            Indicates masculine grammatical gender
            </summary>
        </member>
        <member name="F:Humanizer.GrammaticalGender.Feminine">
            <summary>
            Indicates feminine grammatical gender
            </summary>
        </member>
        <member name="F:Humanizer.GrammaticalGender.Neuter">
            <summary>
            Indicates neuter grammatical gender
            </summary>
        </member>
        <member name="T:Humanizer.HeadingStyle">
            <summary>
            Style for the cardinal direction humanization
            </summary>
        </member>
        <member name="F:Humanizer.HeadingStyle.Abbreviated">
            <summary>
            Returns an abbreviated format
            </summary>
        </member>
        <member name="F:Humanizer.HeadingStyle.Full">
            <summary>
            Returns the full format
            </summary>
        </member>
        <member name="T:Humanizer.HeadingExtensions">
            <summary>
            Contains extensions to transform a number indicating a heading into the
            textual representation of the heading.
            </summary>
        </member>
        <member name="M:Humanizer.HeadingExtensions.ToHeading(System.Double,Humanizer.HeadingStyle,System.Globalization.CultureInfo)">
             <summary>
             Returns a textual representation of the heading.
            
             This representation has a maximum deviation of 11.25 degrees.
             </summary>
             <returns>A textual representation of the heading</returns>
             <param name="heading">The heading value</param>
             <param name="style">Whether to return a short result or not. <see cref="T:Humanizer.HeadingStyle"/></param>
             <param name="culture">The culture to return the textual representation in</param>
        </member>
        <member name="M:Humanizer.HeadingExtensions.ToHeadingArrow(System.Double)">
             <summary>
             Returns a char arrow indicating the heading.
            
             This representation has a maximum deviation of 22.5 degrees.
             </summary>
             <returns>The heading arrow.</returns>
        </member>
        <member name="M:Humanizer.HeadingExtensions.FromAbbreviatedHeading(System.String)">
            <summary>
            Returns a heading based on the short textual representation of the heading.
            </summary>
            <param name="heading">The short textual representation of a heading</param>
            <returns>The heading. -1 if the heading could not be parsed.</returns>
        </member>
        <member name="M:Humanizer.HeadingExtensions.FromAbbreviatedHeading(System.String,System.Globalization.CultureInfo)">
            <summary>
            Returns a heading based on the short textual representation of the heading.
            </summary>
            <param name="heading">The short textual representation of a heading</param>
            <param name="culture">The culture of the heading</param>
            <returns>The heading. -1 if the heading could not be parsed.</returns>
        </member>
        <member name="M:Humanizer.HeadingExtensions.FromHeadingArrow(System.Char)">
            <summary>
            Returns a heading based on the heading arrow.
            </summary>
        </member>
        <member name="M:Humanizer.HeadingExtensions.FromHeadingArrow(System.String)">
            <summary>
            Returns a heading based on the heading arrow.
            </summary>
        </member>
        <member name="T:Humanizer.Vocabularies">
            <summary>
            Container for registered Vocabularies.  At present, only a single vocabulary is supported: Default.
            </summary>
        </member>
        <member name="P:Humanizer.Vocabularies.Default">
            <summary>
            The default vocabulary used for singular/plural irregularities.
            Rules can be added to this vocabulary and will be picked up by called to Singularize() and Pluralize().
            At this time, multiple vocabularies and removing existing rules are not supported.
            </summary>
        </member>
        <member name="T:Humanizer.Vocabulary">
            <summary>
            A container for exceptions to simple pluralization/singularization rules.
            Vocabularies.Default contains an extensive list of rules for US English.
            At this time, multiple vocabularies and removing existing rules are not supported.
            </summary>
        </member>
        <member name="M:Humanizer.Vocabulary.AddIrregular(System.String,System.String,System.Boolean)">
            <summary>
            Adds a word to the vocabulary which cannot easily be pluralized/singularized by RegEx, e.g. "person" and "people".
            </summary>
            <param name="singular">The singular form of the irregular word, e.g. "person".</param>
            <param name="plural">The plural form of the irregular word, e.g. "people".</param>
            <param name="matchEnding">True to match these words on their own as well as at the end of longer words. False, otherwise.</param>
        </member>
        <member name="M:Humanizer.Vocabulary.AddUncountable(System.String)">
            <summary>
            Adds an uncountable word to the vocabulary, e.g. "fish".  Will be ignored when plurality is changed.
            </summary>
            <param name="word">Word to be added to the list of uncountables.</param>
        </member>
        <member name="M:Humanizer.Vocabulary.AddPlural(System.String,System.String)">
            <summary>
            Adds a rule to the vocabulary that does not follow trivial rules for pluralization, e.g. "bus" -> "buses"
            </summary>
            <param name="rule">RegEx to be matched, case insensitive, e.g. "(bus)es$"</param>
            <param name="replacement">RegEx replacement  e.g. "$1"</param>
        </member>
        <member name="M:Humanizer.Vocabulary.AddSingular(System.String,System.String)">
            <summary>
            Adds a rule to the vocabulary that does not follow trivial rules for singularization, e.g. "vertices/indices -> "vertex/index"
            </summary>
            <param name="rule">RegEx to be matched, case insensitive, e.g. ""(vert|ind)ices$""</param>
            <param name="replacement">RegEx replacement  e.g. "$1ex"</param>
        </member>
        <member name="M:Humanizer.Vocabulary.Pluralize(System.String,System.Boolean)">
            <summary>
            Pluralizes the provided input considering irregular words
            </summary>
            <param name="word">Word to be pluralized</param>
            <param name="inputIsKnownToBeSingular">Normally you call Pluralize on singular words; but if you're unsure call it with false</param>
        </member>
        <member name="M:Humanizer.Vocabulary.Singularize(System.String,System.Boolean,System.Boolean)">
            <summary>
            Singularizes the provided input considering irregular words
            </summary>
            <param name="word">Word to be singularized</param>
            <param name="inputIsKnownToBePlural">Normally you call Singularize on plural words; but if you're unsure call it with false</param>
            <param name="skipSimpleWords">Skip singularizing single words that have an 's' on the end</param>
        </member>
        <member name="M:Humanizer.Vocabulary.LetterS(System.String)">
            <summary>
            If the word is the letter s, singular or plural, return the letter s singular
            </summary>
        </member>
        <member name="M:Humanizer.InflectorExtensions.Pluralize(System.String,System.Boolean)">
            <summary>
            Pluralizes the provided input considering irregular words
            </summary>
            <param name="word">Word to be pluralized</param>
            <param name="inputIsKnownToBeSingular">Normally you call Pluralize on singular words; but if you're unsure call it with false</param>
        </member>
        <member name="M:Humanizer.InflectorExtensions.Singularize(System.String,System.Boolean,System.Boolean)">
            <summary>
            Singularizes the provided input considering irregular words
            </summary>
            <param name="word">Word to be singularized</param>
            <param name="inputIsKnownToBePlural">Normally you call Singularize on plural words; but if you're unsure call it with false</param>
            <param name="skipSimpleWords">Skip singularizing single words that have an 's' on the end</param>
        </member>
        <member name="M:Humanizer.InflectorExtensions.Titleize(System.String)">
            <summary>
            Humanizes the input with Title casing
            </summary>
            <param name="input">The string to be titleized</param>
        </member>
        <member name="M:Humanizer.InflectorExtensions.Pascalize(System.String)">
            <summary>
            By default, pascalize converts strings to UpperCamelCase also removing underscores
            </summary>
        </member>
        <member name="M:Humanizer.InflectorExtensions.Camelize(System.String)">
            <summary>
            Same as Pascalize except that the first character is lower case
            </summary>
        </member>
        <member name="M:Humanizer.InflectorExtensions.Underscore(System.String)">
            <summary>
            Separates the input words with underscore
            </summary>
            <param name="input">The string to be underscored</param>
        </member>
        <member name="M:Humanizer.InflectorExtensions.Dasherize(System.String)">
            <summary>
            Replaces underscores with dashes in the string
            </summary>
        </member>
        <member name="M:Humanizer.InflectorExtensions.Hyphenate(System.String)">
            <summary>
            Replaces underscores with hyphens in the string
            </summary>
        </member>
        <member name="M:Humanizer.InflectorExtensions.Kebaberize(System.String)">
            <summary>
            Separates the input words with hyphens and all the words are converted to lowercase
            </summary>
        </member>
        <member name="T:Humanizer.LetterCasing">
            <summary>
            Options for specifying the desired letter casing for the output string
            </summary>
        </member>
        <member name="F:Humanizer.LetterCasing.Title">
            <summary>
            SomeString -> Some String
            </summary>
        </member>
        <member name="F:Humanizer.LetterCasing.AllCaps">
            <summary>
            SomeString -> SOME STRING
            </summary>
        </member>
        <member name="F:Humanizer.LetterCasing.LowerCase">
            <summary>
            SomeString -> some string
            </summary>
        </member>
        <member name="F:Humanizer.LetterCasing.Sentence">
            <summary>
            SomeString -> Some string
            </summary>
        </member>
        <member name="T:Humanizer.ICollectionFormatter">
            <summary>
            An interface you should implement to localize Humanize for collections
            </summary>
        </member>
        <member name="M:Humanizer.ICollectionFormatter.Humanize``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Formats the collection for display, calling ToString() on each object.
            </summary>
        </member>
        <member name="M:Humanizer.ICollectionFormatter.Humanize``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.String})">
            <summary>
            Formats the collection for display, calling <paramref name="objectFormatter"/> on each element.
            </summary>
        </member>
        <member name="M:Humanizer.ICollectionFormatter.Humanize``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Object})">
            <summary>
            Formats the collection for display, calling <paramref name="objectFormatter"/> on each element.
            </summary>
        </member>
        <member name="M:Humanizer.ICollectionFormatter.Humanize``1(System.Collections.Generic.IEnumerable{``0},System.String)">
            <summary>
            Formats the collection for display, calling ToString() on each object
            and using <paramref name="separator"/> before the final item.
            </summary>
        </member>
        <member name="M:Humanizer.ICollectionFormatter.Humanize``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.String},System.String)">
            <summary>
            Formats the collection for display, calling <paramref name="objectFormatter"/> on each element.
            and using <paramref name="separator"/> before the final item.
            </summary>
        </member>
        <member name="M:Humanizer.ICollectionFormatter.Humanize``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Object},System.String)">
            <summary>
            Formats the collection for display, calling <paramref name="objectFormatter"/> on each element.
            and using <paramref name="separator"/> before the final item.
            </summary>
        </member>
        <member name="T:Humanizer.IDateToOrdinalWordConverter">
            <summary>
            The interface used to localise the ToOrdinalWords method.
            </summary>
        </member>
        <member name="M:Humanizer.IDateToOrdinalWordConverter.Convert(System.DateTime)">
            <summary>
            Converts the date to Ordinal Words
            </summary>
        </member>
        <member name="M:Humanizer.IDateToOrdinalWordConverter.Convert(System.DateTime,Humanizer.GrammaticalCase)">
            <summary>
            Converts the date to Ordinal Words using the provided grammatical case
            </summary>
        </member>
        <member name="T:Humanizer.DefaultFormatter">
            <summary>
            Default implementation of IFormatter interface.
            </summary>
        </member>
        <member name="M:Humanizer.DefaultFormatter.#ctor(System.Globalization.CultureInfo)">
            <summary>
            Default implementation of IFormatter interface.
            </summary>
        </member>
        <member name="M:Humanizer.DefaultFormatter.DateHumanize(Humanizer.TimeUnit,Humanizer.Tense,System.Int32)">
            <summary>
            Returns the string representation of the provided DateTime
            </summary>
        </member>
        <member name="M:Humanizer.DefaultFormatter.TimeSpanHumanize_Zero">
            <summary>
            0 seconds
            </summary>
            <returns>Returns 0 seconds as the string representation of Zero TimeSpan</returns>
        </member>
        <member name="M:Humanizer.DefaultFormatter.TimeSpanHumanize(Humanizer.TimeUnit,System.Int32,System.Boolean)">
            <summary>
            Returns the string representation of the provided TimeSpan
            </summary>
            <param name="timeUnit">A time unit to represent.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Is thrown when timeUnit is larger than TimeUnit.Week</exception>
        </member>
        <member name="M:Humanizer.DefaultFormatter.TimeSpanHumanize_Age">
            <inheritdoc/>
        </member>
        <member name="M:Humanizer.DefaultFormatter.DataUnitHumanize(Humanizer.DataUnit,System.Double,System.Boolean)">
            <inheritdoc cref="M:Humanizer.IFormatter.DataUnitHumanize(Humanizer.DataUnit,System.Double,System.Boolean)"/>
        </member>
        <member name="M:Humanizer.DefaultFormatter.TimeUnitHumanize(Humanizer.TimeUnit)">
            <inheritdoc />
        </member>
        <member name="M:Humanizer.DefaultFormatter.Format(System.String)">
            <summary>
            Formats the specified resource key.
            </summary>
            <param name="resourceKey">The resource key.</param>
            <exception cref="T:System.ArgumentException">If the resource not exists on the specified culture.</exception>
        </member>
        <member name="M:Humanizer.DefaultFormatter.Format(Humanizer.TimeUnit,System.String,System.Int32,System.Boolean)">
            <summary>
            Formats the specified resource key.
            </summary>
            <param name="unit"></param>
            <param name="resourceKey">The resource key.</param>
            <param name="number">The number.</param>
            <param name="toWords"></param>
            <exception cref="T:System.ArgumentException">If the resource not exists on the specified culture.</exception>
        </member>
        <member name="M:Humanizer.DefaultFormatter.GetResourceKey(System.String,System.Int32)">
            <summary>
            Override this method if your locale has complex rules around multiple units; e.g. Arabic, Russian
            </summary>
            <param name="resourceKey">The resource key that's being in formatting</param>
            <param name="number">The number of the units being used in formatting</param>
        </member>
        <member name="M:Humanizer.GermanFormatter.DataUnitHumanize(Humanizer.DataUnit,System.Double,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="T:Humanizer.IFormatter">
            <summary>
            Implement this interface if your language has complex rules around dealing with numbers.
            For example in Romanian "5 days" is "5 zile", while "24 days" is "24 de zile" and
            in Arabic 2 days is  not 2 
            </summary>
        </member>
        <member name="M:Humanizer.IFormatter.DateHumanize(Humanizer.TimeUnit,Humanizer.Tense,System.Int32)">
            <summary>
            Returns the string representation of the provided DateTime
            </summary>
        </member>
        <member name="M:Humanizer.IFormatter.TimeSpanHumanize_Zero">
            <summary>
            0 seconds
            </summary>
            <returns>Returns 0 seconds as the string representation of Zero TimeSpan</returns>
        </member>
        <member name="M:Humanizer.IFormatter.TimeSpanHumanize(Humanizer.TimeUnit,System.Int32,System.Boolean)">
            <summary>
            Returns the string representation of the provided TimeSpan
            </summary>
        </member>
        <member name="M:Humanizer.IFormatter.TimeSpanHumanize_Age">
            <summary>
            Returns the age format that converts a humanized TimeSpan string to an age expression.
            For instance, in English that format adds the " old" suffix, so that "40 years" becomes "40 years old".
            </summary>
            <returns>Age format</returns>
        </member>
        <member name="M:Humanizer.IFormatter.DataUnitHumanize(Humanizer.DataUnit,System.Double,System.Boolean)">
            <summary>
            Returns the string representation of the provided DataUnit, either as a symbol or full word
            </summary>
            <param name="dataUnit">Data unit</param>
            <param name="count">Number of said units, to adjust for singular/plural forms</param>
            <param name="toSymbol">Indicates whether the data unit should be expressed as symbol or full word</param>
            <returns>String representation of the provided DataUnit</returns>
        </member>
        <member name="M:Humanizer.IFormatter.TimeUnitHumanize(Humanizer.TimeUnit)">
            <summary>
            Returns the symbol for the given TimeUnit
            </summary>
            <param name="timeUnit">Time unit</param>
            <returns>String representation of the provided TimeUnit</returns>
        </member>
        <member name="M:Humanizer.DefaultNumberToWordsConverter.#ctor(System.Globalization.CultureInfo)">
            <summary>
            Constructor.
            </summary>
            <param name="culture">Culture to use.</param>
        </member>
        <member name="M:Humanizer.DefaultNumberToWordsConverter.Convert(System.Int64)">
            <summary>
            3501.ToWords() -> "three thousand five hundred and one"
            </summary>
            <param name="number">Number to be turned to words</param>
        </member>
        <member name="M:Humanizer.DefaultNumberToWordsConverter.ConvertToOrdinal(System.Int32)">
            <summary>
            1.ToOrdinalWords() -> "first"
            </summary>
            <param name="number">Number to be turned to ordinal words</param>
        </member>
        <member name="T:Humanizer.DutchNumberToWordsConverter">
            <summary>
            Dutch spelling of numbers is not really officially regulated.
            There are a few different rules that can be applied.
            Used the rules as stated here.
            http://www.beterspellen.nl/website/?pag=110
            </summary>
        </member>
        <member name="M:Humanizer.GenderedNumberToWordsConverter.Convert(System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:Humanizer.GenderedNumberToWordsConverter.Convert(System.Int64,Humanizer.WordForm)">
            <inheritdoc/>
        </member>
        <member name="M:Humanizer.GenderedNumberToWordsConverter.Convert(System.Int64,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:Humanizer.GenderedNumberToWordsConverter.Convert(System.Int64,System.Boolean,Humanizer.WordForm)">
            <inheritdoc/>
        </member>
        <member name="M:Humanizer.GenderedNumberToWordsConverter.Convert(System.Int64,Humanizer.GrammaticalGender,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:Humanizer.GenderedNumberToWordsConverter.Convert(System.Int64,Humanizer.WordForm,Humanizer.GrammaticalGender,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:Humanizer.GenderedNumberToWordsConverter.ConvertToOrdinal(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Humanizer.GenderedNumberToWordsConverter.ConvertToOrdinal(System.Int32,Humanizer.GrammaticalGender)">
            <inheritdoc/>
        </member>
        <member name="M:Humanizer.GenderedNumberToWordsConverter.ConvertToOrdinal(System.Int32,Humanizer.WordForm)">
            <inheritdoc/>
        </member>
        <member name="M:Humanizer.GenderedNumberToWordsConverter.ConvertToOrdinal(System.Int32,Humanizer.GrammaticalGender,Humanizer.WordForm)">
            <inheritdoc/>
        </member>
        <member name="M:Humanizer.GenderedNumberToWordsConverter.ConvertToTuple(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Humanizer.GenderlessNumberToWordsConverter.Convert(System.Int64)">
            <inheritdoc/>
        </member>
        <member name="T:Humanizer.INumberToWordsConverter">
            <summary>
            An interface you should implement to localise ToWords and ToOrdinalWords methods
            </summary>
        </member>
        <member name="M:Humanizer.INumberToWordsConverter.Convert(System.Int64)">
            <summary>
            Converts the number to string using the locale's default grammatical gender
            </summary>
        </member>
        <member name="M:Humanizer.INumberToWordsConverter.Convert(System.Int64,Humanizer.WordForm)">
            <summary>
            Converts the number to a specific string form using the locale's default grammatical gender.
            </summary>
        </member>
        <member name="M:Humanizer.INumberToWordsConverter.Convert(System.Int64,System.Boolean)">
            <summary>
            Converts the number to string using the locale's default grammatical gender with or without adding 'And'
            </summary>
            <param name="addAnd">Specify with our without adding "And"</param>
        </member>
        <member name="M:Humanizer.INumberToWordsConverter.Convert(System.Int64,System.Boolean,Humanizer.WordForm)">
            <summary>
            Converts the number to a specific string form using the locale's default grammatical gender with or without adding 'And'
            </summary>
        </member>
        <member name="M:Humanizer.INumberToWordsConverter.Convert(System.Int64,Humanizer.GrammaticalGender,System.Boolean)">
            <summary>
            Converts the number to string using the provided grammatical gender
            </summary>
        </member>
        <member name="M:Humanizer.INumberToWordsConverter.Convert(System.Int64,Humanizer.WordForm,Humanizer.GrammaticalGender,System.Boolean)">
            <summary>
            Converts the number to a specific string form using the provided grammatical gender.
            </summary>
        </member>
        <member name="M:Humanizer.INumberToWordsConverter.ConvertToOrdinal(System.Int32)">
            <summary>
            Converts the number to ordinal string using the locale's default grammatical gender
            </summary>
        </member>
        <member name="M:Humanizer.INumberToWordsConverter.ConvertToOrdinal(System.Int32,Humanizer.WordForm)">
            <summary>
            Converts the number to a specific ordinal string form using the locale's default grammatical gender.
            </summary>
        </member>
        <member name="M:Humanizer.INumberToWordsConverter.ConvertToOrdinal(System.Int32,Humanizer.GrammaticalGender)">
            <summary>
            Converts the number to ordinal string using the provided grammatical gender
            </summary>
        </member>
        <member name="M:Humanizer.INumberToWordsConverter.ConvertToOrdinal(System.Int32,Humanizer.GrammaticalGender,Humanizer.WordForm)">
            <summary>
            Converts the number to a specific ordinal string form using the provided grammatical gender.
            </summary>
        </member>
        <member name="M:Humanizer.INumberToWordsConverter.ConvertToTuple(System.Int32)">
            <summary>
            Converts integer to named tuple (e.g. 'single', 'double' etc.).
            </summary>
        </member>
        <member name="M:Humanizer.ItalianCardinalNumberCruncher.SplitEveryThreeDigits(System.Int32)">
            <summary>
            Splits a number into a sequence of three-digits numbers, starting
            from units, then thousands, millions, and so on.
            </summary>
            <param name="number">The number to split.</param>
            <returns>The sequence of three-digit numbers.</returns>
        </member>
        <member name="M:Humanizer.ItalianCardinalNumberCruncher.GetNextPartConverter">
            <summary>
            During number conversion to text, finds out the converter to use
            for the next three-digit set.
            </summary>
            <returns>The next conversion function to use.</returns>
        </member>
        <member name="M:Humanizer.ItalianCardinalNumberCruncher.ThreeDigitSetConverter(System.Int32,System.Boolean)">
            <summary>
            Converts a three-digit set to text.
            </summary>
            <param name="number">The three-digit set to convert.</param>
            <param name="thisIsLastSet">True if the current three-digit set is the last in the word.</param>
            <returns>The same three-digit set expressed as text.</returns>
        </member>
        <member name="M:Humanizer.ItalianCardinalNumberCruncher.UnitsConverter(System.Int32)">
            <summary>
            Converts a three-digit number, as units, to text.
            </summary>
            <param name="number">The three-digit number, as units, to convert.</param>
            <returns>The same three-digit number, as units, expressed as text.</returns>
        </member>
        <member name="M:Humanizer.ItalianCardinalNumberCruncher.ThousandsConverter(System.Int32)">
            <summary>
            Converts a thousands three-digit number to text.
            </summary>
            <param name="number">The three-digit number, as thousands, to convert.</param>
            <returns>The same three-digit number of thousands expressed as text.</returns>
        </member>
        <member name="M:Humanizer.ItalianCardinalNumberCruncher.MillionsConverter(System.Int32)">
            <summary>
            Converts a millions three-digit number to text.
            </summary>
            <param name="number">The three-digit number, as millions, to convert.</param>
            <returns>The same three-digit number of millions expressed as text.</returns>
        </member>
        <member name="M:Humanizer.ItalianCardinalNumberCruncher.BillionsConverter(System.Int32)">
            <summary>
            Converts a billions three-digit number to text.
            </summary>
            <param name="number">The three-digit number, as billions, to convert.</param>
            <returns>The same three-digit number of billions expressed as text.</returns>
        </member>
        <member name="F:Humanizer.ItalianCardinalNumberCruncher._unitsNumberToText">
            <summary>
            Lookup table converting units number to text. Index 1 for 1, index 2 for 2, up to index 9.
            </summary>
        </member>
        <member name="F:Humanizer.ItalianCardinalNumberCruncher._tensOver20NumberToText">
            <summary>
            Lookup table converting tens number to text. Index 2 for 20, index 3 for 30, up to index 9 for 90.
            </summary>
        </member>
        <member name="F:Humanizer.ItalianCardinalNumberCruncher._teensUnder20NumberToText">
            <summary>
            Lookup table converting teens number to text. Index 0 for 10, index 1 for 11, up to index 9 for 19.
            </summary>
        </member>
        <member name="F:Humanizer.ItalianCardinalNumberCruncher._hundredNumberToText">
            <summary>
            Lookup table converting hundreds number to text. Index 0 for no hundreds, index 1 for 100, up to index 9.
            </summary>
        </member>
        <member name="T:Humanizer.ItalianCardinalNumberCruncher.ThreeDigitSets">
            <summary>
            Enumerates sets of three-digits having distinct conversion to text.
            </summary>
        </member>
        <member name="F:Humanizer.ItalianCardinalNumberCruncher.ThreeDigitSets.Units">
            <summary>
            Lowest three-digits set, from 1 to 999.
            </summary>
        </member>
        <member name="F:Humanizer.ItalianCardinalNumberCruncher.ThreeDigitSets.Thousands">
            <summary>
            Three-digits set counting the thousands, from 1'000 to 999'000.
            </summary>
        </member>
        <member name="F:Humanizer.ItalianCardinalNumberCruncher.ThreeDigitSets.Millions">
            <summary>
            Three-digits set counting millions, from 1'000'000 to 999'000'000.
            </summary>
        </member>
        <member name="F:Humanizer.ItalianCardinalNumberCruncher.ThreeDigitSets.Billions">
            <summary>
            Three-digits set counting billions, from 1'000'000'000 to 999'000'000'000.
            </summary>
        </member>
        <member name="F:Humanizer.ItalianCardinalNumberCruncher.ThreeDigitSets.More">
            <summary>
            Three-digits set beyond 999 billions, from 1'000'000'000'000 onward.
            </summary>
        </member>
        <member name="F:Humanizer.ItalianOrdinalNumberCruncher._unitsUnder10NumberToText">
            <summary>
            Lookup table converting units number to text. Index 1 for 1, index 2 for 2, up to index 9.
            </summary>
        </member>
        <member name="F:Humanizer.RomanianCardinalNumberConverter._units">
            <summary>
            Lookup table converting units number to text. Index 1 for 1, index 2 for 2, up to index 9 for 9.
            </summary>
        </member>
        <member name="F:Humanizer.RomanianCardinalNumberConverter._teensUnder20NumberToText">
            <summary>
            Lookup table converting teens number to text. Index 0 for 10, index 1 for 11, up to index 9 for 19.
            </summary>
        </member>
        <member name="F:Humanizer.RomanianCardinalNumberConverter._tensOver20NumberToText">
            <summary>
            Lookup table converting tens number to text. Index 2 for 20, index 3 for 30, up to index 9 for 90.
            </summary>
        </member>
        <member name="T:Humanizer.RomanianCardinalNumberConverter.ThreeDigitSets">
            <summary>
            Enumerates sets of three-digits having distinct conversion to text.
            </summary>
        </member>
        <member name="F:Humanizer.RomanianCardinalNumberConverter.ThreeDigitSets.Units">
            <summary>
            Lowest three-digits set, from 1 to 999.
            </summary>
        </member>
        <member name="F:Humanizer.RomanianCardinalNumberConverter.ThreeDigitSets.Thousands">
            <summary>
            Three-digits set counting the thousands, from 1'000 to 999'000.
            </summary>
        </member>
        <member name="F:Humanizer.RomanianCardinalNumberConverter.ThreeDigitSets.Millions">
            <summary>
            Three-digits set counting millions, from 1'000'000 to 999'000'000.
            </summary>
        </member>
        <member name="F:Humanizer.RomanianCardinalNumberConverter.ThreeDigitSets.Billions">
            <summary>
            Three-digits set counting billions, from 1'000'000'000 to 999'000'000'000.
            </summary>
        </member>
        <member name="F:Humanizer.RomanianCardinalNumberConverter.ThreeDigitSets.More">
            <summary>
            Three-digits set beyond 999 billions, from 1'000'000'000'000 onward.
            </summary>
        </member>
        <member name="M:Humanizer.RomanianCardinalNumberConverter.SplitEveryThreeDigits(System.Int32)">
            <summary>
            Splits a number into a sequence of three-digits numbers,
            starting from units, then thousands, millions, and so on.
            </summary>
            <param name="number">The number to split.</param>
            <returns>The sequence of three-digit numbers.</returns>
        </member>
        <member name="M:Humanizer.RomanianCardinalNumberConverter.GetNextPartConverter(Humanizer.RomanianCardinalNumberConverter.ThreeDigitSets)">
            <summary>
            During number conversion to text, finds out the converter
            to use for the next three-digit set.
            </summary>
            <returns>The next conversion function to use.</returns>
        </member>
        <member name="M:Humanizer.RomanianCardinalNumberConverter.ThreeDigitSetConverter(System.Int32,Humanizer.GrammaticalGender)">
            <summary>
            Converts a three-digit set to text.
            </summary>
            <param name="number">The three-digit set to convert.</param>
            <param name="gender">The grammatical gender to convert to.</param>
            <returns>The same three-digit set expressed as text.</returns>
        </member>
        <member name="M:Humanizer.RomanianCardinalNumberConverter.UnitsConverter(System.Int32,Humanizer.GrammaticalGender)">
            <summary>
            Converts a three-digit number, as units, to text.
            </summary>
            <param name="number">The three-digit number, as units, to convert.</param>
            <param name="gender">The grammatical gender to convert to.</param>
            <returns>The same three-digit number, as units, expressed as text.</returns>
        </member>
        <member name="M:Humanizer.RomanianCardinalNumberConverter.ThousandsConverter(System.Int32,Humanizer.GrammaticalGender)">
            <summary>
            Converts a thousands three-digit number to text.
            </summary>
            <param name="number">The three-digit number, as thousands, to convert.</param>
            <param name="gender">The grammatical gender to convert to.</param>
            <returns>The same three-digit number of thousands expressed as text.</returns>
        </member>
        <member name="M:Humanizer.RomanianCardinalNumberConverter.MillionsConverter(System.Int32,Humanizer.GrammaticalGender)">
            <summary>
            Converts a millions three-digit number to text.
            </summary>
            <param name="number">The three-digit number, as millions, to convert.</param>
            <param name="gender">The grammatical gender to convert to.</param>
            <returns>The same three-digit number of millions expressed as text.</returns>
        </member>
        <member name="M:Humanizer.RomanianCardinalNumberConverter.BillionsConverter(System.Int32,Humanizer.GrammaticalGender)">
            <summary>
            Converts a billions three-digit number to text.
            </summary>
            <param name="number">The three-digit number, as billions, to convert.</param>
            <param name="gender">The grammatical gender to convert to.</param>
            <returns>The same three-digit number of billions expressed as text.</returns>
        </member>
        <member name="F:Humanizer.RomanianOrdinalNumberConverter._ordinalsUnder10">
            <summary>
            Lookup table converting units number to text. Index 1 for 1, index 2 for 2, up to index 9.
            </summary>
        </member>
        <member name="T:Humanizer.IOrdinalizer">
            <summary>
            The interface used to localise the Ordinalize method
            </summary>
        </member>
        <member name="M:Humanizer.IOrdinalizer.Convert(System.Int32,System.String)">
            <summary>
            Ordinalizes the number
            </summary>
        </member>
        <member name="M:Humanizer.IOrdinalizer.Convert(System.Int32,System.String,Humanizer.WordForm)">
            <summary>
            Ordinalizes the number to a locale's specific form.
            </summary>
        </member>
        <member name="M:Humanizer.IOrdinalizer.Convert(System.Int32,System.String,Humanizer.GrammaticalGender)">
            <summary>
            Ordinalizes the number using the provided grammatical gender
            </summary>
        </member>
        <member name="M:Humanizer.IOrdinalizer.Convert(System.Int32,System.String,Humanizer.GrammaticalGender,Humanizer.WordForm)">
            <summary>
            Ordinalizes the number to a locale's specific form using the provided grammatical gender.
            </summary>
        </member>
        <member name="T:Humanizer.ResourceKeys.DateHumanize">
            <summary>
            Encapsulates the logic required to get the resource keys for DateTime.Humanize
            </summary>
        </member>
        <member name="F:Humanizer.ResourceKeys.DateHumanize.Now">
            <summary>
            Resource key for Now.
            </summary>
        </member>
        <member name="F:Humanizer.ResourceKeys.DateHumanize.Never">
            <summary>
            Resource key for Never.
            </summary>
        </member>
        <member name="M:Humanizer.ResourceKeys.DateHumanize.GetResourceKey(Humanizer.TimeUnit,Humanizer.Tense,System.Int32)">
            <summary>
            Generates Resource Keys according to convention.
            </summary>
            <param name="timeUnit">Time unit</param>
            <param name="timeUnitTense">Is time unit in future or past</param>
            <param name="count">Number of units, default is One.</param>
            <returns>Resource key, like DateHumanize_SingleMinuteAgo</returns>
        </member>
        <member name="T:Humanizer.ResourceKeys.TimeSpanHumanize">
            <summary>
            Encapsulates the logic required to get the resource keys for TimeSpan.Humanize
            Examples: TimeSpanHumanize_SingleMinute, TimeSpanHumanize_MultipleHours.
            </summary>
        </member>
        <member name="M:Humanizer.ResourceKeys.TimeSpanHumanize.GetResourceKey(Humanizer.TimeUnit,System.Int32,System.Boolean)">
            <summary>
            Generates Resource Keys according to convention.
            </summary>
            <param name="unit">Time unit, <see cref="T:Humanizer.TimeUnit"/>.</param>
            <param name="count">Number of units, default is One.</param>
            <param name="toWords">Result to words, default is false.</param>
            <returns>Resource key, like TimeSpanHumanize_SingleMinute</returns>
        </member>
        <member name="T:Humanizer.ResourceKeys.TimeUnitSymbol">
            <summary>
            Encapsulates the logic required to get the resource keys for TimeUnit.ToSymbol
            </summary>
        </member>
        <member name="M:Humanizer.ResourceKeys.TimeUnitSymbol.GetResourceKey(Humanizer.TimeUnit)">
            <summary>
            Generates Resource Keys according to convention.
            Examples: TimeUnit_Minute, TimeUnit_Hour.
            </summary>
            <param name="unit">Time unit, <see cref="T:Humanizer.TimeUnit"/>.</param>
            <returns>Resource key, like TimeSpanHumanize_SingleMinute</returns>
        </member>
        <member name="T:Humanizer.Resources">
            <summary>
            Provides access to the resources of Humanizer
            </summary>
        </member>
        <member name="M:Humanizer.Resources.GetResource(System.String,System.Globalization.CultureInfo)">
            <summary>
            Returns the value of the specified string resource
            </summary>
            <param name="resourceKey">The name of the resource to retrieve.</param>
            <param name="culture">The culture of the resource to retrieve. If not specified, current thread's UI culture is used.</param>
            <returns>The value of the resource localized for the specified culture.</returns>
        </member>
        <member name="M:Humanizer.Resources.TryGetResource(System.String,System.Globalization.CultureInfo,System.String@)">
            <summary>
            Tries to get the value of the specified string resource, without fallback
            </summary>
            <param name="resourceKey">The name of the resource to retrieve.</param>
            <param name="culture">The culture of the resource to retrieve. If not specified, current thread's UI culture is used.</param>
            <param name="result">The value of the resource localized for the specified culture if found; null otherwise.</param>
            <returns>true if the specified string resource was found for the given culture; otherwise, false.</returns>
        </member>
        <member name="T:Humanizer.Tense">
            <summary>
            Enumerates the possible time references; past or future.
            </summary>
        </member>
        <member name="T:Humanizer.MetricNumeralExtensions">
            <summary>
            Contains extension methods for changing a number to Metric representation (ToMetric)
            and from Metric representation back to the number (FromMetric)
            </summary>
        </member>
        <member name="F:Humanizer.MetricNumeralExtensions.Symbols">
            <summary>
            Symbols is a list of every symbols for the Metric system.
            </summary>
        </member>
        <member name="F:Humanizer.MetricNumeralExtensions.UnitPrefixes">
            <summary>
            UnitPrefixes link a Metric symbol (as key) to its prefix (as value).
            </summary>
            <remarks>
            We dont support :
            {'h', "hecto"},
            {'da', "deca" }, // !string
            {'d', "deci" },
            {'c', "centi"},
            </remarks>
        </member>
        <member name="M:Humanizer.MetricNumeralExtensions.FromMetric(System.String)">
            <summary>
            Converts a Metric representation into a number.
            </summary>
            <remarks>
            We don't support input in the format {number}{name} nor {number} {name}.
            We only provide a solution for {number}{symbol} and {number} {symbol}.
            </remarks>
            <param name="input">Metric representation to convert to a number</param>
            <example>
            <code>
            "1k".FromMetric() => 1000d
            "123".FromMetric() => 123d
            "100m".FromMetric() => 1E-1
            </code>
            </example>
            <returns>A number after a conversion from a Metric representation.</returns>
        </member>
        <member name="M:Humanizer.MetricNumeralExtensions.ToMetric(System.Int32,System.Nullable{Humanizer.MetricNumeralFormats},System.Nullable{System.Int32})">
            <summary>
            Converts a number into a valid and Human-readable Metric representation.
            </summary>
            <remarks>
            Inspired by a snippet from Thom Smith.
            See <a href="http://stackoverflow.com/questions/12181024/formatting-a-number-with-a-metric-prefix">this link</a> for more.
            </remarks>
            <param name="input">Number to convert to a Metric representation.</param>
            <param name="formats">A bitwise combination of <see cref="T:Humanizer.MetricNumeralFormats"/> enumeration values that format the metric representation.</param>
            <param name="decimals">If not null it is the numbers of decimals to round the number to</param>
            <example>
            <code>
            1000.ToMetric() => "1k"
            123.ToMetric() => "123"
            1E-1.ToMetric() => "100m"
            </code>
            </example>
            <returns>A valid Metric representation</returns>
        </member>
        <member name="M:Humanizer.MetricNumeralExtensions.ToMetric(System.Double,System.Nullable{Humanizer.MetricNumeralFormats},System.Nullable{System.Int32})">
            <summary>
            Converts a number into a valid and Human-readable Metric representation.
            </summary>
            <remarks>
            Inspired by a snippet from Thom Smith.
            See <a href="http://stackoverflow.com/questions/12181024/formatting-a-number-with-a-metric-prefix">this link</a> for more.
            </remarks>
            <param name="input">Number to convert to a Metric representation.</param>
            <param name="formats">A bitwise combination of <see cref="T:Humanizer.MetricNumeralFormats"/> enumeration values that format the metric representation.</param>
            <param name="decimals">If not null it is the numbers of decimals to round the number to</param>
            <example>
            <code>
            1000d.ToMetric() => "1k"
            123d.ToMetric() => "123"
            1E-1.ToMetric() => "100m"
            </code>
            </example>
            <returns>A valid Metric representation</returns>
        </member>
        <member name="M:Humanizer.MetricNumeralExtensions.CleanRepresentation(System.String)">
            <summary>
            Clean or handle any wrong input
            </summary>
            <param name="input">Metric representation to clean</param>
            <returns>A cleaned representation</returns>
        </member>
        <member name="M:Humanizer.MetricNumeralExtensions.BuildNumber(System.String,System.Char)">
            <summary>
            Build a number from a metric representation or from a number
            </summary>
            <param name="input">A Metric representation to parse to a number</param>
            <param name="last">The last character of input</param>
            <returns>A number build from a Metric representation</returns>
        </member>
        <member name="M:Humanizer.MetricNumeralExtensions.BuildMetricNumber(System.String,System.Char)">
            <summary>
            Build a number from a metric representation
            </summary>
            <param name="input">A Metric representation to parse to a number</param>
            <param name="last">The last character of input</param>
            <returns>A number build from a Metric representation</returns>
        </member>
        <member name="M:Humanizer.MetricNumeralExtensions.ReplaceNameBySymbol(System.String)">
            <summary>
            Replace every symbol's name by its symbol representation.
            </summary>
            <param name="input">Metric representation with a name or a symbol</param>
            <returns>A metric representation with a symbol</returns>
        </member>
        <member name="M:Humanizer.MetricNumeralExtensions.BuildRepresentation(System.Double,System.Nullable{Humanizer.MetricNumeralFormats},System.Nullable{System.Int32})">
            <summary>
            Build a Metric representation of the number.
            </summary>
            <param name="input">Number to convert to a Metric representation.</param>
            <param name="formats">A bitwise combination of <see cref="T:Humanizer.MetricNumeralFormats"/> enumeration values that format the metric representation.</param>
            <param name="decimals">If not null it is the numbers of decimals to round the number to</param>
            <returns>A number in a Metric representation</returns>
        </member>
        <member name="M:Humanizer.MetricNumeralExtensions.BuildMetricRepresentation(System.Double,System.Int32,System.Nullable{Humanizer.MetricNumeralFormats},System.Nullable{System.Int32})">
            <summary>
            Build a Metric representation of the number.
            </summary>
            <param name="input">Number to convert to a Metric representation.</param>
            <param name="exponent">Exponent of the number in a scientific notation</param>
            <param name="formats">A bitwise combination of <see cref="T:Humanizer.MetricNumeralFormats"/> enumeration values that format the metric representation.</param>
            <param name="decimals">If not null it is the numbers of decimals to round the number to</param>
            <returns>A number in a Metric representation</returns>
        </member>
        <member name="M:Humanizer.MetricNumeralExtensions.GetUnitText(System.Char,System.Nullable{Humanizer.MetricNumeralFormats})">
            <summary>
            Get the unit from a symbol of from the symbol's name.
            </summary>
            <param name="symbol">The symbol linked to the unit</param>
            <param name="formats">A bitwise combination of <see cref="T:Humanizer.MetricNumeralFormats"/> enumeration values that format the metric representation.</param>
            <returns>A symbol, a symbol's name, a symbol's short scale word or a symbol's long scale word</returns>
        </member>
        <member name="M:Humanizer.MetricNumeralExtensions.IsOutOfRange(System.Double)">
            <summary>
            Check if a Metric representation is out of the valid range.
            </summary>
            <param name="input">A Metric representation that may be out of the valid range.</param>
            <returns>True if input is out of the valid range.</returns>
        </member>
        <member name="M:Humanizer.MetricNumeralExtensions.IsInvalidMetricNumeral(System.String)">
            <summary>
            Check if a string is not a valid Metric representation.
            A valid representation is in the format "{0}{1}" or "{0} {1}"
            where {0} is a number and {1} is an allowed symbol.
            </summary>
            <remarks>
            ToDo: Performance: Use (string input, out number) to escape the double use of Parse()
            </remarks>
            <param name="input">>A string that may contain an invalid Metric representation.</param>
            <returns>True if input is not a valid Metric representation.</returns>
        </member>
        <member name="T:Humanizer.MetricNumeralFormats">
            <summary>
            Flags for formatting the metric representation of numerals.
            </summary>
        </member>
        <member name="F:Humanizer.MetricNumeralFormats.UseLongScaleWord">
            <summary>
            Use the metric prefix <a href="https://en.wikipedia.org/wiki/Long_and_short_scales">long scale word</a>.
            </summary>
        </member>
        <member name="F:Humanizer.MetricNumeralFormats.UseName">
            <summary>
            Use the metric prefix <a href="https://en.wikipedia.org/wiki/Metric_prefix#List_of_SI_prefixes">name</a> instead of the symbol.
            </summary>
        </member>
        <member name="F:Humanizer.MetricNumeralFormats.UseShortScaleWord">
            <summary>
            Use the metric prefix <a href="https://en.wikipedia.org/wiki/Long_and_short_scales">short scale word</a>.
            </summary>
        </member>
        <member name="F:Humanizer.MetricNumeralFormats.WithSpace">
            <summary>
            Include a space after the numeral.
            </summary>
        </member>
        <member name="T:Humanizer.NoMatchFoundException">
            <summary>
            This is thrown on String.DehumanizeTo enum when the provided string cannot be mapped to the target enum
            </summary>
        </member>
        <member name="T:Humanizer.NumberToNumberExtensions">
            <summary>
            Number to Number extensions
            </summary>
        </member>
        <member name="M:Humanizer.NumberToNumberExtensions.Tens(System.Int32)">
            <summary>
            5.Tens == 50
            </summary>
        </member>
        <member name="M:Humanizer.NumberToNumberExtensions.Tens(System.UInt32)">
            <summary>
            5.Tens == 50
            </summary>
        </member>
        <member name="M:Humanizer.NumberToNumberExtensions.Tens(System.Int64)">
            <summary>
            5.Tens == 50
            </summary>
        </member>
        <member name="M:Humanizer.NumberToNumberExtensions.Tens(System.UInt64)">
            <summary>
            5.Tens == 50
            </summary>
        </member>
        <member name="M:Humanizer.NumberToNumberExtensions.Tens(System.Double)">
            <summary>
            5.Tens == 50
            </summary>
        </member>
        <member name="M:Humanizer.NumberToNumberExtensions.Hundreds(System.Int32)">
            <summary>
            4.Hundreds() == 400
            </summary>
        </member>
        <member name="M:Humanizer.NumberToNumberExtensions.Hundreds(System.UInt32)">
            <summary>
            4.Hundreds() == 400
            </summary>
        </member>
        <member name="M:Humanizer.NumberToNumberExtensions.Hundreds(System.Int64)">
            <summary>
            4.Hundreds() == 400
            </summary>
        </member>
        <member name="M:Humanizer.NumberToNumberExtensions.Hundreds(System.UInt64)">
            <summary>
            4.Hundreds() == 400
            </summary>
        </member>
        <member name="M:Humanizer.NumberToNumberExtensions.Hundreds(System.Double)">
            <summary>
            4.Hundreds() == 400
            </summary>
        </member>
        <member name="M:Humanizer.NumberToNumberExtensions.Thousands(System.Int32)">
            <summary>
            3.Thousands() == 3000
            </summary>
        </member>
        <member name="M:Humanizer.NumberToNumberExtensions.Thousands(System.UInt32)">
            <summary>
            3.Thousands() == 3000
            </summary>
        </member>
        <member name="M:Humanizer.NumberToNumberExtensions.Thousands(System.Int64)">
            <summary>
            3.Thousands() == 3000
            </summary>
        </member>
        <member name="M:Humanizer.NumberToNumberExtensions.Thousands(System.UInt64)">
            <summary>
            3.Thousands() == 3000
            </summary>
        </member>
        <member name="M:Humanizer.NumberToNumberExtensions.Thousands(System.Double)">
            <summary>
            3.Thousands() == 3000
            </summary>
        </member>
        <member name="M:Humanizer.NumberToNumberExtensions.Millions(System.Int32)">
            <summary>
            2.Millions() == 2000000
            </summary>
        </member>
        <member name="M:Humanizer.NumberToNumberExtensions.Millions(System.UInt32)">
            <summary>
            2.Millions() == 2000000
            </summary>
        </member>
        <member name="M:Humanizer.NumberToNumberExtensions.Millions(System.Int64)">
            <summary>
            2.Millions() == 2000000
            </summary>
        </member>
        <member name="M:Humanizer.NumberToNumberExtensions.Millions(System.UInt64)">
            <summary>
            2.Millions() == 2000000
            </summary>
        </member>
        <member name="M:Humanizer.NumberToNumberExtensions.Millions(System.Double)">
            <summary>
            2.Millions() == 2000000
            </summary>
        </member>
        <member name="M:Humanizer.NumberToNumberExtensions.Billions(System.Int32)">
            <summary>
            1.Billions() == 1000000000 (short scale)
            </summary>
        </member>
        <member name="M:Humanizer.NumberToNumberExtensions.Billions(System.UInt32)">
            <summary>
            1.Billions() == 1000000000 (short scale)
            </summary>
        </member>
        <member name="M:Humanizer.NumberToNumberExtensions.Billions(System.Int64)">
            <summary>
            1.Billions() == 1000000000 (short scale)
            </summary>
        </member>
        <member name="M:Humanizer.NumberToNumberExtensions.Billions(System.UInt64)">
            <summary>
            1.Billions() == 1000000000 (short scale)
            </summary>
        </member>
        <member name="M:Humanizer.NumberToNumberExtensions.Billions(System.Double)">
            <summary>
            1.Billions() == 1000000000 (short scale)
            </summary>
        </member>
        <member name="T:Humanizer.NumberToTimeSpanExtensions">
            <summary>
            Number to TimeSpan extensions
            </summary>
        </member>
        <member name="M:Humanizer.NumberToTimeSpanExtensions.Milliseconds(System.Byte)">
            <summary>
            5.Milliseconds() == TimeSpan.FromMilliseconds(5)
            </summary>
        </member>
        <member name="M:Humanizer.NumberToTimeSpanExtensions.Milliseconds(System.SByte)">
            <summary>
            5.Milliseconds() == TimeSpan.FromMilliseconds(5)
            </summary>
        </member>
        <member name="M:Humanizer.NumberToTimeSpanExtensions.Milliseconds(System.Int16)">
            <summary>
            5.Milliseconds() == TimeSpan.FromMilliseconds(5)
            </summary>
        </member>
        <member name="M:Humanizer.NumberToTimeSpanExtensions.Milliseconds(System.UInt16)">
            <summary>
            5.Milliseconds() == TimeSpan.FromMilliseconds(5)
            </summary>
        </member>
        <member name="M:Humanizer.NumberToTimeSpanExtensions.Milliseconds(System.Int32)">
            <summary>
            5.Milliseconds() == TimeSpan.FromMilliseconds(5)
            </summary>
        </member>
        <member name="M:Humanizer.NumberToTimeSpanExtensions.Milliseconds(System.UInt32)">
            <summary>
            5.Milliseconds() == TimeSpan.FromMilliseconds(5)
            </summary>
        </member>
        <member name="M:Humanizer.NumberToTimeSpanExtensions.Milliseconds(System.Int64)">
            <summary>
            5.Milliseconds() == TimeSpan.FromMilliseconds(5)
            </summary>
        </member>
        <member name="M:Humanizer.NumberToTimeSpanExtensions.Milliseconds(System.UInt64)">
            <summary>
            5.Milliseconds() == TimeSpan.FromMilliseconds(5)
            </summary>
        </member>
        <member name="M:Humanizer.NumberToTimeSpanExtensions.Milliseconds(System.Double)">
            <summary>
            5.Milliseconds() == TimeSpan.FromMilliseconds(5)
            </summary>
        </member>
        <member name="M:Humanizer.NumberToTimeSpanExtensions.Seconds(System.Byte)">
            <summary>
            5.Seconds() == TimeSpan.FromSeconds(5)
            </summary>
        </member>
        <member name="M:Humanizer.NumberToTimeSpanExtensions.Seconds(System.SByte)">
            <summary>
            5.Seconds() == TimeSpan.FromSeconds(5)
            </summary>
        </member>
        <member name="M:Humanizer.NumberToTimeSpanExtensions.Seconds(System.Int16)">
            <summary>
            5.Seconds() == TimeSpan.FromSeconds(5)
            </summary>
        </member>
        <member name="M:Humanizer.NumberToTimeSpanExtensions.Seconds(System.UInt16)">
            <summary>
            5.Seconds() == TimeSpan.FromSeconds(5)
            </summary>
        </member>
        <member name="M:Humanizer.NumberToTimeSpanExtensions.Seconds(System.Int32)">
            <summary>
            5.Seconds() == TimeSpan.FromSeconds(5)
            </summary>
        </member>
        <member name="M:Humanizer.NumberToTimeSpanExtensions.Seconds(System.UInt32)">
            <summary>
            5.Seconds() == TimeSpan.FromSeconds(5)
            </summary>
        </member>
        <member name="M:Humanizer.NumberToTimeSpanExtensions.Seconds(System.Int64)">
            <summary>
            5.Seconds() == TimeSpan.FromSeconds(5)
            </summary>
        </member>
        <member name="M:Humanizer.NumberToTimeSpanExtensions.Seconds(System.UInt64)">
            <summary>
            5.Seconds() == TimeSpan.FromSeconds(5)
            </summary>
        </member>
        <member name="M:Humanizer.NumberToTimeSpanExtensions.Seconds(System.Double)">
            <summary>
            5.Seconds() == TimeSpan.FromSeconds(5)
            </summary>
        </member>
        <member name="M:Humanizer.NumberToTimeSpanExtensions.Minutes(System.Byte)">
            <summary>
            4.Minutes() == TimeSpan.FromMinutes(4)
            </summary>
        </member>
        <member name="M:Humanizer.NumberToTimeSpanExtensions.Minutes(System.SByte)">
            <summary>
            4.Minutes() == TimeSpan.FromMinutes(4)
            </summary>
        </member>
        <member name="M:Humanizer.NumberToTimeSpanExtensions.Minutes(System.Int16)">
            <summary>
            4.Minutes() == TimeSpan.FromMinutes(4)
            </summary>
        </member>
        <member name="M:Humanizer.NumberToTimeSpanExtensions.Minutes(System.UInt16)">
            <summary>
            4.Minutes() == TimeSpan.FromMinutes(4)
            </summary>
        </member>
        <member name="M:Humanizer.NumberToTimeSpanExtensions.Minutes(System.Int32)">
            <summary>
            4.Minutes() == TimeSpan.FromMinutes(4)
            </summary>
        </member>
        <member name="M:Humanizer.NumberToTimeSpanExtensions.Minutes(System.UInt32)">
            <summary>
            4.Minutes() == TimeSpan.FromMinutes(4)
            </summary>
        </member>
        <member name="M:Humanizer.NumberToTimeSpanExtensions.Minutes(System.Int64)">
            <summary>
            4.Minutes() == TimeSpan.FromMinutes(4)
            </summary>
        </member>
        <member name="M:Humanizer.NumberToTimeSpanExtensions.Minutes(System.UInt64)">
            <summary>
            4.Minutes() == TimeSpan.FromMinutes(4)
            </summary>
        </member>
        <member name="M:Humanizer.NumberToTimeSpanExtensions.Minutes(System.Double)">
            <summary>
            4.Minutes() == TimeSpan.FromMinutes(4)
            </summary>
        </member>
        <member name="M:Humanizer.NumberToTimeSpanExtensions.Hours(System.Byte)">
            <summary>
            3.Hours() == TimeSpan.FromHours(3)
            </summary>
        </member>
        <member name="M:Humanizer.NumberToTimeSpanExtensions.Hours(System.SByte)">
            <summary>
            3.Hours() == TimeSpan.FromHours(3)
            </summary>
        </member>
        <member name="M:Humanizer.NumberToTimeSpanExtensions.Hours(System.Int16)">
            <summary>
            3.Hours() == TimeSpan.FromHours(3)
            </summary>
        </member>
        <member name="M:Humanizer.NumberToTimeSpanExtensions.Hours(System.UInt16)">
            <summary>
            3.Hours() == TimeSpan.FromHours(3)
            </summary>
        </member>
        <member name="M:Humanizer.NumberToTimeSpanExtensions.Hours(System.Int32)">
            <summary>
            3.Hours() == TimeSpan.FromHours(3)
            </summary>
        </member>
        <member name="M:Humanizer.NumberToTimeSpanExtensions.Hours(System.UInt32)">
            <summary>
            3.Hours() == TimeSpan.FromHours(3)
            </summary>
        </member>
        <member name="M:Humanizer.NumberToTimeSpanExtensions.Hours(System.Int64)">
            <summary>
            3.Hours() == TimeSpan.FromHours(3)
            </summary>
        </member>
        <member name="M:Humanizer.NumberToTimeSpanExtensions.Hours(System.UInt64)">
            <summary>
            3.Hours() == TimeSpan.FromHours(3)
            </summary>
        </member>
        <member name="M:Humanizer.NumberToTimeSpanExtensions.Hours(System.Double)">
            <summary>
            3.Hours() == TimeSpan.FromHours(3)
            </summary>
        </member>
        <member name="M:Humanizer.NumberToTimeSpanExtensions.Days(System.Byte)">
            <summary>
            2.Days() == TimeSpan.FromDays(2)
            </summary>
        </member>
        <member name="M:Humanizer.NumberToTimeSpanExtensions.Days(System.SByte)">
            <summary>
            2.Days() == TimeSpan.FromDays(2)
            </summary>
        </member>
        <member name="M:Humanizer.NumberToTimeSpanExtensions.Days(System.Int16)">
            <summary>
            2.Days() == TimeSpan.FromDays(2)
            </summary>
        </member>
        <member name="M:Humanizer.NumberToTimeSpanExtensions.Days(System.UInt16)">
            <summary>
            2.Days() == TimeSpan.FromDays(2)
            </summary>
        </member>
        <member name="M:Humanizer.NumberToTimeSpanExtensions.Days(System.Int32)">
            <summary>
            2.Days() == TimeSpan.FromDays(2)
            </summary>
        </member>
        <member name="M:Humanizer.NumberToTimeSpanExtensions.Days(System.UInt32)">
            <summary>
            2.Days() == TimeSpan.FromDays(2)
            </summary>
        </member>
        <member name="M:Humanizer.NumberToTimeSpanExtensions.Days(System.Int64)">
            <summary>
            2.Days() == TimeSpan.FromDays(2)
            </summary>
        </member>
        <member name="M:Humanizer.NumberToTimeSpanExtensions.Days(System.UInt64)">
            <summary>
            2.Days() == TimeSpan.FromDays(2)
            </summary>
        </member>
        <member name="M:Humanizer.NumberToTimeSpanExtensions.Days(System.Double)">
            <summary>
            2.Days() == TimeSpan.FromDays(2)
            </summary>
        </member>
        <member name="M:Humanizer.NumberToTimeSpanExtensions.Weeks(System.Byte)">
            <summary>
            2.Weeks() == new TimeSpan(14, 0, 0, 0)
            </summary>
        </member>
        <member name="M:Humanizer.NumberToTimeSpanExtensions.Weeks(System.SByte)">
            <summary>
            2.Weeks() == new TimeSpan(14, 0, 0, 0)
            </summary>
        </member>
        <member name="M:Humanizer.NumberToTimeSpanExtensions.Weeks(System.Int16)">
            <summary>
            2.Weeks() == new TimeSpan(14, 0, 0, 0)
            </summary>
        </member>
        <member name="M:Humanizer.NumberToTimeSpanExtensions.Weeks(System.UInt16)">
            <summary>
            2.Weeks() == new TimeSpan(14, 0, 0, 0)
            </summary>
        </member>
        <member name="M:Humanizer.NumberToTimeSpanExtensions.Weeks(System.Int32)">
            <summary>
            2.Weeks() == new TimeSpan(14, 0, 0, 0)
            </summary>
        </member>
        <member name="M:Humanizer.NumberToTimeSpanExtensions.Weeks(System.UInt32)">
            <summary>
            2.Weeks() == new TimeSpan(14, 0, 0, 0)
            </summary>
        </member>
        <member name="M:Humanizer.NumberToTimeSpanExtensions.Weeks(System.Int64)">
            <summary>
            2.Weeks() == new TimeSpan(14, 0, 0, 0)
            </summary>
        </member>
        <member name="M:Humanizer.NumberToTimeSpanExtensions.Weeks(System.UInt64)">
            <summary>
            2.Weeks() == new TimeSpan(14, 0, 0, 0)
            </summary>
        </member>
        <member name="M:Humanizer.NumberToTimeSpanExtensions.Weeks(System.Double)">
            <summary>
            2.Weeks() == new TimeSpan(14, 0, 0, 0)
            </summary>
        </member>
        <member name="T:Humanizer.NumberToWordsExtension">
            <summary>
            Transform a number into words; e.g. 1 => one
            </summary>
        </member>
        <member name="M:Humanizer.NumberToWordsExtension.ToOrdinalWords(System.Int32,System.Globalization.CultureInfo)">
            <summary>
            1.ToOrdinalWords() -> "first"
            </summary>
            <param name="number">Number to be turned to ordinal words</param>
            <param name="culture">Culture to use. If null, current thread's UI culture is used.</param>
        </member>
        <member name="M:Humanizer.NumberToWordsExtension.ToOrdinalWords(System.Int32,Humanizer.WordForm,System.Globalization.CultureInfo)">
            <summary>
            Converts a number to ordinal words supporting locale's specific variations.
            </summary>
            <example>
            In Spanish:
            <code>
            1.ToOrdinalWords(WordForm.Normal) -> "primero" // As in "He llegado el primero".
            3.ToOrdinalWords(WordForm.Abbreviation) -> "tercer" // As in "Vivo en el tercer piso"
            </code>
            </example>
            <param name="number">Number to be turned to ordinal words</param>
            <param name="wordForm">Form of the word, i.e. abbreviation</param>
            <param name="culture">Culture to use. If null, current thread's UI culture is used.</param>
            <returns>The number converted into ordinal words</returns>
        </member>
        <member name="M:Humanizer.NumberToWordsExtension.ToOrdinalWords(System.Int32,Humanizer.GrammaticalGender,System.Globalization.CultureInfo)">
            <summary>
            for Brazilian Portuguese locale
            1.ToOrdinalWords(GrammaticalGender.Masculine) -> "primeiro"
            1.ToOrdinalWords(GrammaticalGender.Feminine) -> "primeira"
            </summary>
            <param name="number">Number to be turned to words</param>
            <param name="gender">The grammatical gender to use for output words</param>
            <param name="culture">Culture to use. If null, current thread's UI culture is used.</param>
        </member>
        <member name="M:Humanizer.NumberToWordsExtension.ToOrdinalWords(System.Int32,Humanizer.GrammaticalGender,Humanizer.WordForm,System.Globalization.CultureInfo)">
            <summary>
            Converts a number to ordinal words supporting locale's specific variations.
            </summary>
            <example>
            In Spanish:
            <code>
            3.ToOrdinalWords(GrammaticalGender.Masculine, WordForm.Normal) -> "tercero"
            3.ToOrdinalWords(GrammaticalGender.Masculine, WordForm.Abbreviation) -> "tercer"
            3.ToOrdinalWords(GrammaticalGender.Feminine, WordForm.Normal) -> "tercera"
            3.ToOrdinalWords(GrammaticalGender.Feminine, WordForm.Abbreviation) -> "tercera"
            </code>
            </example>
            <param name="number">Number to be turned to ordinal words</param>
            <param name="gender">The grammatical gender to use for output words</param>
            <param name="wordForm">Form of the word, i.e. abbreviation</param>
            <param name="culture">Culture to use. If null, current thread's UI culture is used.</param>
            <returns>The number converted into ordinal words</returns>
        </member>
        <member name="M:Humanizer.NumberToWordsExtension.ToTuple(System.Int32,System.Globalization.CultureInfo)">
            <summary>
            1.ToTuple() -> "single"
            </summary>
            <param name="number">Number to be turned to tuple</param>
            <param name="culture">Culture to use. If null, current thread's UI culture is used.</param>
        </member>
        <member name="M:Humanizer.NumberToWordsExtension.ToWords(System.Int32,System.Globalization.CultureInfo)">
            <summary>
            3501.ToWords() -> "three thousand five hundred and one"
            </summary>
            <param name="number">Number to be turned to words</param>
            <param name="culture">Culture to use. If null, current thread's UI culture is used.</param>
        </member>
        <member name="M:Humanizer.NumberToWordsExtension.ToWords(System.Int32,Humanizer.WordForm,System.Globalization.CultureInfo)">
            <summary>
            Converts a number to words supporting specific word variations, including grammatical gender, of some locales.
            </summary>
            <example>
            In Spanish, numbers ended in 1 change its form depending on their position in the sentence.
            <code>
            21.ToWords(WordForm.Normal) -> veintiuno // as in "Mi nmero favorito es el veintiuno".
            21.ToWords(WordForm.Abbreviation) -> veintin // as in "En total, cont veintin coches"
            </code>
            </example>
            <param name="number">Number to be turned to words</param>
            <param name="wordForm">Form of the word, i.e. abbreviation</param>
            <param name="culture">Culture to use. If null, current thread's UI culture is used.</param>
            <returns>The number converted to words</returns>
        </member>
        <member name="M:Humanizer.NumberToWordsExtension.ToWords(System.Int32,System.Boolean,System.Globalization.CultureInfo)">
            <summary>
            3501.ToWords(false) -> "three thousand five hundred one"
            </summary>
            <param name="number">Number to be turned to words</param>
            <param name="addAnd">To add 'and' before the last number.</param>
            <param name="culture">Culture to use. If null, current thread's UI culture is used.</param>
        </member>
        <member name="M:Humanizer.NumberToWordsExtension.ToWords(System.Int32,System.Boolean,Humanizer.WordForm,System.Globalization.CultureInfo)">
            <summary>
            Converts a number to words supporting specific word variations of some locales.
            </summary>
            <example>
            In Spanish, numbers ended in 1 changes its form depending on their position in the sentence.
            <code>
            21.ToWords(WordForm.Normal) -> veintiuno // as in "Mi nmero favorito es el veintiuno".
            21.ToWords(WordForm.Abbreviation) -> veintin // as in "En total, cont veintin coches"
            </code>
            </example>
            <param name="number">Number to be turned to words</param>
            <param name="addAnd">To add 'and' before the last number</param>
            <param name="wordForm">Form of the word, i.e. abbreviation</param>
            <param name="culture">Culture to use. If null, current thread's UI culture is used.</param>
            <returns>The number converted to words</returns>
        </member>
        <member name="M:Humanizer.NumberToWordsExtension.ToWords(System.Int32,Humanizer.GrammaticalGender,System.Globalization.CultureInfo)">
            <summary>
            For locales that support gender-specific forms
            </summary>
            <example>
            Russian:
            <code>
              1.ToWords(GrammaticalGender.Masculine) -> ""
              1.ToWords(GrammaticalGender.Feminine) -> ""
            </code>
            Hebrew:
            <code>
              1.ToWords(GrammaticalGender.Masculine) -> ""
              1.ToWords(GrammaticalGender.Feminine) -> ""
            </code>
            </example>
            <param name="number">Number to be turned to words</param>
            <param name="gender">The grammatical gender to use for output words</param>
            <param name="culture">Culture to use. If null, current thread's UI culture is used.</param>
        </member>
        <member name="M:Humanizer.NumberToWordsExtension.ToWords(System.Int32,Humanizer.WordForm,Humanizer.GrammaticalGender,System.Globalization.CultureInfo)">
            <summary>
            Converts a number to words supporting specific word variations, including grammatical gender, of some locales.
            </summary>
            <example>
            In Spanish, numbers ended in 1 change its form depending on their position in the sentence.
            <code>
            21.ToWords(WordForm.Normal, GrammaticalGender.Masculine) -> veintiuno // as in "Mi nmero favorito es el veintiuno".
            21.ToWords(WordForm.Abbreviation, GrammaticalGender.Masculine) -> veintin // as in "En total, cont veintin coches"
            21.ToWords(WordForm.Normal, GrammaticalGender.Feminine) -> veintiuna // as in "veintiuna personas"
            </code>
            </example>
            <param name="number">Number to be turned to words</param>
            <param name="wordForm">Form of the word, i.e. abbreviation</param>
            <param name="gender">The grammatical gender to use for output words</param>
            <param name="culture">Culture to use. If null, current thread's UI culture is used.</param>
            <returns>The number converted to words</returns>
        </member>
        <member name="M:Humanizer.NumberToWordsExtension.ToWords(System.Int64,System.Globalization.CultureInfo,System.Boolean)">
            <summary>
            3501.ToWords() -> "three thousand five hundred and one"
            </summary>
            <param name="number">Number to be turned to words</param>
            <param name="culture">Culture to use. If null, current thread's UI culture is used.</param>
            <param name="addAnd">Whether "and" should be included or not.</param>
        </member>
        <member name="M:Humanizer.NumberToWordsExtension.ToWords(System.Int64,Humanizer.WordForm,System.Globalization.CultureInfo,System.Boolean)">
            <summary>
            Converts a number to words supporting specific word variations of some locales.
            </summary>
            <example>
            In Spanish, numbers ended in 1 changes its form depending on their position in the sentence.
            <code>
            21.ToWords(WordForm.Normal) -> veintiuno // as in "Mi nmero favorito es el veintiuno".
            21.ToWords(WordForm.Abbreviation) -> veintin // as in "En total, cont veintin coches"
            </code>
            </example>
            <param name="number">Number to be turned to words</param>
            <param name="wordForm">Form of the word, i.e. abbreviation</param>
            <param name="culture">Culture to use. If null, current thread's UI culture is used.</param>
            <param name="addAnd">To add 'and' before the last number</param>
            <returns>The number converted to words</returns>
        </member>
        <member name="M:Humanizer.NumberToWordsExtension.ToWords(System.Int64,Humanizer.GrammaticalGender,System.Globalization.CultureInfo)">
             <summary>
             For locales that support gender-specific forms
             </summary>
             <example>
             Russian:
             <code>
               1.ToWords(GrammaticalGender.Masculine) -> ""
               1.ToWords(GrammaticalGender.Feminine) -> ""
             </code>
             Hebrew:
             <code>
               1.ToWords(GrammaticalGender.Masculine) -> ""
               1.ToWords(GrammaticalGender.Feminine) -> ""
             </code>
             </example>
            
             <param name="number">Number to be turned to words</param>
             <param name="gender">The grammatical gender to use for output words</param>
             <param name="culture">Culture to use. If null, current thread's UI culture is used.</param>
        </member>
        <member name="M:Humanizer.NumberToWordsExtension.ToWords(System.Int64,Humanizer.WordForm,Humanizer.GrammaticalGender,System.Globalization.CultureInfo)">
            <summary>
            Converts a number to words supporting specific word variations, including grammatical gender, of some locales.
            </summary>
            <example>
            In Spanish, numbers ended in 1 changes its form depending on their position in the sentence.
            <code>
            21.ToWords(WordForm.Normal, GrammaticalGender.Masculine) -> veintiuno // as in "Mi nmero favorito es el veintiuno".
            21.ToWords(WordForm.Abbreviation, GrammaticalGender.Masculine) -> veintin // as in "En total, cont veintin coches"
            21.ToWords(WordForm.Normal, GrammaticalGender.Feminine) -> veintiuna // as in "veintiuna personas"
            </code>
            </example>
            <param name="number">Number to be turned to words</param>
            <param name="wordForm">Form of the word, i.e. abbreviation</param>
            <param name="gender">The grammatical gender to use for output words</param>
            <param name="culture">Culture to use. If null, current thread's UI culture is used.</param>
            <returns>The number converted to words</returns>
        </member>
        <member name="T:Humanizer.OnNoMatch">
            <summary>
            Dictating what should be done when a match is not found - currently used only for DehumanizeTo
            </summary>
        </member>
        <member name="F:Humanizer.OnNoMatch.ThrowsException">
            <summary>
            This is the default behavior which throws a NoMatchFoundException
            </summary>
        </member>
        <member name="F:Humanizer.OnNoMatch.ReturnsNull">
            <summary>
            If set to ReturnsNull the method returns null instead of throwing an exception
            </summary>
        </member>
        <member name="T:Humanizer.OrdinalizeExtensions">
            <summary>
            Ordinalize extensions
            </summary>
        </member>
        <member name="M:Humanizer.OrdinalizeExtensions.Ordinalize(System.String)">
            <summary>
            Turns a number into an ordinal string used to denote the position in an ordered sequence such as 1st, 2nd, 3rd, 4th.
            </summary>
            <param name="numberString">The number, in string, to be ordinalized</param>
        </member>
        <member name="M:Humanizer.OrdinalizeExtensions.Ordinalize(System.String,Humanizer.WordForm)">
            <summary>
            Turns a number into an ordinal number used to denote the position in an ordered sequence supporting specific locale's variations.
            </summary>
            <example>
            In Spanish:
            <code>
            "1".Ordinalize(WordForm.Abbreviation) -> 1.er // As in "Vivo en el 1.er piso"
            "1".Ordinalize(WordForm.Normal) -> 1. // As in "Fui el 1 de mi promocin"
            </code>
            </example>
            <param name="numberString">The number, in string, to be ordinalized</param>
            <param name="wordForm">Form of the word, i.e. abbreviation</param>
            <returns>The number ordinalized</returns>
        </member>
        <member name="M:Humanizer.OrdinalizeExtensions.Ordinalize(System.String,System.Globalization.CultureInfo)">
            <summary>
            Turns a number into an ordinal string used to denote the position in an ordered sequence such as 1st, 2nd, 3rd, 4th.
            </summary>
            <param name="numberString">The number, in string, to be ordinalized</param>
            <param name="culture">Culture to use. If null, current thread's UI culture is used.</param>
        </member>
        <member name="M:Humanizer.OrdinalizeExtensions.Ordinalize(System.String,System.Globalization.CultureInfo,Humanizer.WordForm)">
            <summary>
            Turns a number into an ordinal number used to denote the position in an ordered sequence supporting specific locale's variations.
            </summary>
            <example>
            In Spanish:
            <code>
            "1".Ordinalize(new CultureInfo("es-ES"),WordForm.Abbreviation) -> 1.er // As in "Vivo en el 1.er piso"
            "1".Ordinalize(new CultureInfo("es-ES"), WordForm.Normal) -> 1. // As in "Fui el 1 de mi promocin"
            </code>
            </example>
            <param name="numberString">The number to be ordinalized</param>
            <param name="culture">Culture to use. If null, current thread's UI culture is used.</param>
            <param name="wordForm">Form of the word, i.e. abbreviation</param>
            <returns>The number ordinalized</returns>
        </member>
        <member name="M:Humanizer.OrdinalizeExtensions.Ordinalize(System.String,Humanizer.GrammaticalGender)">
            <summary>
            Turns a number into an ordinal string used to denote the position in an ordered sequence such as 1st, 2nd, 3rd, 4th.
            Gender for Brazilian Portuguese locale
            "1".Ordinalize(GrammaticalGender.Masculine) -> "1"
            "1".Ordinalize(GrammaticalGender.Feminine) -> "1"
            </summary>
            <param name="numberString">The number, in string, to be ordinalized</param>
            <param name="gender">The grammatical gender to use for output words</param>
        </member>
        <member name="M:Humanizer.OrdinalizeExtensions.Ordinalize(System.String,Humanizer.GrammaticalGender,Humanizer.WordForm)">
            <summary>
            Turns a number into an ordinal number used to denote the position in an ordered sequence supporting specific
            locale's variations using the grammatical gender provided
            </summary>
            <example>
            In Spanish:
            <code>
            "1".Ordinalize(GrammaticalGender.Masculine, WordForm.Abbreviation) -> 1.er // As in "Vivo en el 1.er piso"
            "1".Ordinalize(GrammaticalGender.Masculine, WordForm.Normal) -> 1. // As in "Fui el 1 de mi promocin"
            "1".Ordinalize(GrammaticalGender.Feminine, WordForm.Normal) -> 1. // As in "Es 1 vez que hago esto"
            </code>
            </example>
            <param name="numberString">The number to be ordinalized</param>
            <param name="gender">The grammatical gender to use for output words</param>
            <param name="wordForm">Form of the word, i.e. abbreviation</param>
            <returns>The number ordinalized</returns>
        </member>
        <member name="M:Humanizer.OrdinalizeExtensions.Ordinalize(System.String,Humanizer.GrammaticalGender,System.Globalization.CultureInfo)">
            <summary>
            Turns a number into an ordinal string used to denote the position in an ordered sequence such as 1st, 2nd, 3rd, 4th.
            Gender for Brazilian Portuguese locale
            "1".Ordinalize(GrammaticalGender.Masculine) -> "1"
            "1".Ordinalize(GrammaticalGender.Feminine) -> "1"
            </summary>
            <param name="numberString">The number, in string, to be ordinalized</param>
            <param name="gender">The grammatical gender to use for output words</param>
            <param name="culture">Culture to use. If null, current thread's UI culture is used.</param>
        </member>
        <member name="M:Humanizer.OrdinalizeExtensions.Ordinalize(System.String,Humanizer.GrammaticalGender,System.Globalization.CultureInfo,Humanizer.WordForm)">
            <summary>
            Turns a number into an ordinal number used to denote the position in an ordered sequence supporting specific
            locale's variations using the grammatical gender provided
            </summary>
            <example>
            In Spanish:
            <code>
            "1".Ordinalize(GrammaticalGender.Masculine, new CultureInfo("es-ES"),WordForm.Abbreviation) -> 1.er // As in "Vivo en el 1.er piso"
            "1".Ordinalize(GrammaticalGender.Masculine, new CultureInfo("es-ES"), WordForm.Normal) -> 1. // As in "Fui el 1 de mi promocin"
            "1".Ordinalize(GrammaticalGender.Feminine, new CultureInfo("es-ES"), WordForm.Normal) -> 1. // As in "Fui el 1 de mi promocin"
            </code>
            </example>
            <param name="numberString">The number to be ordinalized</param>
            <param name="gender">The grammatical gender to use for output words</param>
            <param name="culture">Culture to use. If null, current thread's UI culture is used.</param>
            <param name="wordForm">Form of the word, i.e. abbreviation</param>
            <returns>The number ordinalized</returns>
        </member>
        <member name="M:Humanizer.OrdinalizeExtensions.Ordinalize(System.Int32)">
            <summary>
            Turns a number into an ordinal number used to denote the position in an ordered sequence such as 1st, 2nd, 3rd, 4th.
            </summary>
            <param name="number">The number to be ordinalized</param>
        </member>
        <member name="M:Humanizer.OrdinalizeExtensions.Ordinalize(System.Int32,Humanizer.WordForm)">
            <summary>
            Turns a number into an ordinal number used to denote the position in an ordered sequence supporting specific locale's variations.
            </summary>
            <example>
            In Spanish:
            <code>
            1.Ordinalize(WordForm.Abbreviation) -> 1.er // As in "Vivo en el 1.er piso"
            1.Ordinalize(WordForm.Normal) -> 1. // As in "Fui el 1 de mi promocin"
            </code>
            </example>
            <param name="number">The number to be ordinalized</param>
            <param name="wordForm">Form of the word, i.e. abbreviation</param>
            <returns>The number ordinalized</returns>
        </member>
        <member name="M:Humanizer.OrdinalizeExtensions.Ordinalize(System.Int32,System.Globalization.CultureInfo)">
            <summary>
            Turns a number into an ordinal number used to denote the position in an ordered sequence such as 1st, 2nd, 3rd, 4th.
            </summary>
            <param name="number">The number to be ordinalized</param>
            <param name="culture">Culture to use. If null, current thread's UI culture is used.</param>
        </member>
        <member name="M:Humanizer.OrdinalizeExtensions.Ordinalize(System.Int32,System.Globalization.CultureInfo,Humanizer.WordForm)">
            <summary>
            Turns a number into an ordinal number used to denote the position in an ordered sequence supporting specific locale's variations.
            </summary>
            <example>
            In Spanish:
            <code>
            1.Ordinalize(new CultureInfo("es-ES"),WordForm.Abbreviation) -> 1.er // As in "Vivo en el 1.er piso"
            1.Ordinalize(new CultureInfo("es-ES"), WordForm.Normal) -> 1. // As in "Fui el 1 de mi promocin"
            </code>
            </example>
            <param name="number">The number to be ordinalized</param>
            <param name="culture">Culture to use. If null, current thread's UI culture is used.</param>
            <param name="wordForm">Form of the word, i.e. abbreviation</param>
            <returns>The number ordinalized</returns>
        </member>
        <member name="M:Humanizer.OrdinalizeExtensions.Ordinalize(System.Int32,Humanizer.GrammaticalGender)">
            <summary>
            Turns a number into an ordinal number used to denote the position in an ordered sequence such as 1st, 2nd, 3rd, 4th.
            Gender for Brazilian Portuguese locale
            1.Ordinalize(GrammaticalGender.Masculine) -> "1"
            1.Ordinalize(GrammaticalGender.Feminine) -> "1"
            </summary>
            <param name="number">The number to be ordinalized</param>
            <param name="gender">The grammatical gender to use for output words</param>
        </member>
        <member name="M:Humanizer.OrdinalizeExtensions.Ordinalize(System.Int32,Humanizer.GrammaticalGender,Humanizer.WordForm)">
            <summary>
            Turns a number into an ordinal number used to denote the position in an ordered sequence supporting specific
            locale's variations using the grammatical gender provided
            </summary>
            <example>
            In Spanish:
            <code>
            1.Ordinalize(GrammaticalGender.Masculine, WordForm.Abbreviation) -> 1.er // As in "Vivo en el 1.er piso"
            1.Ordinalize(GrammaticalGender.Masculine, WordForm.Normal) -> 1. // As in "Fui el 1 de mi promocin"
            1.Ordinalize(GrammaticalGender.Feminine, WordForm.Normal) -> 1. // As in "Es 1 vez que hago esto"
            </code>
            </example>
            <param name="number">The number to be ordinalized</param>
            <param name="gender">The grammatical gender to use for output words</param>
            <param name="wordForm">Form of the word, i.e. abbreviation</param>
            <returns>The number ordinalized</returns>
        </member>
        <member name="M:Humanizer.OrdinalizeExtensions.Ordinalize(System.Int32,Humanizer.GrammaticalGender,System.Globalization.CultureInfo)">
            <summary>
            Turns a number into an ordinal number used to denote the position in an ordered sequence such as 1st, 2nd, 3rd, 4th.
            Gender for Brazilian Portuguese locale
            1.Ordinalize(GrammaticalGender.Masculine) -> "1"
            1.Ordinalize(GrammaticalGender.Feminine) -> "1"
            </summary>
            <param name="number">The number to be ordinalized</param>
            <param name="gender">The grammatical gender to use for output words</param>
            <param name="culture">Culture to use. If null, current thread's UI culture is used.</param>
        </member>
        <member name="M:Humanizer.OrdinalizeExtensions.Ordinalize(System.Int32,Humanizer.GrammaticalGender,System.Globalization.CultureInfo,Humanizer.WordForm)">
            <summary>
            Turns a number into an ordinal number used to denote the position in an ordered sequence supporting specific
            locale's variations using the grammatical gender provided
            </summary>
            <example>
            In Spanish:
            <code>
            1.Ordinalize(GrammaticalGender.Masculine, new CultureInfo("es-ES"),WordForm.Abbreviation) -> 1.er // As in "Vivo en el 1.er piso"
            1.Ordinalize(GrammaticalGender.Masculine, new CultureInfo("es-ES"), WordForm.Normal) -> 1. // As in "Fui el 1 de mi promocin"
            1.Ordinalize(GrammaticalGender.Feminine, new CultureInfo("es-ES"), WordForm.Normal) -> 1. // As in "Fui el 1 de mi promocin"
            </code>
            </example>
            <param name="number">The number to be ordinalized</param>
            <param name="gender">The grammatical gender to use for output words</param>
            <param name="culture">Culture to use. If null, current thread's UI culture is used.</param>
            <param name="wordForm">Form of the word, i.e. abbreviation</param>
            <returns>The number ordinalized</returns>
        </member>
        <member name="T:Humanizer.Plurality">
            <summary>
            Provides hint for Humanizer as to whether a word is singular, plural or with unknown plurality
            </summary>
        </member>
        <member name="F:Humanizer.Plurality.Singular">
            <summary>
            The word is singular
            </summary>
        </member>
        <member name="F:Humanizer.Plurality.Plural">
            <summary>
            The word is plural
            </summary>
        </member>
        <member name="F:Humanizer.Plurality.CouldBeEither">
            <summary>
            I am unsure of the plurality
            </summary>
        </member>
        <member name="T:Humanizer.RomanNumeralExtensions">
            <summary>
            Contains extension methods for changing a number to Roman representation (ToRoman) and from Roman representation back to the number (FromRoman)
            </summary>
        </member>
        <member name="M:Humanizer.RomanNumeralExtensions.FromRoman(System.String)">
            <summary>
            Converts Roman numbers into integer
            </summary>
            <param name="input">Roman number</param>
            <returns>Human-readable number</returns>
        </member>
        <member name="M:Humanizer.RomanNumeralExtensions.FromRoman(System.ReadOnlySpan{System.Char})">
            <summary>
            Converts Roman numbers into integer
            </summary>
            <param name="input">Roman number</param>
            <returns>Human-readable number</returns>
        </member>
        <member name="M:Humanizer.RomanNumeralExtensions.ToRoman(System.Int32)">
            <summary>
            Converts the input to Roman number
            </summary>
            <param name="input">Integer input</param>
            <returns>Roman number</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when the input is smaller than 1 or larger than 3999</exception>
        </member>
        <member name="T:Humanizer.StringDehumanizeExtensions">
            <summary>
            Contains extension methods for dehumanizing strings.
            </summary>
        </member>
        <member name="M:Humanizer.StringDehumanizeExtensions.Dehumanize(System.String)">
            <summary>
            Dehumanizes a string; e.g. 'some string', 'Some String', 'Some string' -> 'SomeString'
            If a string is already dehumanized then it leaves it alone 'SomeStringAndAnotherString' -> 'SomeStringAndAnotherString'
            </summary>
            <param name="input">The string to be dehumanized</param>
        </member>
        <member name="T:Humanizer.StringHumanizeExtensions">
            <summary>
            Contains extension methods for humanizing string values.
            </summary>
        </member>
        <member name="M:Humanizer.StringHumanizeExtensions.Humanize(System.String)">
            <summary>
            Humanizes the input string; e.g. Underscored_input_String_is_turned_INTO_sentence -> 'Underscored input String is turned INTO sentence'
            </summary>
            <param name="input">The string to be humanized</param>
        </member>
        <member name="M:Humanizer.StringHumanizeExtensions.Humanize(System.String,Humanizer.LetterCasing)">
            <summary>
            Humanized the input string based on the provided casing
            </summary>
            <param name="input">The string to be humanized</param>
            <param name="casing">The desired casing for the output</param>
        </member>
        <member name="T:Humanizer.TimeSpanHumanizeExtensions">
            <summary>
            Humanizes TimeSpan into human readable form
            </summary>
        </member>
        <member name="M:Humanizer.TimeSpanHumanizeExtensions.Humanize(System.TimeSpan,System.Int32,System.Globalization.CultureInfo,Humanizer.TimeUnit,Humanizer.TimeUnit,System.String,System.Boolean)">
            <summary>
            Turns a TimeSpan into a human readable form. E.g. 1 day.
            </summary>
            <param name="precision">The maximum number of time units to return. Defaulted is 1 which means the largest unit is returned</param>
            <param name="culture">Culture to use. If null, current thread's UI culture is used.</param>
            <param name="maxUnit">The maximum unit of time to output. The default value is <see cref="F:Humanizer.TimeUnit.Week"/>. The time units <see cref="F:Humanizer.TimeUnit.Month"/> and <see cref="F:Humanizer.TimeUnit.Year"/> will give approximations for time spans bigger 30 days by calculating with 365.2425 days a year and 30.4369 days a month.</param>
            <param name="minUnit">The minimum unit of time to output.</param>
            <param name="collectionSeparator">The separator to use when combining humanized time parts. If null, the default collection formatter for the current culture is used.</param>
            <param name="toWords">Uses words instead of numbers if true. E.g. one day.</param>
        </member>
        <member name="M:Humanizer.TimeSpanHumanizeExtensions.Humanize(System.TimeSpan,System.Int32,System.Boolean,System.Globalization.CultureInfo,Humanizer.TimeUnit,Humanizer.TimeUnit,System.String,System.Boolean)">
            <summary>
            Turns a TimeSpan into a human readable form. E.g. 1 day.
            </summary>
            <param name="precision">The maximum number of time units to return.</param>
            <param name="countEmptyUnits">Controls whether empty time units should be counted towards maximum number of time units. Leading empty time units never count.</param>
            <param name="culture">Culture to use. If null, current thread's UI culture is used.</param>
            <param name="maxUnit">The maximum unit of time to output. The default value is <see cref="F:Humanizer.TimeUnit.Week"/>. The time units <see cref="F:Humanizer.TimeUnit.Month"/> and <see cref="F:Humanizer.TimeUnit.Year"/> will give approximations for time spans bigger than 30 days by calculating with 365.2425 days a year and 30.4369 days a month.</param>
            <param name="minUnit">The minimum unit of time to output.</param>
            <param name="collectionSeparator">The separator to use when combining humanized time parts. If null, the default collection formatter for the current culture is used.</param>
            <param name="toWords">Uses words instead of numbers if true. E.g. one day.</param>
        </member>
        <member name="M:Humanizer.TimeSpanHumanizeExtensions.ToAge(System.TimeSpan,System.Globalization.CultureInfo,Humanizer.TimeUnit,System.Boolean)">
            <summary>
            Turns a TimeSpan into an age expression, e.g. "40 years old"
            </summary>
            <param name="timeSpan">Elapsed time</param>
            <param name="culture">Culture to use. If null, current thread's UI culture is used.</param>
            <param name="maxUnit">The maximum unit of time to output. The default value is <see cref="F:Humanizer.TimeUnit.Year"/>.</param>
            <param name="toWords">Uses words instead of numbers if true. E.g. "forty years old".</param>
            <returns>Age expression in the given culture/language</returns>
        </member>
        <member name="T:Humanizer.TimeUnitToSymbolExtensions">
            <summary>
            Transform a time unit into a symbol; e.g. <see cref="F:Humanizer.TimeUnit.Year"/> => "a"
            </summary>
        </member>
        <member name="M:Humanizer.TimeUnitToSymbolExtensions.ToSymbol(Humanizer.TimeUnit,System.Globalization.CultureInfo)">
            <summary>
            TimeUnit.Day.ToSymbol() -> "d"
            </summary>
            <param name="unit">Unit of time to be turned to a symbol</param>
            <param name="culture">Culture to use. If null, current thread's UI culture is used.</param>
        </member>
        <member name="T:Humanizer.ShowQuantityAs">
            <summary>
            Enumerates the ways of displaying a quantity value when converting
            a word to a quantity string.
            </summary>
        </member>
        <member name="F:Humanizer.ShowQuantityAs.None">
            <summary>
            Indicates that no quantity will be included in the formatted string.
            </summary>
        </member>
        <member name="F:Humanizer.ShowQuantityAs.Numeric">
            <summary>
            Indicates that the quantity will be included in the output, formatted
            as its numeric value (e.g. "1").
            </summary>
        </member>
        <member name="F:Humanizer.ShowQuantityAs.Words">
            <summary>
            Incidates that the quantity will be included in the output, formatted as
            words (e.g. 123 => "one hundred and twenty three").
            </summary>
        </member>
        <member name="T:Humanizer.ToQuantityExtensions">
            <summary>
            Provides extensions for formatting a <see cref="T:System.String"/> word as a quantity.
            </summary>
        </member>
        <member name="M:Humanizer.ToQuantityExtensions.ToQuantity(System.String,System.Int64,Humanizer.ShowQuantityAs)">
            <summary>
            Prefixes the provided word with the number and accordingly pluralizes or singularizes the word
            </summary>
            <param name="input">The word to be prefixed</param>
            <param name="quantity">The quantity of the word</param>
            <param name="showQuantityAs">How to show the quantity. Numeric by default</param>
            <example>
            "request".ToQuantity(0) => "0 requests"
            "request".ToQuantity(1) => "1 request"
            "request".ToQuantity(2) => "2 requests"
            "men".ToQuantity(2) => "2 men"
            "process".ToQuantity(1200, ShowQuantityAs.Words) => "one thousand two hundred processes"
            </example>
        </member>
        <member name="M:Humanizer.ToQuantityExtensions.ToQuantity(System.String,System.Int64,System.String,System.IFormatProvider)">
            <summary>
            Prefixes the provided word with the number and accordingly pluralizes or singularizes the word
            </summary>
            <param name="input">The word to be prefixed</param>
            <param name="quantity">The quantity of the word</param>
            <param name="format">A standard or custom numeric format string.</param>
            <param name="formatProvider">An object that supplies culture-specific formatting information.</param>
            <example>
            "request".ToQuantity(0) => "0 requests"
            "request".ToQuantity(10000, format: "N0") => "10,000 requests"
            "request".ToQuantity(1, format: "N0") => "1 request"
            </example>
        </member>
        <member name="M:Humanizer.ToQuantityExtensions.ToQuantity(System.String,System.Double,System.String,System.IFormatProvider)">
            <summary>
            Prefixes the provided word with the number and accordingly pluralizes or singularizes the word
            </summary>
            <param name="input">The word to be prefixed</param>
            <param name="quantity">The quantity of the word</param>
            <param name="format">A standard or custom numeric format string.</param>
            <param name="formatProvider">An object that supplies culture-specific formatting information.</param>
            <example>
            "request".ToQuantity(0.2) => "0.2 requests"
            "request".ToQuantity(10.6, format: "N0") => "10.6 requests"
            "request".ToQuantity(1.0, format: "N0") => "1 request"
            </example>
        </member>
        <member name="M:Humanizer.ToQuantityExtensions.ToQuantity(System.String,System.Double)">
            <summary>
            Prefixes the provided word with the number and accordingly pluralizes or singularizes the word
            </summary>
            <param name="input">The word to be prefixed</param>
            <param name="quantity">The quantity of the word</param>
            <example>
            "request".ToQuantity(0.2) => "0.2 requests"
            </example>
        </member>
        <member name="T:Humanizer.ICulturedStringTransformer">
            <summary>
            Can transform a string with the given culture
            </summary>
        </member>
        <member name="M:Humanizer.ICulturedStringTransformer.Transform(System.String,System.Globalization.CultureInfo)">
            <summary>
            Transform the input
            </summary>
            <param name="input">String to be transformed</param>
        </member>
        <member name="T:Humanizer.IStringTransformer">
            <summary>
            Can transform a string
            </summary>
        </member>
        <member name="M:Humanizer.IStringTransformer.Transform(System.String)">
            <summary>
            Transform the input
            </summary>
            <param name="input">String to be transformed</param>
        </member>
        <member name="T:Humanizer.To">
            <summary>
            A portal to string transformation using IStringTransformer
            </summary>
        </member>
        <member name="M:Humanizer.To.Transform(System.String,Humanizer.IStringTransformer[])">
            <summary>
            Transforms a string using the provided transformers. Transformations are applied in the provided order.
            </summary>
        </member>
        <member name="M:Humanizer.To.Transform(System.String,System.Globalization.CultureInfo,Humanizer.ICulturedStringTransformer[])">
            <summary>
            Transforms a string using the provided transformers. Transformations are applied in the provided order.
            </summary>
        </member>
        <member name="P:Humanizer.To.TitleCase">
            <summary>
            Changes string to title case
            </summary>
            <example>
            "INvalid caSEs arE corrected" -> "Invalid Cases Are Corrected"
            </example>
        </member>
        <member name="P:Humanizer.To.LowerCase">
            <summary>
            Changes the string to lower case
            </summary>
            <example>
            "Sentence casing" -> "sentence casing"
            </example>
        </member>
        <member name="P:Humanizer.To.UpperCase">
            <summary>
            Changes the string to upper case
            </summary>
            <example>
            "lower case statement" -> "LOWER CASE STATEMENT"
            </example>
        </member>
        <member name="P:Humanizer.To.SentenceCase">
            <summary>
            Changes the string to sentence case
            </summary>
            <example>
            "lower case statement" -> "Lower case statement"
            </example>
        </member>
        <member name="T:Humanizer.TruncateExtensions">
            <summary>
            Allow strings to be truncated
            </summary>
        </member>
        <member name="M:Humanizer.TruncateExtensions.Truncate(System.String,System.Int32)">
            <summary>
            Truncate the string
            </summary>
            <param name="input">The string to be truncated</param>
            <param name="length">The length to truncate to</param>
            <returns>The truncated string</returns>
        </member>
        <member name="M:Humanizer.TruncateExtensions.Truncate(System.String,System.Int32,Humanizer.ITruncator,Humanizer.TruncateFrom)">
            <summary>
            Truncate the string
            </summary>
            <param name="input">The string to be truncated</param>
            <param name="length">The length to truncate to</param>
            <param name="truncator">The truncate to use</param>
            <param name="from">The enum value used to determine from where to truncate the string</param>
            <returns>The truncated string</returns>
        </member>
        <member name="M:Humanizer.TruncateExtensions.Truncate(System.String,System.Int32,System.String,Humanizer.TruncateFrom)">
            <summary>
            Truncate the string
            </summary>
            <param name="input">The string to be truncated</param>
            <param name="length">The length to truncate to</param>
            <param name="truncationString">The string used to truncate with</param>
            <param name="from">The enum value used to determine from where to truncate the string</param>
            <returns>The truncated string</returns>
        </member>
        <member name="M:Humanizer.TruncateExtensions.Truncate(System.String,System.Int32,System.String,Humanizer.ITruncator,Humanizer.TruncateFrom)">
            <summary>
            Truncate the string
            </summary>
            <param name="input">The string to be truncated</param>
            <param name="length">The length to truncate to</param>
            <param name="truncationString">The string used to truncate with</param>
            <param name="truncator">The truncator to use</param>
            <param name="from">The enum value used to determine from where to truncate the string</param>
            <returns>The truncated string</returns>
        </member>
        <member name="T:Humanizer.TruncateFrom">
            <summary>
            Truncation location for humanizer
            </summary>
        </member>
        <member name="F:Humanizer.TruncateFrom.Left">
            <summary>
            Truncate letters from the left (start) of the string
            </summary>
        </member>
        <member name="F:Humanizer.TruncateFrom.Right">
            <summary>
            Truncate letters from the right (end) of the string
            </summary>
        </member>
        <member name="T:Humanizer.FixedLengthTruncator">
            <summary>
            Truncate a string to a fixed length
            </summary>
        </member>
        <member name="T:Humanizer.FixedNumberOfCharactersTruncator">
            <summary>
            Truncate a string to a fixed number of letters or digits
            </summary>
        </member>
        <member name="T:Humanizer.FixedNumberOfWordsTruncator">
            <summary>
            Truncate a string to a fixed number of words
            </summary>
        </member>
        <member name="T:Humanizer.ITruncator">
            <summary>
            Can truncate a string.
            </summary>
        </member>
        <member name="M:Humanizer.ITruncator.Truncate(System.String,System.Int32,System.String,Humanizer.TruncateFrom)">
            <summary>
            Truncate a string
            </summary>
            <param name="value">The string to truncate</param>
            <param name="length">The length to truncate to</param>
            <param name="truncationString">The string used to truncate with</param>
            <param name="truncateFrom">The enum value used to determine from where to truncate the string</param>
            <returns>The truncated string</returns>
        </member>
        <member name="T:Humanizer.Truncator">
            <summary>
            Gets a ITruncator
            </summary>
        </member>
        <member name="P:Humanizer.Truncator.FixedLength">
            <summary>
            Fixed length truncator
            </summary>
        </member>
        <member name="P:Humanizer.Truncator.FixedNumberOfCharacters">
            <summary>
            Fixed number of characters truncator
            </summary>
        </member>
        <member name="P:Humanizer.Truncator.FixedNumberOfWords">
            <summary>
            Fixed number of words truncator
            </summary>
        </member>
        <member name="T:Humanizer.TupleizeExtensions">
            <summary>
            Convert int to named tuple strings (1 -> 'single', 2-> 'double' etc.).
            Only values 1-10, 100, and 1000 have specific names. All others will return 'n-tuple'.
            </summary>
        </member>
        <member name="M:Humanizer.TupleizeExtensions.Tupleize(System.Int32)">
            <summary>
            Converts integer to named tuple (e.g. 'single', 'double' etc.).
            </summary>
            <param name="input">Integer</param>
            <returns>Named tuple</returns>
        </member>
        <member name="T:Humanizer.WordForm">
            <summary>
            Options for specifying the form of the word when different variations of the same word exists.
            </summary>
        </member>
        <member name="F:Humanizer.WordForm.Normal">
            <summary>
            Indicates the normal form of a written word.
            </summary>
        </member>
        <member name="F:Humanizer.WordForm.Abbreviation">
            <summary>
            Indicates the shortened form of a written word.
            </summary>
        </member>
        <member name="F:Humanizer.WordForm.Eifeler">
            <summary>
            Indicates the Eifeler Rule form of a word.
            https://lb.wikipedia.org/wiki/Eifeler_Reegel
            </summary>
        </member>
    </members>
</doc>
